#+title: Holscher's Home Manager Config
#+startup: overview
#+auto_tangle: t

* Notes to my future self
+ To get eduroam working, you need ppp & pptclient
+ Don't let xorg use the nvidia card. It breaks everything

* Flake
#+begin_src nix :noweb yes :tangle flake.nix
  {
    description = "Nixos config flake";

    inputs = {
      <<Flake Inputs>>
    };

    outputs = { self, home-manager, nixgl, nixpkgs, nixpkgs-stable, stylix, ... }@inputs:
      let
        <<Flake Repo Definitions>>
      in
        {
          gpuWrappers = nixgl.defaultPackage;
          # gpuWrappers = nixgl.nixGLNvidia;
          homeConfigurations."holschcc" = home-manager.lib.homeManagerConfiguration {
            <<Flake Home Manager Definition>>
          } ;
        };
  }

#+end_src

** Inputs
#+NAME: Flake Inputs
#+begin_src nix
  nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
  nixpkgs-stable.url = "github:nixos/nixpkgs/nixos-24.11";
  emacs-overlay.url  = "github:nix-community/emacs-overlay";

  stylix.url = "github:danth/stylix";

  apple-fonts.url = "github:Lyndeno/apple-fonts.nix";

  home-manager = {
    url = "github:nix-community/home-manager";
    inputs.nixpkgs.follows = "nixpkgs";
  };

  nixgl = {
    url = "github:nix-community/nixGL"; 
    inputs.nixpkgs.follows = "nixpkgs";
  };

  kmonad = {
    url = "github:kmonad/kmonad?submodules=1&dir=nix";
    inputs.nixpkgs.follows = "nixpkgs";
  };

  # Emacs packages
  gptel-quick = {
    url = "github:karthink/gptel-quick";
    flake = false;
  };

  doom-utils = {
    url = "github:firefoxsalesman/doom-utils";
    flake = false;
  };

  repeaters = {
    url = "github:mmarshall540/repeaters";
    flake = false;
  };

  app-launcher = {
    url = "github:SebastienWae/app-launcher";
    flake = false;
  };

  emacs-embark = {
    url = "github:oantolin/embark";
    flake = false;
  };

  dired-single = {
    url = "github:firefoxsalesman/dired-single";
    flake = false;
  };

  ezf = {
    url = "github:firefoxsalesman/ezf";
    flake = false;
  };

  doom-nano-modeline = {
    url = "github:ronisbr/doom-nano-modeline";
    flake = false;
  };

  symex2 = {
    url = "github:firefoxsalesman/symex.el/2.0-integration";
    flake = false;
  };

  treesitter-context = {
    url = "github:zbelial/treesitter-context.el";
    flake = false;
  };

  eglot-booster = {
    url = "github:jdtsmith/eglot-booster";
    flake = false;
  };

  eglot-x = {
    url = "github:nemethf/eglot-x";
    flake = false;
  };

  org-modern-indent = {
    url = "github:alphapapa/org-modern-indent";
    flake = false;
  };

  mpc-wrapper = {
    url = "github:FirefoxSalesman/mpc-wrapper";
    flake = false;
  };

  exwm-outer-gaps = {
    url = "github:firefoxsalesman/exwm-outer-gaps";
    flake = false;
  };

  exwm-qutebrowser = {
    url = "github:lrustand/qutebrowser.el";
    flake = false;
  };
#+end_src

** Outputs
*** Repo Definitions
#+NAME: Flake Repo Definitions
#+begin_src nix
  system = "x86_64-linux";

  pkgs = import nixpkgs {
    inherit system;
    config.allowUnfree = true;
    overlays = [inputs.emacs-overlay.overlay];
  };
  pkgs-stable = import nixpkgs-stable {
    inherit system;
    config.allowUnfree = true;
  };
#+end_src

*** Home Manager Definition
#+NAME: Flake Home Manager Definition
#+begin_src nix
  inherit pkgs;
  extraSpecialArgs = {
    inherit self;
    inherit inputs;
    inherit system;
    inherit (inputs)  apple-fonts doom-utils repeaters ezf dired-single launcher doom-nano-modeline symex2 treesitter-context gptel-quick eglot-x org-modern-indent mpc-wrapper exwm-qutebrowser exwm-outer-gaps;
    inherit pkgs-stable;
  };
  modules = [
    ./home.nix
    stylix.homeManagerModules.stylix
  ];
#+end_src

* Scripts
** Cast
:PROPERTIES:
:header-args:nix: :tangle scripts/cast.nix
:END:
For moving massive quantities of Jordan Peterson's podcast into my mp3 player
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "cast" ''
    #Exit on fail
    set -e

    #Set Input & Output Filetypes
    in=$(${pkgs.coreutils}/bin/printf 'm4a\nopus\nmp4\nmkv\nwebm' | ezf)
    out=$(${pkgs.coreutils}/bin/printf 'mp3\nflac\nwav\nogg' | ezf)

    #Choose device to transfer to
    device=$(${pkgs.coreutils}/bin/ls /run/media/$USER | ezf)

    #Convert files
    ${(import ./ffmpeg-bulk.nix { inherit pkgs; })}/bin/ffmpeg-bulk *.$in -t $out
    ${pkgs.coreutils}/bin/rm *.$in

    #Remove metadata so the glowies don't see it.
    ${pkgs.python312Packages.mat2}/bin/mat2 *.$out

    #Transfer
    ${pkgs.coreutils}/bin/mv ~/*.cleaned.$out /run/media/$USER/$device/Podcasts
    ${pkgs.coreutils}/bin/rm ~/*.$out
  ''
#+end_src

** Doomer
:PROPERTIES:
:header-args:nix: :tangle scripts/doomer.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "doomer" ''
  ${pkgs.sox}/bin/sox "$1" "$1.flac" pitch -500 treble -20 pad 0 3 reverb 80 tempo .8 highpass 1000 lowpass 700 compand 0.3,0.8 0
  ''
#+end_src

** Ezf
:PROPERTIES:
:header-args:nix: :tangle scripts/ezf.nix
:END:
Borrowed from here: https://github.com/mickeynp/ezf
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "ezf" ''
  set -o nounset -o errexit -o pipefail

  field=0-
  # the elisp function to use for completing read
  candidate_fn=ezf-default
  while getopts c:f: OPT; do
      case $OPT in
          c)
              candidate_fn=$OPTARG
              ;;
          f)
              field=$OPTARG
              ;;
          ,*)
              ${pkgs.coreutils}/bin/echo "usage: ezf [-f field] [-c candidate-fn]"
              exit 2
      esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1

  ezftmp="$(mktemp)"
  trap 'rm -f -- "$ezftmp"' EXIT
  > "$ezftmp" cat -
  # xargs is there to strip the "" from the beginning and end of the
  # output from Emacs.  Ensure "field" is always passed as a string by
  # quoting it.
  selection=$(emacsclient -e "(progn (require 'ezf) (ezf \"$ezftmp\" \"$field\" #'$candidate_fn))" | xargs)
  if [[ "$selection" == "nil" ]]; then
      exit 1
  else
     ${pkgs.coreutils}/bin/echo "$selection"
  fi

  ''
#+end_src

** Ffmpeg-bulk
:PROPERTIES:
:header-args:nix: :tangle scripts/ffmpeg-bulk.nix
:END:
I stole this from this git repo https://github.com/sylsau/ffmpeg-bulk
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "ffmpeg-bulk" ''
  #!/bin/bash - 
  #===============================================================================
  #
  #		  USAGE: ./this.sh --help
  # 
  #	DESCRIPTION: Create a ffmpeg conversion script from a list of input files.
  # 
  #		OPTIONS: ---
  #  REQUIREMENTS: sed, gawk, ffmpeg, tee
  #		   BUGS: ---
  #		  NOTES: ---
  #		 AUTHOR: Sylvain Saubier (ResponSyS), mail@sylsau.com
  #		CREATED: 01/05/16 14:09
  #===============================================================================

  [[ $DEBUG ]] && set -o nounset
  set -o pipefail -o errexit -o errtrace
  trap 'echo -e "''${FMT_BOLD}ERROR''${FMT_OFF}: at $FUNCNAME:$LINENO"' ERR

  readonly FMT_BOLD='\e[1m'
  readonly FMT_UNDERL='\e[4m'
  readonly FMT_OFF='\e[0m'

  readonly PROGRAM_NAME="''${0##*/}"
  readonly SCRIPT_NAME="''${0##*/}"
  RES="$( stat -c %y $0 | cut -d" " -f1 )"
  readonly VERSION=''${RES//-/}

  readonly ERR_NO_CMD=60

  FFMPEG="''${FFMPEG:-ffmpeg}"
  OPT_EXT=
  OPT_ARGS_IN=
  OPT_ARGS_OUT=
  OPT_FORCE=
  OPT_LOGLEVEL="-loglevel error"
  INPUT=( )


  # $1 = command to test (string)
  fn_need_cmd() {
          if ! command -v "$1" > /dev/null 2>&1
                  then fn_err "need '$1' (command not found)" $ERR_NO_CMD
          fi
  }
  # $1 = message (string)
  m_say() {
          echo -e "$PROGRAM_NAME: $1"
  }
  # $1 = error message (string), $2 = return code (int)
  fn_err() {
          m_say "''${FMT_BOLD}ERROR''${FMT_OFF}: $1" >&2
          exit $2
  }

  fn_help() {
          cat << EOF
  $PROGRAM_NAME v$VERSION
          Convert multiple media files at once with ffmpeg.
          In pure and secure bash.
  REQUIREMENTS
          ffmpeg
  USAGE
          $PROGRAM_NAME FILES... (--to|-t) EXTENSION [--args-in|-ai INPUT_ARGS] [--args-out|-ao OUTPUT_ARGS] [--force|-f] [--log-level LOG_LEVEL]
  OPTIONS AND ARGUMENTS
          EXTENSION 		format of output files
          INPUT_ARGS 		ffmpeg arguments for the input file
          OUTPUT_ARGS		ffmpeg arguments for the output file
          --force			overwrite files 
          LOG_LEVEL		change ffmpeg '-loglevel'
                                  (default: 'error', ffmpeg default: 'info')
  EXAMPLE
          Convert all flac and wav files in the current directory to opus with the specified options:
                  $ $PROGRAM_NAME *.flac -t opus --args-out "-b:a 320k" *.wav
  SEE ALSO
          ffmpeg(1)
  AUTHOR
          Written by Sylvain Saubier
  REPORTING BUGS
          Mail at: <feedback@sylsau.com>
  EOF
  }

  fn_show_params() {
          m_say "\n input=''${INPUT[*]}\n -t=$OPT_EXT\n -ai=$OPT_ARGS_IN\n -ao=$OPT_ARGS_OUT\n -f=$OPT_FORCE\n -q=$OPT_LOGLEVEL" >&2
  }


  fn_need_cmd "$FFMPEG"

  # Check args
  if [[ -z "$@" ]]; then
          fn_help
          exit
  else
          while [[ $# -gt 0 ]]; do
                  case "$1" in
                          "--help"|"-h")
                                  fn_help
                                  exit
                                  ;;
                          "--to"|"-t")
                                  OPT_EXT=$2
                                  shift
                                  ;;
                          "--args-in"|"-ai")
                                  OPT_ARGS_IN=$2
                                  shift
                                  ;;
                          "--args-out"|"-ao")
                                  OPT_ARGS_OUT=$2
                                  shift
                                  ;;
                          "--force"|"-f")
                                  OPT_FORCE="-y"
                                  ;;
                          "--log-level")
                                  OPT_LOGLEVEL="-loglevel $2"
                                  shift
                                  ;;
                          ,*)
                                  [[ -e "$1" ]] || fn_err "file '$1' does not exist" 127
                                  INPUT+=( "$1" )
                                  ;;
                  esac	# --- end of case ---
                  shift 	# delete $1
          done
  fi

  [[ $DEBUG ]] && fn_show_params

  [[ $OPT_EXT ]] || fn_err "please specify the output extension with -t EXT" 2

  # Rajoute un point à l'extension si absent
  if [[ ''${OPT_EXT:0:1} != '.' ]]; then
          OPT_EXT=.$OPT_EXT
  fi

  m_say "converting...\n---"
  for F in "''${INPUT[@]}"; do # Just show the commands
          ${pkgs.coreutils}/bin/echo $FFMPEG $OPT_ARGS_IN -i "$F" $OPT_ARGS_OUT $OPT_FORCE $OPT_LOGLEVEL "''${F%.*}$OPT_EXT"
  done ;  ${pkgs.coreutils}/bin/echo "---" ; [[ $DEBUG ]] && exit
  for F in "''${INPUT[@]}"; do # Actually execute
          m_say "converting \"$F\"..."
               $FFMPEG $OPT_ARGS_IN -i "$F" $OPT_ARGS_OUT $OPT_FORCE $OPT_LOGLEVEL "''${F%.*}$OPT_EXT"
  done

  exit
  ''
#+end_src

** Masstube
:PROPERTIES:
:header-args:nix: :tangle scripts/masstube.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "masstube" ''
    emacsclient ~/.download.txt
    ${pkgs.yt-dlp}/bin/yt-dlp $1 --verbose -ci --batch-file=~/.download.txt --proxy socks://localhost:9050
    ${pkgs.coreutils}/bin/rm ~/.download.txt
  ''
#+end_src

** Start-ollama
:PROPERTIES:
:header-args:nix: :tangle scripts/start-ollama.nix
:END:
#+begin_src nix
  { config, pkgs }:

  pkgs.writeShellScriptBin "start-ollama" ''
    if [[ "$(pidof ollama)" -gt 0 ]]; then
        echo "ollama already running"
    else
        ${(config.lib.nixGL.wrap pkgs.ollama)}/bin/ollama serve
    fi
  ''
#+end_src

** Pkg
:PROPERTIES:
:header-args:nix: :tangle scripts/pkg.nix
:END:
A package manager manager

Dev templates: https://github.com/the-nix-way/dev-templates
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "pkg" ''
    optimize() {
      nix-collect-garbage -d
      nix-store --optimise
      doas pacman -Sc --noconfirm
    }

    update() {
      nix flake update --flake ~/.config/home-manager/
      home-manager switch --flake ~/.config/home-manager/#holschcc
      doas nix flake update --flake /etc/system-manager/
      doas nix run 'github:numtide/system-manager' -- switch --flake '/etc/system-manager/'
      yay -Syu
    }

    help() {
      ${pkgs.coreutils}/bin/echo "help: display this message"
      ${pkgs.coreutils}/bin/echo "install [packages]: install packages with yay"
      ${pkgs.coreutils}/bin/echo "optimize: clean up package cache"
      ${pkgs.coreutils}/bin/echo "update: update all packages"
    }

    getTemplates() {
      ${pkgs.coreutils}/bin/printf "bun\nc-cpp\nclojure\ncsharp\ncue\ndhall\nelixir\nelm\nempty\ngleam\ngo\nhashi\nhaskell\nhaxe\njava\njupyter\nkotlin\nlatex\nnickel\nnim\nnix\nnode\nocaml\nopa\nphp\nplatformio\nprotobuf\npulumi\npurescript\npython\nr\nruby\nrust\nrust-toolchain\nscala\nshell\nswi-prolog\nswift\nvlang\nzig" | ezf
    }

    template() {
      nix flake init --template "https://flakehub.com/f/the-nix-way/dev-templates/*#$(getTemplates)" 
      ${pkgs.direnv}/bin/direnv allow
    }

    case "$1" in
      optimize ) optimize ;;
      update ) update ;;
      add ) yay -S ''${@:2} ;;
      rm ) yay -Rs ''${@:2} ;;
      flake ) nix flake ''${@:2} ;;
      template ) template;;
      help ) help ;;
    esac
  ''
#+end_src
** i3status-rust
:PROPERTIES:
:header-args:nix: :tangle scripts/i3status-rust.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "i3status-rust" ''
  ${pkgs.i3status-rust}/bin/i3status-rs config-default.toml
  ''
#+end_src

** Udisksmenu
:PROPERTIES:
:header-args:nix: :tangle scripts/udisksmenu.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "udisksmenu" ''
  action=$(${pkgs.coreutils}/bin/printf 'mount\nunmount' | ${(import ./ezf.nix { inherit pkgs; })}/bin/ezf)
  disk=$(${pkgs.coreutils}/bin/ls /dev | ${pkgs.ripgrep}/bin/rg sd[a-z] | ${(import ./ezf.nix { inherit pkgs; })}/bin/ezf)

  ${pkgs.udisks}/bin/udisksctl $action -b /dev/$disk
  ''
#+end_src

** Wiki
:PROPERTIES:
:header-args:nix: :tangle scripts/wiki.nix
:END:
Requires arch-wiki-docs to be installed

Stole it from Derek Taylor
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "wiki" ''
  dir="/usr/share/doc/arch-wiki/html/en/"
  doc="$(${pkgs.findutils}/bin/find $dir -iname "*.html" | \
         ${pkgs.coreutils}/bin/cut -d '/' -f8- | \
  ${(import ./ezf.nix { inherit pkgs; })}/bin/ezf)"

  if [ "''${dir}$doc" ]; then
      emacsclient -e "(eww-open-file \"''${dir}$doc\")"
  else
      ${pkgs.coreutils}/bin/echo "Program terminated." && exit 0
  fi
  ''
#+end_src

* Home Manager
** Main Config
*** Inputs & Imports
#+begin_src nix :noweb yes :tangle home.nix
  { lib, config, inputs, ... }:

  {
    # This is some text
    # Home Manager needs a bit of information about you and the paths it should
    # manage.
    home.username = "holschcc";
    home.homeDirectory = "/home/holschcc";

    # This value determines the Home Manager release that your configuration is
    # compatible with. This helps avoid breakage when a new Home Manager release
    # introduces backwards incompatible changes.
    #
    # You should not change this value, even if you update Home Manager. If you do
    # want to update the value, then make sure to first check the Home Manager
    # release notes.
    home.stateVersion = "23.05"; # Please read the comment before changing.

    # Let Home Manager install and manage itself.
    programs.home-manager.enable = true;

    imports =
      [ # Include the results of the hardware scan.
        ./internet.nix
        ./multimedia.nix
        ./aesthetics.nix
        ./extra-packages.nix
        ./gui.nix
        ./emacs.nix
        ./shells.nix
        ./sage.nix
        ./keyboard.nix
      ];

    nix.nixPath = [ "nixpkgs=${inputs.nixpkgs}" ];

    <<glx>>

    <<GPG>>

    <<alsoftrc>>

    <<Environment Variables>>

    <<User Dirs>>
  }
#+end_src

*** glx
#+NAME: glx
#+begin_src nix
  nixGL.packages = inputs.nixgl.packages;

  targets.genericLinux.enable = true;

  home.activation = {
    clearNixglCache = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
        [ -v DRY_RUN ] || rm -f ${config.xdg.cacheHome}/nixgl/result*
      '';
  };

#+end_src

*** gpg
#+NAME: GPG
#+begin_src nix
  home.file.".local/share/gnupg/gpg-agent.conf".text = ''
     pinentry-program /usr/bin/pinentry-emacs
     allow-loopback-pinentry
     allow-emacs-pinentry
     default-cache-ttl 600
     max-cache-ttl 7200
     enable-ssh-support
  '';
  home.file.".local/share/gnupg/gpg.conf".text = ''
     use-agent
  '';
#+end_src

*** alsoftrc
#+NAME: alsoftrc
#+begin_src nix
  home.file.".alsoftrc".text = ''
    [general]
    drivers=pulse
    hrtf=true
  '';
#+end_src

*** Environment variables
#+NAME: Environment Variables
#+begin_src nix
  home.sessionVariables = {
    XDG_DATA_HOME="$HOME/.local";
    XDG_STATE_HOME="$HOME/.local/state";
    XDG_CACHE_HOME="$HOME/.cache";
    XDG_CONFIG_HOME="$HOME/.config";
    XDG_DATA_DIRS= lib.mkForce "$HOME/.nix-profile/share:$XDG_DATA_DIRS";
    # EDITOR = "emacsclient";
    BROWSER="qutebrowser";
    _JAVA_OPTIONS="-Djava.util.prefs.userRoot=$XDG_CONFIG_HOME/java";
    GTK2_RC_FILES="/home/holschcc/.gtkrc-2.0";
    SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)";
    _JAVA_AWT_WM_NONREPARENTING = "1";
    PATH="/run/system-manager/sw/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/holschcc/bin:/home/holschcc/.nix-profile/bin";
  };
#+end_src

*** User Dirs
#+NAME: User Dirs
#+begin_src nix
  xdg.userDirs = {
      enable = true;
      createDirectories = true;
      desktop = null;
      publicShare = null;
      templates = null;
      documents = "${config.home.homeDirectory}/doc";
      download = "${config.home.homeDirectory}/dwn";
      music = "${config.home.homeDirectory}/mus";
      pictures = "${config.home.homeDirectory}/pic";
      videos = "${config.home.homeDirectory}/vid";
    };
#+end_src

** shells
*** boilerplate
#+begin_src nix :noweb yes :tangle shells.nix
  { pkgs, ... }:
  {
    imports = [
          ./dash.nix
    ];

    <<Shell Aliases>>

    programs = {
      <<Fish Shell>>

      <<Bash Shell>>

      <<Atuin>>

      <<Starship>>

      <<Direnv>>

      <<Dash Shell>>

      emacs.init.usePackage = {
        <<Eshell>>
      };
    };
  }
#+end_src

*** aliases
#+NAME: Shell Aliases
#+begin_src nix
  home.shellAliases = {
    ffrecord = "ffmpeg -f sndio -i snd/0.mon -f x11grab -r 30 -s 1920x1080 -i :0 -c:v libx164 -preset ultrafast -acodec copy ~/test.mkv";
    ffaud = "ffmpeg -f alsa -channels 1 -sample_rate 44100 -i default:CARD=Mic output.flac";
    sx = "startx";
    otp = "pass otp";
    run = "cd /run/";
    l = "ls";
    ".." = "cd ..";
    tortube = "yt-dlp --proxy socks://localhost:9050";
    wget = "torsocks wget --hsts-file=$XDG_DATA_HOME/wget-hsts";
    ga = "git add";
    gc = "torsocks git clone";
    gp = "git pull";
    gP = "git push";
  };
#+end_src

*** fish
This shell is mostly around for eshell to get completions from, but it can be used interactively, if need be
#+NAME: Fish Shell
#+begin_src nix
  fish = {
    enable = true;
    package = pkgs.fish;
    interactiveShellInit = ''${pkgs.pfetch}/bin/pfetch'';
  };
#+end_src

*** bash
It's mostly here for eshell to get completions from, but it's a usable shell
#+NAME: Bash Shell
#+begin_src nix
  bash = {
    enable = true;
    initExtra = ''${pkgs.pfetch}/bin/pfetch'';
    shellAliases.z = "cd ./$(ls -d */ .*/ | ezf)";
  };
#+end_src

*** atuin
Gives us a consistent shell history across all our shells
#+NAME: Atuin
#+begin_src nix
  atuin = {
    enable = true;
    enableFishIntegration = true;
    enableBashIntegration = true;
  };

  emacs.init.usePackage.eshell-atuin = {
      enable = true;
      afterCall = ["eshell-mode"];
      generalTwo."'insert".eshell-mode-map."M-O" = "'eshell-atuin-history";
      config = "(eshell-atuin-mode)";
  };
#+end_src

*** starship
a prompt for bash & fish
#+NAME: Starship
#+begin_src nix
  starship = {
    enable = true;
    enableFishIntegration = true;
    enableBashIntegration = true;
  };
#+end_src

*** direnv
#+NAME: Direnv
#+begin_src nix
  direnv = {
    enable = true;
    enableBashIntegration = true;
    nix-direnv.enable = true;
  };

  emacs.init.usePackage.envrc = {
      enable = true;
      ghook = ["('after-init-hook 'envrc-global-mode)"];
      generalOne."efs/leader-keys" = {
        "e" = '''(:ignore t :which-key "direnv")'';
        "ea" = '''(envrc-allow :which-key "allow")'';
        "eu" = '''(envrc-reload :which-key "update dir")'';
      };
  };
#+end_src

*** Eshell
Eshell is a command shell written in elisp, & duplicates many of the GNU coreutils in elisp. It can also call aliases & elisp functions.

=Key Bindings=
+ =[[= / =]]= Go backwards & forwards in the buffer's prompts.

Eat lets us get away with using eshell all the time. It can be used to get into a normal shell, but I doubt I'll be doing that too much.
#+NAME: Eshell
#+begin_src nix :noweb yes
    eshell = {
      enable = true;
      after = ["evil-collection"];
      ghook = [
        "('eshell-first-time-mode-hook 'efs/configure-eshell)"
        #Save command history when commands are entered
        "('eshell-precommand-hook 'eshell-save-some-history)"
        #pfetch
        ''('eshell-banner-load-hook  (lambda ()
                                       (gsetq eshell-banner-message
                                          (shell-command-to-string "${pkgs.pfetch}/bin/pfetch"))))''
      ];
      general."s-<enter>" = "'efs/make-eshell";
      generalOne.eshell-mode-map = {
        "M-o" = "'eshell-previous-matching-input-from-input";
        "M-e" = "'eshell-next-matching-input-from-input";
      };
      generalTwo.local-leader.eshell-mode-map = {
        "e" = '''(eshell-insert-envvar :which-key "insert environment variable")'';
        "b" = '''(eshell-insert-buffer-name :which-key "insert buffer name")'';
      };
      init = ''
    <<Emacs Eshell Init>>
  '';
      config = ''
    <<Emacs Eshell Config>>
  '';
    } ;

    eshell-syntax-highlighting = {
      enable = true;
      defer = true;
      ghook = ["('eshell-mode-hook 'eshell-syntax-highlighting-global-mode)"];
    };

    fish-completion = {
      enable = true;
      defer = true;
      ghook = ["('eshell-mode-hook 'fish-completion-mode)"];
    };

    eshell-git-prompt = {
      enable = true;
      afterCall = ["eshell-mode"];
      config = ''(eshell-git-prompt-use-theme 'powerline)'';
    };

    eat = {
      enable = true;
      defer = true;
      afterCall = ["eshell-mode"];
      config = ''
        <<Emacs Eat Config>>
      '';
    };
#+end_src

#+NAME: Emacs Eshell Init
#+begin_src emacs-lisp
  (defun efs/make-eshell ()
    (interactive)
    (eshell 'N))
#+end_src

#+NAME: Emacs Eshell Config
#+begin_src emacs-lisp
  (defun efs/configure-eshell ()
    ;; Truncate buffer for perforance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)
    (setenv "TERM" "xterm")
    (gsetq eshell-command-aliases-list '(("gc" "torsocks git clone")
  				       ("nixbuild" "home-manager switch --flake ~/.config/home-manager/#holschcc")
  				       ("l" "ls $*")
  				       ("halt" "doas shutdown -P now")
  				       ("systembuild" "doas nix run 'github:numtide/system-manager' -- switch --flake '/etc/system-manager/'"))
  	 eshell-history-size 0
           eshell-buffer-maximum-lines 100
           eshell-hist-ignoredups t
           eshell-scroll-to-bottom-on-input t))

  (with-eval-after-load 'esh-opt
    (gsetq eshell-destroy-buffer-when-process-dies t))

  (with-eval-after-load 'evil-collection-eshell
    (general-add-advice 'evil-collection-eshell-setup-keys
  		:after
  		'(lambda ()
  		   (general-def 'normal eshell-mode-map
  		     "v" 'evil-collection-eshell-evil-delete
  		     "V" 'evil-collection-eshell-evil-change
  		     "C-v" 'evil-collection-eshell-evil-delete-line
  		     "d" 'evil-yank
  		     "D" 'evil-yank-line
  		     "c" 'evil-visual-state
  		     "C" 'evil-visual-line))))
#+end_src

#+NAME: Emacs Eat Config
#+begin_src emacs-lisp
  (eat-eshell-mode)
  (evil-ex-define-cmd "term" 'eat)
  (defun eat-term-get-suitable-term-name (&optional display)
    "Return the most suitable value for `TERM' for DISPLAY.

    If the number of colors supported by display (as returned by
    `display-color-cells') is more than 256, return \"eat-truecolor\", if
    it is more than 8 but less than or equal to 256, return
    \"eat-256color\", if is more than 1 but less than or equal to 8,
    return \"eat-color\", otherwise return \"eat-mono\"."
    (let ((colors (display-color-cells display)))
      (cond ((> colors 256) "xterm")
            ((> colors 8) "xterm")
            ((> colors 1) "xterm")
            (t "xterm"))))

#+end_src

*** dash
Probably won't use this one interactively much, but it's my login shell, & my /bin/sh, so it may as well be nice
#+NAME: Dash Shell
#+begin_src nix
  dash = {
    enable = true;
    initExtra = ''
      ${pkgs.pfetch}/bin/pfetch
      . ~/.cache/wal/colors.sh
    '';
    shellAliases.z = "cd ./$(ls -d */ .*/ | ezf)";
    profileExtra = ''
      export LEIN_HOME="$XDG_DATA_HOME/lein";
      export NPM_CONFIG_USERCONFIG="$XDG_CONFIG_HOME/npm/npmrc";
      export XCOMPOSECACHE="$XDG_CACHE_HOME/x11/xcompose";
      export GOPATH="$XDG_DATA_HOME/go";
      export DOT_SAGE="$XDG_CONFIG_HOME/sage";
      export XAUTHORITY="$XDG_RUNTIME_DIR/Xauthority";
      export CARGO_HOME="$XDG_DATA_HOME/cargo";
      export GNUPGHOME="$XDG_DATA_HOME/share/gnupg";
      export PASSWORD_STORE_DIR="$XDG_DATA_HOME/share/pass";
      export CUDA_CACHE_PATH="$XDG_CACHE_HOME/nv";
      export ERRFILE="$XDG_CACHE_HOME/X11/xsession-errors"
      export XINITRC="$XDG_CONFIG_HOME"/X11/xinitrc
      export HISTFILE="''${XDG_STATE_HOME}"/bash/history
      GRADLE_USER_HOME="$XDG_DATA_HOME"/gradle
      
      [ "$(tty)" = "/dev/tty1" ] && ! pidof -s Xorg >/dev/null 2>&1 && exec startx
    '';
  };
#+end_src

**** Configuration template
This one borrows heavily from the bash module

Special note: The profile settings here take precedence over bash's, because I'm too dumb to make them coexist

***** Premble
#+begin_src nix :noweb yes :tangle dash.nix
  { config, lib, pkgs, ... }:

  with lib;

  let

    cfg = config.programs.dash;

    writeBashScript = name: text:
      pkgs.writeTextFile {
        inherit name text;
        checkPhase = ''
          ${pkgs.stdenv.shellDryRun} "$target"
        '';
      };

  in {
    meta.maintainers = [ maintainers.rycee ];
    <<Dash Option Definitions>>
    
    <<Dash File Generation>>
  }
#+end_src

***** Option Definitions
#+NAME: Dash Option Definitions
#+begin_src nix
    options = {
      programs.dash = {
        enable = mkEnableOption "Debian Almquiest Shell";

        shellOptions = mkOption {
          type = types.listOf types.str;
          default = [];
          example = [ "extglob" "-cdspell" ];
          description = ''
            Shell options to set. Prefix an option with
            "`-`" to unset.
          '';
        };

        sessionVariables = mkOption {
          default = { };
          type = types.attrs;
          example = { MAILCHECK = 30; };
          description = ''
            Environment variables that will be set for the dash session.
          '';
        };

        shellAliases = mkOption {
          default = { };
          type = types.attrsOf types.str;
          example = literalExpression ''
            {
              ll = "ls -l";
              ".." = "cd ..";
            }
          '';
          description = ''
            An attribute set that maps aliases (the top level attribute names in
            this option) to command strings or directly to build outputs.
          '';
        };

        profileExtra = mkOption {
          default = "";
          type = types.lines;
          description = ''
            Extra commands that should be run when initializing a login
            shell.
          '';
        };

        initExtra = mkOption {
          default = "";
          type = types.lines;
          description = ''
            Extra commands that should be run when initializing an
            interactive shell.
          '';
        };

        dashrcExtra = mkOption {
          default = "";
          type = types.lines;
          description = ''
            Extra commands that should be placed in {file}`~/.dashrc`.
            Note that these commands will be run even in non-interactive shells.
          '';
        };
      };
    };
#+end_src

***** File generation
#+NAME: Dash File Generation
#+begin_src nix
    config = let
      aliasesStr = concatStringsSep "\n"
        ((mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
          cfg.shellAliases) ++ 
        (mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
          config.home.shellAliases));

      globalAliasesStr = concatStringsSep "\n"
        (mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
          home.shellAliases);

      shoptsStr = let switch = v: if hasPrefix "-" v then "-u" else "-s";
      in concatStringsSep "\n"
      (map (v: "shopt ${switch v} ${removePrefix "-" v}") cfg.shellOptions);

      sessionVarsStr = config.lib.shell.exportAll cfg.sessionVariables;

    in mkIf cfg.enable {
      home.file.".profile".source = lib.mkForce (writeBashScript "profile" ''
        . "${config.home.profileDirectory}/etc/profile.d/hm-session-vars.sh"

        ${sessionVarsStr}

        ${cfg.profileExtra}
      '');

      home.file.".dashrc".source = writeBashScript "dashrc" ''
        ${cfg.dashrcExtra}

        ${shoptsStr}

        ${aliasesStr}

        ${cfg.initExtra}
      '' ;

      home.sessionVariables.ENV = "$HOME/.dashrc";
    };
#+end_src

** Aesthetics
*** Inputs
#+begin_src nix :noweb yes :tangle aesthetics.nix
  { config, inputs, lib, pkgs, ... }:

  {
    <<Stylix Config>>

    <<Aesthetics Picom>>

    programs.emacs.init.usePackage = {
      <<Emacs Ricing Icons>>
      
      <<Emacs Ricing Dashboard>>
      
      <<Emacs Ricing Nano>>

      <<Emacs Ricing Theme>>
      
      <<Emacs Ricing Solaire>>
      
      <<Emacs Ricing Posframes>>
    };
  }
#+end_src

*** Picom
For making emacs transparent
#+NAME: Aesthetics Picom
#+begin_src nix
  services.picom = {
    enable = true;
    package = (config.lib.nixGL.wrap pkgs.picom);
    backend = "glx";
    opacityRules = [ "70:class_g = 'lmms'" ];
    settings = {
      glx-no-stencil = true;
      glx-no-rebind-pixmap = true;
      use-damage = true;
      vsync = true;
      blur = {
        method = "gaussian";
        size = 5;
        deviation = 2.0;
      };
      shadow-exclude = [ "class_g != 'emacs'"
      ];
    };
    shadow = true;
  };
#+end_src

*** Stylix
Stylix does a bad job of theming emacs, so we use pywal instead

Pywal integration: https://github.com/danth/stylix/issues/99
#+NAME: Stylix Config
#+begin_src nix
  stylix = {
    enable = true;
    polarity = "dark";
    targets.emacs.enable = false;
    image = ./wallpaper.png;
    cursor = {
      package = pkgs.nordzy-cursor-theme;
      name = "Nordzy-cursors-white";
      size = 16;
    };
    opacity = {
      applications = 0.9;
      popups = 0.9;
      terminal = 0.9;
    };
    fonts = with pkgs; rec {
      monospace = {
        package = jetbrains-mono;
        name = "JetBrains Mono";
      };
      sansSerif = {
        package = inputs.apple-fonts.packages.${system}.sf-pro;
        name = "SF Pro";
      };
      serif = sansSerif;
    };
  };

  home.file = {
    ".cache/colors.json".source = config.lib.stylix.colors {
      template = builtins.readFile ./pywal.json.mustache;
      extension = ".json";
    };
  };

  home.activation =  #ALSO ACTIVATES AT REBOOT
    {
      generate_pywal_colors = lib.hm.dag.entryAfter ["writeBoundary"] ''
         $DRY_RUN_CMD ${pkgs.pywal}/bin/wal -f ~/.cache/colors.json
         $DRY_RUN_CMD ${pkgs.pywal}/bin/wal -R
       '';
    } ;
#+end_src

*** Icons
Installs all the icon fonts for dired.

Use =M-x all-the-icons-install-fonts=
#+NAME: Emacs Ricing Icons
#+begin_src nix
  nerd-icons = {
    enable = true;
    command = [
      "nerd-icons-octicon"
      "nerd-icons-faicon"
      "nerd-icons-flicon"
      "nerd-icons-wicon"
      "nerd-icons-mdicon"
      "nerd-icons-codicon"
      "nerd-icons-devicon"
      "nerd-icons-ipsicon"
      "nerd-icons-pomicon"
      "nerd-icons-powerline"
    ];
  };

  all-the-icons = {
    enable = true;
  };

  nerd-icons-completion = {
    enable = true;
    ghook = ["('marginalia-mode-hook 'nerd-icons-completion-marginalia-setup)"];
  };
#+end_src

*** Dashboard
#+NAME: Emacs Ricing Dashboard
#+begin_src nix :noweb yes
  dashboard = {
    enable = true;
    ghook = ["('on-init-ui-hook '(dashboard-insert-startupify-lists dashboard-initialize))"];
    config = ''
      <<Emacs Dashboard Config>>  
    '' ;
    custom = {
      dashboard-banner-logo-title = ''"Emacs: The one true desktop environment"'';
      dashboard-center-content = "t";
      dashboard-items = '''((recents   . 5)
                            (bookmarks . 5)
                            (projects  . 5)
                            (agenda    . 5))'';
      dashboard-icon-type = "'nerd-icons";
      dashboard-set-heading-icons = "t";
      dashboard-set-file-icons = "t";
      dashboard-agenda-sort-strategy = "'(time-up)";
    };
  };
#+end_src

#+NAME: Emacs Dashboard Config
#+begin_src emacs-lisp
  (dashboard-setup-startup-hook)
  (dashboard-open)
  (evil-collection-dashboard-setup)
  (evil-collection-dashboard-setup-jump-commands)
#+end_src

*** Nano
Using nano modeline to cut down clutter.

I'm not using the minor mode, because its text is being sent to the tab bar.

The powerline separators were borrowed from punchline, because I think they look cool
#+NAME: Emacs Ricing Nano
#+begin_src nix :noweb yes
  doom-nano-modeline = {
    enable = true;
    package = epkgs: (epkgs.callPackage ./emacs/emacs-packages/doom-nano-modeline.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild doom-themes;
    });
    afterCall = ["after-init-hook"];
    custom.mode-line-format = "nil";
    config = ''
      <<Emacs Doom Nano Modeline Config>>
    '';
  };
#+end_src

This is just overriding a bunch of functions so that I can put all the info in the tab bar
#+NAME: Emacs Doom Nano Modeline Config
#+begin_src emacs-lisp
  (defun doom-nano-modeline--render (left right &optional hide-evil-mode)
    "Render the doom-nano modeline string.

    LEFT is the information that will be rendered to the left of the modeline. RIGHT
    is the information that will be rendered to the right of modeline. Both
    variables must be a list in which each element has the following syntax:

        (text . face)

    where TEXT will be decorated with FACE.

    If HIDE-EVIL-MODE is nil, the Evil mode state is not shown in the modeline."
    (let* ((window (get-buffer-window (current-buffer)))

           ;; Variable to store if the this window is active.
  	 (active t)

           ;; Status of the buffer.
           (status (doom-nano-modeline-status))

           ;; Check if we are recording a macro and get its name.
           (hasmacro (or defining-kbd-macro executing-kbd-macro))
           (macroname (if (bound-and-true-p evil-this-macro)
                          (char-to-string evil-this-macro)
                        "?"))

           ;; String to indicate the current evil mode.
           (evilstate
            (if hide-evil-mode
                nil
              (concat (cond ((eq evil-state 'emacs)    "E ")
                            ((eq evil-state 'motion)   "M ")
                            ((eq evil-state 'normal)   "N ")
                            ((eq evil-state 'insert)   "I ")
                            ((eq evil-state 'replace)  "R ")
                            ((eq evil-state 'operator) "O ")
                            ((eq evil-state 'god) "G ")
                            ((eq evil-state 'symex) "S ")
                            ((eq evil-state 'visual) (cond ((eq evil-visual-selection 'line)  "L ")
                                                           ((eq evil-visual-selection 'block) "B ")
                                                           (t                                 "V ")))
                            (t "? ")))))

           ;; String to indicate if a macro is being recorded.
           (macrostring (if hasmacro (concat "● " macroname ) nil))

           ;; Select the modeline face.
  	 (modeline-face 'doom-nano-modeline-active-face)

           ;; Select the face to highlight the evil state.
           (evilstate-face
            (cond (hide-evil-mode            modeline-face)
                  ((not active)              modeline-face)
                  ((eq evil-state 'emacs)    'doom-nano-modeline-evil-emacs-state-face)
                  ((or (eq evil-state 'normal) (eq evil-state 'god) (eq evil-state 'symex))   'doom-nano-modeline-evil-normal-state-face)
                  ((eq evil-state 'motion)   'doom-nano-modeline-evil-motion-state-face)
                  ((eq evil-state 'insert)   'doom-nano-modeline-evil-insert-state-face)
                  ((eq evil-state 'replace)  'doom-nano-modeline-evil-replace-state-face)
                  ((eq evil-state 'operator) 'doom-nano-modeline-evil-operator-state-face)
                  ((eq evil-state 'visual)   'doom-nano-modeline-evil-visual-state-face)
                  (t                         modeline-face)))

           ;; Select the face to highlight the macro recording indicator.
           (macro-face (if hasmacro 'doom-nano-modeline-macro-face modeline-face))

           ;; Assemble the left string with the highlights.
           (pleft (concat
                   (propertize " "
                               'face evilstate-face
                               'display `(raise ,doom-nano-modeline-top-padding))

                   ;; Evil state.
                   (when evilstate
                     (concat (propertize evilstate 'face evilstate-face)
                             (propertize " " 'face modeline-face)))

                   ;; Macro recording indicator.
                   (when macrostring
                     (concat (propertize macrostring 'face macro-face)
                             (propertize " " 'face modeline-face)))

                   ;; Left list.
                   (if left
                       (mapconcat
                        (lambda (element)
                          (if (and active (cdr element))
                              (propertize (car element) 'face (cdr element))
                            (propertize (car element) 'face modeline-face)))
                        left
                        "")
                     ""))))

      ;; Concatenate and return the modeline string.
      (concat pleft
              ;; We have one final space as margin, so we make sure it is
              ;; highlighted with the correct face.
              (propertize " " 'face modeline-face))))

  (defun doom-nano-modeline-org-mode-buffer-name-and-major-mode ()
    "Return the buffer name and the major mode for Org buffers."
    (if (derived-mode-p 'org-mode)
        (let* ((org-title (doom-nano-modeline--get-org-title))
               (buffer-name (if org-title
                                org-title
                              (format-mode-line "%b")))
               (buffer-modified (if (and buffer-file-name (buffer-modified-p)) "** " "")))

          `((,(concat buffer-modified buffer-name) . nil)
  	  ("  " . nil)
            (,(nerd-icons-icon-for-buffer) . doom-nano-modeline-major-mode-face)
  	  ("  " . nil)))
      (doom-nano-modeline-default-mode)))

  (defun doom-nano-modeline-buffer-name-vc-and-major-mode ()
    "Return the buffer name and the major mode."
    (let* ((buffer-name (cond
                         ((and (derived-mode-p 'org-mode)
                               (buffer-narrowed-p)
                               (buffer-base-buffer))
                          (format"%s [%s]" (buffer-base-buffer)
                                 (org-link-display-format
                                  (substring-no-properties (or (org-get-heading 'no-tags)
                                                               "-")))))
                         ((and (buffer-narrowed-p)
                               (buffer-base-buffer))
                          (format"%s [narrow]" (buffer-base-buffer)))
                         (t
                          (format-mode-line "%b"))))

           (buffer-modified (if (and buffer-file-name (buffer-modified-p)) "** " ""))

           (vc-branch-name (doom-nano-modeline--get-vc-branch))

           (vc-branch (if vc-branch-name
                          `((vc-branch-name . nil))
                        nil)))

      `((,(concat buffer-modified buffer-name) . nil)
        ("  " . nil)
        (,(if vc-branch-name (concat vc-branch-name " ") "") . doom-nano-modeline-vc-branch-name-face)
        (,(if vc-branch-name " " "") . nil)
        (,(if (or (equal major-mode 'nix-mode) (equal major-mode 'bibtex-mode)) (all-the-icons-icon-for-buffer) (nerd-icons-icon-for-buffer)) . doom-nano-modeline-major-mode-face)
        ("  " . nil))))

  (defun doom-nano-modeline--special-mode-p ()
    "Return t if we are in `special-mode' or nil otherwise."
    (or (derived-mode-p 'special-mode) (and (eq major-mode 'exwm-mode) (not qutebrowser-exwm-mode))))

  (defun doom-nano-tabline ()
    "Format the modeline for the tabline"
    (let* ((the-format '((:eval
  			(funcall
  			 (or (catch 'found
  			       (dolist (elt doom-nano-modeline-mode-formats)
  				 (let* ((config (cdr elt))
  					(mode-p (plist-get config :mode-p))
  					(format (plist-get config :format)))
  				   (when mode-p
  				     (when (funcall mode-p)
  				       (throw 'found format))))))
  			     #'doom-nano-modeline-default-mode-format))))))
      `((global menu-item ,(format-mode-line the-format) ignore))))
#+end_src

**** Package Definition
#+begin_src nix :tangle emacs/emacs-packages/doom-nano-modeline.nix
  { inputs, trivialBuild, doom-themes } :

  trivialBuild rec {
    pname = "doom-nano-modeline";
    version = "current";
    src = inputs.doom-nano-modeline;

    propagatedUserEnvPkgs = [
      doom-themes
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

*** Emacs Theme
Makes emacs' theme mimic the wallpaper. A good pywal config will get most things to match.
#+NAME: Emacs Ricing Theme
#+begin_src nix :noweb yes
  ewal = {
    enable = true;
    demand = true;
    custom = {
      ewal-use-built-in-always-p = "nil";
      ewal-use-built-in-on-failure-p = "t";
      ewal-built-in-palette = ''"sexy-material"'';
    };
  };

  ewal-doom-themes = {
    enable = true;
    demand = true;
    config = ''
      <<Emacs Ewal Config>>
    '';
    custom = {
      doom-themes-enable-bold = "t";
      doom-themes-enable-italic = "t";
    };
  };
#+end_src

#+NAME: Emacs Ewal Config
#+begin_src emacs-lisp
  (load-theme 'ewal-doom-one t)
  ;; Stolen from Noctuid
  (let (custom--inhibit-theme-enable)
    (custom-theme-set-faces
     'ewal-doom-one
     `(font-lock-number-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-header-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-header-delimiter-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-bold-face ((t (:foreground ,(ewal-get-color 'green)))))
     `(markdown-list-face ((t (:foreground ,(ewal-get-color 'green)))))
     `(org-code ((t (:foreground ,(ewal-get-color 'green)))))
     `(line-number ((t (:foreground ,(ewal-get-color 'blue)))))
     `(eshell-git-prompt-powerline-dir-face ((t (:background ,(ewal-get-color 'blue)))))
     `(tab-bar ((t :inherit mode-line)))
     `(eshell-git-prompt-powerline-clean-face ((t (:background ,(ewal-get-color 'green)))))
     `(eshell-git-prompt-powerline-not-clean-face ((t (:background ,(ewal-get-color 'red)))))))
  (doom-themes-visual-bell-config)
  (doom-themes-org-config)
#+end_src

*** Solaire
Solaire dims certain parts of the frame.
#+NAME: Emacs Ricing Solaire
#+begin_src nix
  solaire-mode = {
    enable = true;
    demand = true;
    config = ''(solaire-global-mode)'';
  };
#+end_src

*** Posframes
Vertico Posframe puts vertico in a separate frame, causing it to actually look like dmenu.
#+NAME: Emacs Ricing Posframes
#+begin_src nix
  vertico-posframe = {
    enable = true;
    defer = true;
    ghook = ["('vertico-mode-hook 'vertico-posframe-mode)"];
    config = ''(set-face-attribute 'vertico-posframe-face nil :family 'variable-pitch)'';
  };

  which-key-posframe = {
    enable = true;
    defer = true;
    ghook = ["('which-key-mode-hook 'which-key-posframe-mode)"];
    custom = {
      which-key-posframe-poshandler = "'posframe-poshandler-frame-bottom-center";
      which-key-posframe-parameters = "'(:parent-frame nil :refposhandler posframe-refposhandler-xwininfo)";
    };
  };
#+end_src

*** Mustache File
#+begin_src json-ts :tangle pywal.json.mustache
  {
      "special": {
          "background": "#{{base00-hex}}",
          "foreground": "#{{base07-hex}}",
          "cursor": "#{{base07-hex}}"
      },
      "colors": {
          "color0": "#{{base00-hex}}",
          "color1": "#{{base01-hex}}",
          "color2": "#{{base02-hex}}",
          "color3": "#{{base03-hex}}",
          "color4": "#{{base04-hex}}",
          "color5": "#{{base05-hex}}",
          "color6": "#{{base06-hex}}",
          "color7": "#{{base07-hex}}",
          "color8": "#{{base08-hex}}",
          "color9": "#{{base09-hex}}",
          "color10": "#{{base0A-hex}}",
          "color11": "#{{base0B-hex}}",
          "color12": "#{{base0C-hex}}",
          "color13": "#{{base0D-hex}}",
          "color14": "#{{base0E-hex}}",
          "color15": "#{{base0F-hex}}"
      }
  }

#+end_src

** Extra Packages
#+begin_src nix :tangle extra-packages.nix
  { config, pkgs, pkgs-stable, ... }:

  {
    home.packages = with pkgs; [
      (config.lib.nixGL.wrap gimp)
      # (config.lib.nixGL.wrap prismlauncher)
      wget
      zip
      zbar
      # comms
      (config.lib.nixGL.wrap teams-for-linux)
      (config.lib.nixGL.wrap thunderbird)
      (vesktop.override {withSystemVencord = true;})
      # things emacs appreciates
      xclip
      xsel
      xdotool
      # scripts
      (import ./scripts/ezf.nix { inherit pkgs; })
      (import ./scripts/pkg.nix { inherit pkgs; })
    ];
  }
#+end_src

** Gui
#+NAME: xinitrc-config
#+begin_src shell
  #!/usr/bin/sh
  xrandr --output eDP-1 --mode 2560x1600
  ${pkgs.xwallpaper}/bin/xwallpaper --stretch ~/.config/home-manager/wallpaper.png 
  xrdb load ~/.cache/wal/colors.Xresources 

  if test -z "$DBUS_SESSION_BUS_ADDRESS"; then
      eval $(dbus-launch --exit-with-session --sh-syntax)
  fi

  picom &

  if command -v dbus-update-activation-environment >/dev/null 2>&1; then
      dbus-update-activation-environment DISPLAY XAUTHORITY
  fi

  # exec dbus-launch --exit-with-session emacsclient -c
  exec dbus-launch --exit-with-session emacs -mm --debug-init
#+end_src

#+begin_src nix :noweb yes :tangle gui.nix
  { pkgs, ... }:

  {
    home.file.".config/X11/xinitrc".text = '' 
      <<xinitrc-config>>
    '' ;
  }
#+end_src

** Emacs
*** Template
This came from Robert Helgeson's nur expressions. I've tweaked it a little to add a few more options for things like general & removed the ability to natively compile init.el, because it was breaking stuff

https://gitlab.com/rycee/nur-expressions

**** Setup
#+begin_src nix :noweb yes :tangle emacs/emacs-init.nix
  { config, lib, inputs, pkgs, ... }:

  with lib;

  let

    cfg = config.programs.emacs.init;

    packageFunctionType = mkOptionType {
      name = "packageFunction";
      description = "function from epkgs to package";
      check = isFunction;
      merge = mergeOneOption;
    };

    <<Emacs Template Use Package>>
    <<Emacs Template Use Package Constants>>
    <<Emacs Template Use Package Construction>>
    <<Emacs Template Early Init Construction>>
  in {
    <<Emacs Template Config Construction>>
  }
#+end_src

**** Use Package
#+NAME: Emacs Template Use Package
#+begin_src nix :noweb yes
  usePackageType = types.submodule ({ name, config, ... }: {
    <<Emacs Template Use Package Options>>

    <<Emacs Template Use Package Functions>>
  });
#+end_src

***** Options
#+NAME: Emacs Template Use Package Options
#+begin_src nix :noweb yes
    options = {
      enable = mkEnableOption "Emacs package ${name}";

      package = mkOption {
        type = types.either (types.str // { description = "name of package"; })
          packageFunctionType;
        default = name;
        description = ''
          The package to use for this module. Either the package name
          within the Emacs package set or a function taking the Emacs
          package set and returning a package.
        '';
      };

      <<Emacs Template Key Binding Options>>

      <<Emacs Template Lazy Loading Options>>
      
      <<Emacs Template Hook Options>>

      defines = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          The entries to use for <option>:defines</option>.
        '';
      };

      demand = mkOption {
        type = types.bool;
        default = false;
        description = ''
          The <option>:demand</option> setting.
        '';
      };

      diminish = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          The entries to use for <option>:diminish</option>.
        '';
      };

      functions = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          The entries to use for <option>:functions</option>.
        '';
      };

      custom = mkOption {
        type = types.attrsOf types.str;
        default = { };
        example = {
          "display-line-numbers-type" = "'relative";
        };
        description = ''
          The entries to use for <option>:custom</option>.
        '';
      };

      config = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Code to place in the <option>:config</option> section.
        '';
      };

      extraConfig = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Additional lines to place in the use-package configuration.
        '';
      };

      earlyInit = mkOption {
        type = types.lines;
        default = "";
        description = ''
          Lines to add to <option>programs.emacs.init.earlyInit</option> when
          this package is enabled.
          </para><para>
          Note, the package is not automatically loaded so you will have to
          <literal>require</literal> the necessary features yourself.
        '';
      };

      init = mkOption {
        type = types.lines;
        default = "";
        description = ''
          The entries to use for <option>:init</option>.
        '';
      };

      extraPackages = mkOption {
        type = types.listOf types.package;
        default = [ ];
        description = ''
          Extra packages to add to <option>home.packages</option>.
        '';
      };

      assembly = mkOption {
        type = types.lines;
        readOnly = true;
        internal = true;
        description = "The final use-package code.";
      };
    };
#+end_src

****** Key Binding Options
#+NAME: Emacs Template Key Binding Options
#+begin_src nix
  chords = mkOption {
    type = types.attrsOf types.str;
    default = { };
    example = {
      "jj" = "ace-jump-char-mode";
      "jk" = "ace-jump-word-mode";
    };
    description = ''
      The entries to use for <option>:chords</option>.
    '';
  };

  bind = mkOption {
    type = types.attrsOf types.str;
    default = { };
    example = {
      "M-<up>" = "drag-stuff-up";
      "M-<down>" = "drag-stuff-down";
    };
    description = ''
      The entries to use for <option>:bind</option>.
    '';
  };

  general = mkOption {
    type = types.attrsOf types.str;
    default = { };
    example = {
      "[remap describe-variable]" = "helpful-variable";
    };
    description = ''
      The entries to use for global keys in <option>:general</option>.
      The function does not quote your bindings for you, with the intention of being able to use it for remaps.
    '';
  };

  generalOne = mkOption {
    type = types.attrsOf (types.attrsOf types.str);
    default = { };
    example = {
      "'normal" = { "/" = "consult-line"; };
    };
    description = ''
      The entries to use for keymaps with 1 argument in <option>:general</option>.
    '';
  };

  generalTwo = mkOption {
    type = types.attrsOf (types.attrsOf (types.attrsOf types.str));
    default = { };
    example = {
      "'normal".vundo-mode-map."C-e" = "'vundo-next";
    };
    description = ''
      The entries to use for keymaps with 2 arguments in <option>:general</option>.
    '';
  };

  bindLocal = mkOption {
    type = types.attrsOf (types.attrsOf types.str);
    default = { };
    example = {
      helm-command-map = { "C-c h" = "helm-execute-persistent-action"; };
    };
    description = ''
      The entries to use for local keymaps in <option>:bind</option>.
    '';
  };

  bindKeyMap = mkOption {
    type = types.attrsOf types.str;
    default = { };
    example = { "C-c p" = "projectile-command-map"; };
    description = ''
      The entries to use for <option>:bind-keymap</option>.
    '';
  };
#+end_src

****** Lazy Loading Options
#+NAME: Emacs Template Lazy Loading Options
#+begin_src nix
      mode = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          The entries to use for <option>:mode</option>.
        '';
      };

      after = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          The entries to use for <option>:after</option>.
        '';
      };

      afterCall = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          The entries to use for <option>:after-call</option>.
        '';
      };

      defer = mkOption {
        type = types.either types.bool types.ints.positive;
        default = false;
        description = ''
          The <option>:defer</option> setting.
        '';
      };

      deferIncrementally = mkOption {
        type = types.either types.bool (types.listOf types.str);
        default = false;
        description = ''
          The <option>:defer-incrementally</option> setting.
        '';
      };

      command = mkOption {
        type = types.listOf types.str;
        default = [ ];
        description = ''
          The entries to use for <option>:commands</option>.
        '';
      };

#+end_src

****** Hook Options
#+NAME: Emacs Template Hook Options
#+begin_src nix
  hook = mkOption {
    type = types.listOf types.str;
    default = [ ];
    description = ''
      The entries to use for <option>:hook</option>.
    '';
  };

  ghook = mkOption {
    type = types.listOf types.str;
    default = [ ];
    description = ''
      The entries to use for <option>:ghook</option>.
    '';
  };

  gfhook = mkOption {
    type = types.listOf types.str;
    default = [ ];
    description = ''
      The entries to use for <option>:gfhook</option>.
    '';
  };
#+end_src

***** Functions
#+NAME: Emacs Template Use Package Functions
#+begin_src nix
  config = mkIf config.enable {
    assembly = let
      quoted = v: ''"${escape [ ''"'' ] v}"'';
      mkBindHelper = cmd: prefix: bs:
        optionals (bs != { }) ([ ":${cmd} (${prefix}" ]
                               ++ mapAttrsToList (n: v: "  (${quoted n} . ${v})") bs ++ [ ")" ]);
      mkGeneralHelper = mode: map: bs:
        optionals (bs != { }) ([ ":general (${mode} ${map}" ]
                               ++ mapAttrsToList (n: v: "  ${quoted n} ${v}") bs ++ [ ")" ]);
      mkGeneralLocalHelper = state: bs:
        let mkMap = n: v: mkGeneralHelper "${state}" "${n}" v;
        in flatten (mapAttrsToList mkMap bs);
      mkAfter = vs: optional (vs != [ ]) ":after (${toString vs})";
      mkAfterCall = vs: optional (vs != [ ]) ":after-call (${toString vs})";
      mkCommand = vs: optional (vs != [ ]) ":commands (${toString vs})";
      # Having :custom before every statement grants better load times. No idea why
      mkCustom = vs: optionals (vs != { }) (mapAttrsToList (n: v: ":custom (${n} ${v})") vs);
      mkDefines = vs: optional (vs != [ ]) ":defines (${toString vs})";
      mkDiminish = vs: optional (vs != [ ]) ":diminish (${toString vs})";
      mkMode = vs: optional (vs != [ ]) ":mode ${toString vs}";
      mkFunctions = vs: optional (vs != [ ]) ":functions (${toString vs})";
      mkBind = mkBindHelper "bind" "";
      mkGeneral = bs:
        optionals (bs != { }) ([ ":general ("]
                               ++ mapAttrsToList (n: v: ''  "${n}" ${v}'') bs ++ [ ")" ]);

      mkGeneralOne = bs:
        let mkMap = n: v: mkGeneralHelper "${n}" "" v;
        in flatten (mapAttrsToList mkMap bs);
      mkGeneralTwo = bs:
        let mkMap = n: v: mkGeneralLocalHelper "${n}" v;
        in flatten (mapAttrsToList mkMap bs);
      mkBindLocal = bs:
        let mkMap = n: v: mkBindHelper "bind" ":map ${n}" v;
        in flatten (mapAttrsToList mkMap bs);
      mkBindKeyMap = mkBindHelper "bind-keymap" "";
      mkChords = mkBindHelper "chords" "";
      mkHook = vs: optional (vs != [ ]) ":hook ${toString vs}";
      mkGhook = vs: optional (vs != [ ]) ":ghook ${toString vs}";
      mkGfhook = vs: optional (vs != [ ]) ":gfhook ${toString vs}";
      mkDefer = v:
        if isBool v then
          optional v ":defer t"
        else
          [ ":defer ${toString v}" ];
      mkDeferIncrementally = v:
        if isBool v then
          optional v ":defer-incrementally t"
        else
          map (n: ":defer-incrementally ${n}") v;
      mkDemand = v: optional v ":demand t";
    in concatStringsSep "\n  " ([ "(use-package ${name}" ]
                                ++ mkAfter config.after ++ mkAfterCall config.afterCall ++ mkBind config.bind
                                ++ mkBindKeyMap config.bindKeyMap ++ mkBindLocal config.bindLocal
                                ++ mkChords config.chords ++ mkCommand config.command
                                ++ mkDefer config.defer ++ mkDeferIncrementally config.deferIncrementally 
                                ++ mkDefines config.defines
                                ++ mkFunctions config.functions ++ mkDemand config.demand
                                ++ mkDiminish config.diminish ++ mkHook config.hook ++ mkGhook config.ghook
                                ++ mkGfhook config.gfhook ++ mkCustom config.custom
                                ++ mkGeneralOne config.generalOne ++ mkGeneralTwo config.generalTwo ++ mkGeneral config.general
                                ++ mkMode config.mode
                                ++ optionals (config.init != "") [ ":init" config.init ]
                                ++ optionals (config.config != "") [ ":config" config.config ]
                                ++ optional (config.extraConfig != "") config.extraConfig) + ")";
  };
#+end_src

**** Use Package Constants
#+NAME: Emacs Template Use Package Constants
#+begin_src nix
  usePackageStr = name: pkgConfStr: ''
    (use-package ${name}
      ${pkgConfStr})'';

  mkRecommendedOption = type: extraDescription:
    mkOption {
      type = types.bool;
      default = false;
      example = true;
      description = ''
        Whether to enable recommended ${type} settings.
      '' + optionalString (extraDescription != "") ''
        </para><para>
        ${extraDescription}
      '';
    };

  # Recommended GC settings.
  gcSettings = ''
    (defun hm/reduce-gc ()
      "Reduce the frequency of garbage collection."
      (setq gc-cons-threshold most-positive-fixnum
            gc-cons-percentage 0.6))

    (defun hm/restore-gc ()
      "Restore the frequency of garbage collection."
      (setq gc-cons-threshold 16777216
            gc-cons-percentage 0.1))

    ;; Make GC more rare during init, while minibuffer is active, and
    ;; when shutting down. In the latter two cases we try doing the
    ;; reduction early in the hook.
    (hm/reduce-gc)
    (add-hook 'minibuffer-setup-hook #'hm/reduce-gc -50)
    (add-hook 'kill-emacs-hook #'hm/reduce-gc -50)

    ;; But make it more regular after startup and after closing minibuffer.
    (add-hook 'emacs-startup-hook #'hm/restore-gc)
    (add-hook 'minibuffer-exit-hook #'hm/restore-gc)

    ;; Avoid unnecessary regexp matching while loading .el files.
    (defvar hm/file-name-handler-alist file-name-handler-alist)
    (setq file-name-handler-alist nil)

    (defun hm/restore-file-name-handler-alist ()
      "Restores the file-name-handler-alist variable."
      (setq file-name-handler-alist hm/file-name-handler-alist)
      (makunbound 'hm/file-name-handler-alist))
    
    (add-hook 'emacs-startup-hook #'hm/restore-file-name-handler-alist)
  '';

  # Whether the configuration makes use of `:diminish`.
  hasDiminish = any (p: p.diminish != [ ]) (attrValues cfg.usePackage);

  # Whether the configuration makes use of `:defer-incrementally`.
  hasDoom = any (p: (p.deferIncrementally != [ ] && p.deferIncrementally != false) || p.afterCall != [ ] || cfg.largeFileHandling) (attrValues cfg.usePackage);

  # Whether the configuration makes any use of general keywords.
  hasGeneral = any (p: p.ghook != [ ] || p.gfhook != [ ] || p.generalOne != { } || p.generalTwo != { } || p.general != { }) (attrValues cfg.usePackage);

  # Whether the configuration makes use of `:bind`.
  hasBind = any (p: p.bind != { } || p.bindLocal != { } || p.bindKeyMap != { })
    (attrValues cfg.usePackage);

  # Whether the configuration makes use of `:chords`.
  hasChords = any (p: p.chords != { }) (attrValues cfg.usePackage);
#+end_src

**** Use Package Construction
#+NAME: Emacs Template Use Package Construction
#+begin_src nix
  usePackageSetup = ''
    (require 'use-package)
    ;; To help fixing issues during startup.
    (setq use-package-verbose ${
      if cfg.usePackageVerbose then "t" else "nil"
    })
  '' + ''
  ;; Optimizes for large file handling
    ${if cfg.largeFileHandling then
      "(use-package doom-large-file
      :demand t)"
      else ""
     }
    '' + optionalString hasDiminish ''
  ;; For :diminish in (use-package).
    (require 'diminish)
    '' + optionalString hasDoom ''
  ;; For :defer-incrementally in (use-package).
    (use-package doom-defer
     :demand t)
    '' + optionalString hasGeneral ''
  ;; For any general keywords in (use-package).
    (use-package general
     :demand t
     :config
       (general-auto-unbind-keys))
    '' + optionalString hasBind ''
  ;; For :bind in (use-package).
    (require 'bind-key)

  ;; Fixes "Symbol’s function definition is void: use-package-autoload-keymap".
    (autoload #'use-package-autoload-keymap "use-package-bind-key")
      '' + optionalString hasChords ''
     ;; For :chords in (use-package).
       (use-package use-package-chords
        :config (key-chord-mode 1))
  '';
#+end_src

**** Early Init Construction
#+NAME: Emacs Template Early Init Construction
#+begin_src nix
    earlyInitFile = ''
      ;;; hm-early-init.el --- Emacs configuration à la Home Manager -*- lexical-binding: t; -*-
      ;;
      ;;; Commentary:
      ;;
      ;; The early init component of the Home Manager Emacs configuration.
      ;;
      ;;; Code:

      ;; Avoid expensive frame resizing. Inspired by Doom Emacs.
      (setq frame-inhibit-implied-resize t)

      ${optionalString cfg.recommendedGcSettings gcSettings}

      ${cfg.earlyInit}
      (provide 'hm-early-init)
      ;; hm-early-init.el ends here
    '';
#+end_src

**** Config Construction
#+NAME: Emacs Template Config Construction
#+begin_src nix
  options.programs.emacs.init = {
    enable = mkEnableOption "Emacs configuration";

    recommendedGcSettings = mkRecommendedOption "garbage collection" ''
      This will reduce garbage collection frequency during startup and
      while the minibuffer is active.
    '';

    # Credits: The large file handling package is from Noctuid
    largeFileHandling = mkEnableOption "Optimizes operations on large text files";

    startupTimer = mkEnableOption "Emacs startup duration timer";

    earlyInit = mkOption {
      type = types.lines;
      default = "";
      description = ''
        Configuration lines to add in <filename>early-init.el</filename>.
      '';
    };

    prelude = mkOption {
      type = types.lines;
      default = "";
      description = ''
        Configuration lines to add in the beginning of
        <filename>init.el</filename>.
      '';
    };

    postlude = mkOption {
      type = types.lines;
      default = "";
      description = ''
        Configuration lines to add in the end of
        <filename>init.el</filename>.
      '';
    };

    packageQuickstart = mkOption {
      type = types.bool;
      default = true;
      description = ''
        Whether to enable package-quickstart. This will make sure that
        <literal>package.el</literal> is activated and all autoloads are
        available.
        </para><para>
        If disabled you can save quite a few milliseconds on the startup time,
        but you will most likely have to tweak the <literal>command</literal>
        option of various packages.
        </para><para>
        As an example, running <literal>(emacs-init-time)</literal> on an Emacs
        configuration with this option enabled reported ~300ms. Disabling the
        option dropped the init time to ~200ms.
      '';
    };

    usePackageVerbose = mkEnableOption "verbose use-package mode";

    usePackage = mkOption {
      type = types.attrsOf usePackageType;
      default = { };
      example = literalExpression ''
        {
          dhall-mode = {
            mode = [ '''"\\.dhall\\'"''' ];
          };
        }
      '';
      description = ''
        Attribute set of use-package configurations.
      '';
    };
  };

  config = mkIf (config.programs.emacs.enable && cfg.enable) {
    programs.emacs.extraPackages = epkgs:
      let
        getPkg = v:
          if isFunction v then
            [ (v epkgs) ]
          else
            optional (isString v && hasAttr v epkgs) epkgs.${v};

        packages = concatMap (v: getPkg (v.package))
          (filter (getAttr "enable") (builtins.attrValues cfg.usePackage));
      in [
        epkgs.use-package
        (epkgs.trivialBuild {
          pname = "hm-early-init";
          src = pkgs.writeText "hm-early-init.el" earlyInitFile;
          version = "0.1.0";
          packageRequires = packages;
          preferLocalBuild = true;
          allowSubstitutes = false;
        })
      ] ++ optionals hasGeneral [epkgs.general]
      ++ optionals hasDoom [
        (epkgs.callPackage ./emacs-packages/doom-utils.nix {
          inherit inputs;
          inherit (epkgs) trivialBuild;
        })
      ] ++ packages;

    # Collect the extra packages that should be included in the user profile.
    # These are typically tools called by Emacs packages.
    home.packages = concatMap (v: v.extraPackages)
      (filter (getAttr "enable") (builtins.attrValues cfg.usePackage));

    home.file = {
      ".config/emacs/early-init.el".text = ''
        (require 'hm-early-init)
      '';

      ".config/emacs/init.el".text = ''
        ${if cfg.packageQuickstart then ''
          (setq package-quickstart t
                package-quickstart-file "hm-package-quickstart.el")
        '' else ''
          (setq package-enable-at-startup nil)
        ''}


      ${usePackageSetup}
      ${cfg.prelude}
      '' + concatStringsSep "\n\n" (map (getAttr "assembly")
        (filter (getAttr "enable") (attrValues cfg.usePackage))) + ''

        ${cfg.postlude}
      '';
    };
  };
#+end_src

*** Main
**** Inputs & Imports
#+begin_src nix :tangle emacs.nix :noweb yes
  { config, pkgs, inputs, ... }:

  {
    imports = [
      ./emacs/emacs-init.nix
      ./emacs/early-init.nix
      ./emacs/evil.nix
      ./emacs/file-management.nix
      ./emacs/help-system.nix
      ./emacs/completion-system.nix
      ./emacs/development.nix
      ./emacs/passwords.nix
      ./emacs/writing.nix
      ./emacs/window-manager.nix
    ];

    programs.emacs = {
      enable = true;
      package = pkgs.emacs29-gtk3;
      extraPackages = epkgs: with epkgs; [ 
        on
        (callPackage ./emacs/emacs-packages/repeaters.nix {
          inherit inputs;
          inherit (epkgs) trivialBuild;
        })
        epkgs.hydra
        epkgs.pretty-hydra
      ] ;
      init = {
        enable = true;
        packageQuickstart = false;
        recommendedGcSettings = true;
        usePackageVerbose = false;
        largeFileHandling = true;

        <<Emacs Prelude>>

        usePackage = {

          <<Emacs UI Improvements>>

          <<Emacs Cleanup>>

          <<Emacs Doom Escape>>

          <<Emacs Async>>

          <<Emacs Wgrep>>

          <<Emacs Ledger>>

          <<Emacs GPTel>>

          <<Emacs Notifications>>
          
        };

        <<Emacs Postlude>>
      };
    };
  }
#+end_src

***** Package Definitions
#+begin_src nix :tangle emacs/emacs-packages/doom-utils.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "doom-utils";
    version = "current";
    src = inputs.doom-utils;
  }

#+end_src

#+begin_src nix :tangle emacs/emacs-packages/on.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "on";
    version = "current";
    src = inputs.on-el;
  }

#+end_src

#+begin_src nix :tangle emacs/emacs-packages/repeaters.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "repeaters";
    version = "current";
    src = inputs.repeaters;
  }
#+end_src

**** Prelude
#+NAME: Emacs Prelude
#+begin_src nix :noweb yes
    prelude =''
      <<emacs-prelude>>
    '';
#+end_src

#+NAME: emacs-prelude
#+begin_src emacs-lisp
  (defalias 'gsetq #'general-setq)

  (use-package on
    :demand t)

  (general-create-definer efs/leader-keys
    :keymaps 'override
    :states '(emacs insert normal hybrid motion visual operator)
    :prefix "SPC"
    :global-prefix "C-SPC")

  (efs/leader-keys
    "f" '(find-file :which-key "find or create file")
    ;; Help
    "h" '(:ignore t :which-key "help")
    "h." '(display-local-help :which-key "display local help")
    "h4" '(info-other-window :which-key "info other window")
    "hA" '((lambda () (interactive) (async-shell-command "${(import ./scripts/wiki.nix { inherit pkgs; })}/bin/wiki")) :which-key "arch wiki")
    "hC" '(describe-coding-system :which-key "describe coding system")
    "hD" '(view-emacs-debugging :which-key "emacs debugging")
    "hE" '(view-external-packages :which-key "external packages")
    "hF" '(Info-goto-emacs-command-node :which-key "info: command node")
    "hb" '(embark-bindings :which-key "display all keybinds")
    "hI" '(describe-input-method :which-key "describe input method")
    "hK" '(Info-goto-emacs-key-command :which-key "info: key command")
    "hL" '(describe-language-environment :which-key "describe language environment")
    "hM" '(woman :which-key "man")
    "hP" '(describe-package :which-key "describe package")
    "hR" '(info-display-manual :which-key "info: manual")
    "hS" '(info-lookup-symbol :which-key "info: symbol")
    "hT" '(view-emacs-todo :which-key "things you can do to help emacs")
    "ha" '(about-emacs :which-key "about emacs")
    "hc" '(describe-key-briefly :which-key "short describe key")
    "hd" '(apropos-documentation :which-key "apropos documentation")
    "he" '(view-echo-area-messages :which-key "view echoed messages")
    ;; "hf" '(describe-function :which-key "describe function")
    "hh" '(help-for-help :which-key "help for help")
    "hi" '(info :which-key "info pages")
    ;; "hk" '(describe-key :which-key "describe key")
    "hl" '(view-lossage :which-key "lossage")
    "hm" '(describe-mode :which-key "describe mode")
    "hn" '(view-emacs-news :which-key "emacs news")
    ;; "ho" '(describe-symbol :which-key "describe symbol")
    "hp" '(finder-by-keyword :which-key "finder by keyword")
    "hq" '(help-quit :which-key "help quit")
    "hr" '(info-emacs-manual :which-key "info: emacs")
    "hs" '(describe-syntax :which-key "describe syntax")
    "ht" '(help-with-tutorial :which-key "emacs tutor")
    ;; "hv" '(describe-variable :which-key "describe variable")
    "hw" '(where-is :which-key "find binds of command")
    ;; "hx" '(describe-command :which-key "describe command")
    "h C-f" '(view-emacs-FAQ :which-key "emacs FAQ")
    "h C-p" '(view-emacs-problems :which-key "view emacs problems")
    "h C-s" '(search-forward-help-for-help :which-key "search in help for help")
    ;;Mouse
    "l" '(compile :which-key "compile")
    ;; Mount/unmount drive
    "u" '((lambda () (interactive) (start-process-shell-command "udisksmenu" nil "${(import ./scripts/udisksmenu.nix { inherit pkgs; })}/bin/udisksmenu")) :which-key "mount/unmount drive"))

  (general-unbind "C-h")

  (general-create-definer local-leader
    :prefix "M-SPC"
    :states '(emacs insert normal hybrid motion visual operator))

  (use-package hydra
    :defer t)

  (use-package pretty-hydra
    :custom
    (hydra-hint-display-type 'posframe)
    :config
    (gsetq hydra-posframe-show-params '(:internal-border-width 1
  							     :internal-border-color "003f28"
  							     :parent-frame nil
  							     :poshandler posframe-poshandler-frame-bottom-center
  							     :refposhandler posframe-refposhandler-xwininfo))
    :gfhook ('doom-escape-hook 'hydra-keyboard-quit))

  (use-package repeaters
    :demand t
    :config
    (repeaters-define-maps
     '(("next-error" ;; borrowed from the hydra wiki
        next-error "`"
        next-error "n"
        previous-error "e"))))

  (use-package repeat
    :config
    (repeat-mode))

  (general-def "H-z" 'repeat)
#+end_src

**** Sensible Defaults
***** UI Improvements
Most of this was shamelessly lifted from Emacs from Scratch.
Display buffer rules were taken from noctuid's config.
https://emacs.stackexchange.com/questions/75528/how-to-define-display-buffer-alist-to-keep-every-buffer-in-the-frame-it-is-curr
#+NAME: Emacs UI Improvements
#+begin_src nix :noweb yes
  tooltip = {
    enable = true;
    config = ''
      (tooltip-mode -1)
      (set-fringe-mode -1)
    '';
  };

  simple = {
    enable = true;
    config = ''
      (gsetq save-interprogram-paste-before-kill t)
      (column-number-mode)
    '';
  };

  display-line-numbers = {
    enable = true;
    custom = {
      display-line-numbers-type = "'relative";
      display-line-numbers-width = "3";
    }; 
    config = "(global-display-line-numbers-mode)";
    #Disable line numbers for some modes
    ghook = ["('(org-mode-hook term-mode-hook dired-mode-hook eww-mode-hook eat-mode-hook markdown-mode-hook help-mode-hook helpful-mode-hook Info-mode-hook woman-mode-hook shell-mode-hook pdf-view-mode-hook elfeed-search-mode-hook elfeed-show-mode-hook eshell-mode-hook racket-repl-mode-hook sage-shell-mode-hook) (lambda () (display-line-numbers-mode 0)))"];
  } ;

  elec-pair = {
    enable = true;
    ghook = ["('on-first-buffer-hook 'electric-pair-mode)"];
    custom.electric-pair-pairs = ''
     '((?\" . ?\")
       (?\[ . ?\])
       (?\( . ?\))
       (?\{ . ?\}))
    '';
    config = ''
      <<Emacs Electric Pair Config>>
    '';
  };

  server = {
    enable = true;
    deferIncrementally = true;
    config = "(server-start)";
  };
#+end_src

#+NAME: Emacs Electric Pair Config
#+begin_src emacs-lisp
  ;; < & > are not delimiters. Change my mind.
  ;; Courtesy of DT. https://gitlab.com/dwt1/configuring-emacs/-/tree/main/07-the-final-touches?ref_type=heads
  (gsetq electric-pair-inhibit-predicate `(lambda (c)
  					   (if (or (char-equal c ?<) (char-equal c ?>))
  					       t
  					       (,electric-pair-inhibit-predicate c))))
#+end_src

***** Cleanup
Emacs has a propensity for leaving garbage lying around. This configuration that I stole from David Wilson should make that stop.

#+NAME: Emacs Cleanup
#+begin_src nix
  no-littering = {
    enable = true;
    demand = true;
    #no-littering doesn't set this by default so we must place
    #auto save files in the same path as it uses for sessions
    custom.auto-save-file-name-transforms = ''`((".*" ,(no-littering-expand-var-file-name "auto-save/") t))'';
  };
#+end_src

**** Doom Escape
Credits: Doom Escape is from doom. (Wow)
#+NAME: Emacs Doom Escape
#+begin_src nix :noweb yes
  doom-escape = {
    enable = true;
    package = epkgs: (epkgs.callPackage ./emacs/emacs-packages/doom-utils.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild;
    });
    gfhook = ["('doom-escape-hook (list (lambda () (setq efs/vertico-active nil)) 'transient-quit-one))"];
    general."C-g" = "'doom/escape";
    config = ''
      <<Doom Escape Config>>
    '';
  };
#+end_src

#+NAME: Doom Escape Config
#+begin_src emacs-lisp
  (with-eval-after-load 'eldoc
    (eldoc-add-command 'doom/escape))
#+end_src

**** Async
Async lets emacs create other instances of itself to run functions. It still has to be passed back to the main instance, but it does help with the single-threadedness.
#+NAME: Emacs Async
#+begin_src nix :noweb yes
  async = {
    enable = true;
    config = ''
      <<Emacs Async Config>>
    '';
  };
#+end_src

#+NAME: Emacs Async Config
#+begin_src emacs-lisp
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode)
#+end_src

**** Wgrep
Wgrep basically turns grep into sed.

=Bindings=
+ C-c C-e: Apply changes
+ C-c C-u: Changes are unmarked & ignored
+ C-c C-d: Mark current line for deletion
+ C-c C-r: Remove changes in region
+ C-c C-p: Toggle read-only
+ C-c C-k: Exit without changes
+ C-x C-q: Exit wgrep
#+NAME: Emacs Wgrep
#+begin_src nix
  wgrep = {
    enable = true;
    custom.wgrep-auto-save-buffer = "t";
    generalTwo."'normal".grep-mode-map."w" = "'wgrep-change-to-wgrep-mode";
  };
#+end_src

**** Ledger
#+NAME: Emacs Ledger
#+begin_src nix
  ledger = {
    enable = true;
    package = epkgs: epkgs.ledger-mode;
    mode = [''"\\.ledger\\'"''];
  };
#+end_src

**** GPT.el
#+NAME: Emacs GPTel
#+begin_src nix :noweb yes
  gptel = {
    enable = true;
    defer = true;
    command = ["start-ollama"];
    generalOne."efs/leader-keys" = {
      "g" = '''(:ignore t :which-key "gptel")'';
      "gs" = '''(start-ollama :which-key "start")'';
      "gp" = '''(gptel :which-key "prompt")'';
    };
    generalTwo."local-leader".gptel-mode-map = {
      "d" = '''(gptel-send :which-key "send")'';
      "m" = '''(gptel-menu :which-key "menu")'';
    };
    config = ''
      <<Emacs Gpt4all Config>>
    '';
  };

  gptel-quick = {
    enable = true;
    defer = true;
    package = epkgs: (pkgs.callPackage ./emacs/emacs-packages/gptel-quick.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild gptel;
    });
    generalOne = {
      embark-general-map."?" = '''(gptel-quick :which-key "summarize")''; 
      "efs/leader-keys"."gq" = '''(gptel-quick :which-key "summarize")'';
    };
  };
#+end_src

#+NAME: Emacs Gpt4all Config
#+begin_src emacs-lisp
  (gsetq gptel-backend (gptel-make-ollama "Ollama"
  		       :stream t
  		       :protocol "http"
  		       :host "localhost:11434"
  		       :models '(llama3.2:latest))
         gptel-max-tokens 10000000
         gptel-prompt-prefix-alist '((default . "You are a large language model and a helpful assistant. Respond concisely.")
  				   (programming . "You are a large language model and a careful programmer. Provide code and only code as output without any additional text, prompt or note.")
  				   (writing . "You are a large language model and a writing assistant. Respond concisely.")
  				   (chat . "You are a large language model and a conversation partner. Respond concisely.")))

  (defun start-ollama ()
    (interactive)
    (start-process-shell-command "start-ollama" nil "${(import ./scripts/start-ollama.nix { inherit pkgs config; })}/bin/start-ollama"))
#+end_src

***** Package Definitions
#+begin_src nix :tangle emacs/emacs-packages/gptel-quick.nix
  { inputs, trivialBuild, gptel } :

  trivialBuild rec {
    pname = "gptel-quick";
    version = "current";
    src = inputs.gptel-quick;

    propagatedUserEnvPkgs = [
      gptel
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

**** Notifications
Stolen from EDNC's github page.

EDNC does the same thing as dunst. It will pop up any new notifications inside of a text buffer.
#+NAME: Emacs Notifications
#+begin_src nix :noweb yes
  ednc = {
    enable = true;
    gfhook = [
      "('ednc-notification-presentation-functions #'show-notification-in-echo-area)"
    ];
    deferIncrementally = true;
    config = ''
      <<Emacs EDNC Config>>
    '';
  };
#+end_src

#+NAME: Emacs EDNC Config
#+begin_src emacs-lisp
  (ednc-mode)
  (defun show-notification-in-echo-area (old new)
    (when new (message (ednc-format-notification new t))))
#+end_src

**** Postlude
#+NAME: Emacs Postlude
#+begin_src nix :noweb yes
  postlude = ''
    <<Emacs Postlude Config>>
  '';
#+end_src

#+NAME: Emacs Postlude Config
#+begin_src emacs-lisp
  ;; Stolen from Derek Taylor's config.
  (add-to-list 'default-frame-alist '(alpha-background . 90))
  ;; Display buffer rules
  (cl-pushnew (list (rx "*Async Shell Command*" (0+ any)) #'display-buffer-no-window) display-buffer-alist)
  (cl-pushnew (list (rx "*Shell Command Output*" (0+ any)) #'display-buffer-no-window) display-buffer-alist)
#+end_src

*** Early Init
All of the repeaters config was origally stolen from Karthinks. I don't think any of the code I stole is actually here anymore, though.
#+begin_src nix :noweb yes :tangle emacs/early-init.nix
  { ... }:

  {
    programs.emacs.init = {
      earlyInit = ''
        <<Emacs Early Init>>
      '';
    };
  }
#+end_src

#+NAME: Emacs Early Init
#+begin_src emacs-lisp
  (scroll-bar-mode -1) ; Disable visible scrollbar
  (tool-bar-mode -1) ; Disable the toolbar
  (menu-bar-mode -1)

  (setq auto-save-visited-file-name t
        warning-minimum-level :error
        use-package-enable-imenu-support t
        make-backup-files nil
        enable-recursive-minibuffers t
        inhibit-startup-message t
        inhibit-startup-screen t
        visible-bell t
        use-short-answers t
        ;; Scratch is an org mode buffer
        initial-major-mode 'org-mode
        initial-scratch-message ""
        ;;Reduce garbage
        user-emacs-directory "~/.cache/emacs")

  (defun efs/display-startup-time ()
    (message "Emacs loaded in %s with %d garbage collections."
             (format "%.2f seconds"
                     (float-time
                      (time-subtract after-init-time before-init-time)))
             gcs-done))

  (add-hook 'emacs-startup-hook #'efs/display-startup-time)
#+end_src

*** Evil Mode
My keybinds have been rearranged to work with Colemak. Evil is used for the purposes of ergonomics, & all my bindings revolve around it.

Evil mode provides vim-like keybinds.
#+begin_src nix :noweb yes :tangle emacs/evil.nix
  { inputs, ... }:

  {
    programs.emacs.init.usePackage = {
      <<Emacs Evil Main>>
      
      <<Emacs Evil Extensions>>
      
      # <<Emacs Evil Symex>>
      
      <<Emacs Evil God State>>
      
      <<Emacs Evil Compats>>

      <<Emacs Evil Undo>>
    };
  }
#+end_src

**** TODO Main Config
+ [ ] ergovim keys
  https://emacs.stackexchange.com/questions/59223/how-to-assign-a-command-to-g-key-when-using-evil
https://www.hxa.name/articles/content/ergovim-key-mappings_hxa7241_2010.html
+ [X] Dashboard
+ [X] Easymotions
+ [X] What do we do about consult-yank-pop?
+ [ ] Symex
  Very messy
It should be noted that C-g quits out of insert mode. That, like most of this config, was taken from David Wilson's dotfiles.

Differences from the spec:
+ numbers & symbols aren't rebound

We used general to bind commonly used functions to the spacebar. It is partially based on the bindings in doom emacs.
M-SPC is our local leader, & it's used for keys specific to a given major mode
#+NAME: Emacs Evil Main
#+begin_src nix :noweb yes
  evil = {
    enable = true;
    demand = true;
    gfhook = ["('doom-escape-hook 'evil-normal-state)"];
    general."M-u" = "'universal-argument";
    generalOne.universal-argument-map = {
      "M-u" = "'universal-argument-more";
      "C-u" = "'nil";
    };
    custom = {
      # Various settings to make it more like vim
      evil-want-integration = "t";
      evil-want-keybinding = "nil";
      evil-want-minibuffer = "t";
      evil-want-C-u-scroll = "t";
      evil-want-C-w-delete = "t";
      evil-want-C-u-delete = "t";
      evil-want-C-h-delete = "t";
      evil-want-C-i-jump = "t";
      evil-move-cursor-back = "nil";
      evil-move-beyond-eol = "t"; # Combined with move-cursor-back, it prevents the cursor from moving behind a "/" when selecting a directory in the minibuffer
      evil-cross-lines = "t";
      sentence-end-double-space = "nil";
    };
    generalOne."'insert" = {
       "C-s" = "'insert-char";
       "C-k" = "'kill-line";
    };
    config = ''
      <<emacs-evil-config>>
    '';
  };
#+end_src

#+NAME: emacs-evil-config
#+begin_src emacs-lisp
  ;; Initiate evil mode
  (evil-mode)
  (evil-ex-define-cmd "q" '(lambda () (interactive) (prescient--save) (save-buffers-kill-emacs)))
  (evil-ex-define-cmd "Undotree" 'vundo)
  (evil-ex-define-cmd "k[ill]" 'kill-current-buffer)
  (gsetq evil-want-Y-yank-to-eol t)
  (evil-set-undo-system 'undo-redo)

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal)
  (general-advice-add '(evil-scroll-down evil-scroll-up evil-scroll-page-up evil-scroll-page-down) :after #'(lambda (arg) (evil-window-middle)))

  (evil-add-command-properties #'flymake-goto-next-error :jump t)
  (evil-add-command-properties #'flymake-goto-prev-error :jump t)
  (evil-add-command-properties #'evil-scroll-up :jump t)
  (evil-add-command-properties #'evil-scroll-down :jump t)
  (evil-add-command-properties #'consult-grep :jump t)

  (evil-define-operator ergo-word-delete (beg end type register yank-handler)
    "Delete word."
    :motion evil-a-word
    (evil-delete beg end type register yank-handler))

  (evil-define-operator ergo-word-change (beg end type register yank-handler)
    "Delete word."
    :motion evil-inner-word
    (evil-change beg end type register yank-handler))

  (general-def 'normal
    "i" 'evil-forward-char
    "I" 'evil-window-top
    "C-i" 'evil-goto-line
    "n" 'evil-backward-char
    "N" 'evil-window-bottom
    "C-n" 'evil-goto-first-line
    "E" 'evil-scroll-down
    "o" 'evil-previous-visual-line
    "O" 'evil-scroll-up
    "x" 'evil-backward-WORD-begin
    "X" 'evil-backward-word-begin
    "C-x" 'evil-backward-WORD-end
    "j" 'evil-undo
    "J" 'evil-redo
    "a" 'evil-ex
    "r" 'evil-insert-line
    "R" 'evil-open-above
    "s" 'evil-append-line
    "S" 'evil-open-below
    "t" 'evil-insert
    "T" 'evil-append
    "C-t" 'evil-replace-state
    "u" 'evil-forward-WORD-begin
    "U" 'evil-forward-word-begin
    "C-u" 'evil-forward-WORD-end
    "-" 'evil-jump-backward
    "_" 'evil-jump-forward
    "m" 'evil-search-next
    "M" 'evil-search-previous
    "k" 'evil-delete-char
    "K" 'evil-substitute
    "l" 'evil-invert-char
    "L" 'evil-invert-case
    "c" 'evil-visual-state
    "C" 'evil-visual-line
    "C-c" 'evil-visual-block
    "v" 'evil-delete
    "V" 'evil-change
    "C-v" 'evil-delete-line
    "d" 'evil-yank
    "D" 'evil-yank-line
    "G" 'evil-paste-after
    ";" 'evil-end-of-visual-line
    ":" 'evil-end-of-line
    "C-;" 'evil-end-of-line
    "p" 'ergo-word-delete
    "P" 'ergo-word-change
    "C-p" 'ergo-word-change
    "$" 'evil-execute-macro
    "~" 'evil-record-macro
    "C-z" 'evil-goto-last-change-reverse
    "w" 'evil-repeat
    "W" 'evil-ex-repeat
    "C-w" 'evil-ex-repeat
    "l" 'evil-shift-right-line
    "L" 'evil-shift-left-line
    "C-l" 'evil-shift-left-line
    "y" 'evil-shift-right
    "Y" 'evil-shift-left
    "<escape>" 'doom/escape)
    

  (general-def 'motion
    "i" 'evil-forward-char
    "I" 'evil-window-top
    "C-i" 'evil-goto-line
    "n" 'evil-backward-char
    "N" 'evil-window-bottom
    "C-n" 'evil-goto-first-line
    "e" 'evil-next-visual-line
    "C-e" 'evil-scroll-page-down
    "o" 'evil-previous-visual-line
    "C-o" 'evil-scroll-page-up
    "a" 'evil-ex
    "h" 'evil-set-marker
    "m" 'evil-search-next
    "M" 'evil-search-previous
    "-" 'evil-jump-backward
    "_" 'evil-jump-forward
    "/" 'isearch-forward-regexp
    "?" 'isearch-backward-regexp
    "f" 'evil-first-non-blank-of-visual-line
    "F" 'evil-beginning-of-visual-line
    "C-f" 'evil-first-non-blank
    "B" 'evil-goto-line)

  (general-swap-key nil '(motion normal visual)
    "g" "b"
    "z" "q"
    "Z" "Q")

  (general-def
    :keymaps 'override
    :states '(normal visual)
    "g" 'evil-paste-before
    "z" 'evil-jump-item
    "Z" 'evil-goto-last-change)

  (general-def
    :keymaps 'override
    :states '(operator visual)
    "i" 'evil-forward-char
    "s" evil-inner-text-objects-map
    "t" evil-outer-text-objects-map)

  (general-def 'visual
    "o" 'evil-previous-visual-line
    "e" 'evil-next-visual-line
    ;; "n" 'evil-backward-char
    ;; "i" 'evil-forward-char
    "U" 'evil-forward-word-begin
    "u" 'evil-forward-WORD-begin
    "X" 'evil-backward-word-begin
    "x" 'evil-backward-WORD-begin
    "v" 'evil-delete-char
    "V" 'evil-substitute
    "C-v" 'evil-substitute
    "t" evil-outer-text-objects-map
    "s" evil-inner-text-objects-map
    "l" 'evil-invert-case
    "y" 'evil-shift-right
    "Y" 'evil-shift-left
    "C-t" 'evil-replace
    "R" 'evil-insert-line
    "C-r" 'evil-append-line
    "d" 'evil-yank-line
    "D" 'evil-yank-line
    "C-d" 'evil-yank-line
    "G" 'evil-paste)

  (general-def 'normal "bl" '(consult-goto-line :which-key "go to line")
    "b/" '(consult-keep-lines :which-key "delete non-matching lines"))

#+end_src

**** Extensions
Evil-snipe is used to make jumping more efficient.
Easymotion's prefix is M-SPC, however, most important keys are already bound somewhere easier.
Repeat map idea: https://hungyi.net/posts/hydra-for-evil-mc/
#+NAME: Emacs Evil Extensions
#+begin_src nix :noweb yes
  evil-collection = {
    enable = true;
    custom.evil-collection-unimpaired-want-repeat-mode-integration = "t";
    config = ''
      <<Emacs Evil Collection Config>>
    '';
  };

  evil-surround = {
    enable = true;
    deferIncrementally = true;
    config = ''
      <<Emacs Evil Surround Config>>
    '';
  };

  evil-easymotion = {
    enable = true;
    generalOne = {
      "'operator" = {
       "/" = "'evil-avy-goto-char-2"; 
       "?" = "'evil-avy-goto-char-2"; 
      };
      "(normal visual operator)" = {
        "H-m" = "'evilem-motion-search-next";
        "H-U" = "'evilem-motion-forward-word-begin";
        "H-u" = "'evilem-motion-forward-WORD-begin";
        "H-X" = "'evilem-motion-backward-word-begin";
        "H-x" = "'evilem-motion-backward-WORD-begin";
        "H-M" = "'evilem-motion-search-previous";
        "H-e" = "'evilem-motion-next-visual-line";
        "H-o" = "'evilem-motion-previous-visual-line";
      };
    };
    custom = {
      avy-dispatch-alist = ''
        '((?m . avy-action-cursor)
  			  (?l . avy-action-ispell)
  			  (?o . avy-action-embark)
  			  (?h . avy-action-helpful)
  			  (?g . avy-action-yank)
  			  (?p . avy-action-teleport)
  			  (?q . avy-action-fold))
      '';
      avy-keys = "'(?c ?r ?s ?t ?b ?f ?n ?e ?i ?a)";
    };
    config = ''
      <<Emacs Evil Easymotion Config>>
    '';
  };

  evil-nerd-commenter = {
    enable = true;
    defer = true;
    generalOne."efs/leader-keys" = {
      "c" = '''(:ignore t :which-key "comment")'';
      "ci" = '''(evilnc-comment-or-uncomment-lines :which-key "comment line")'';
      "cl" = '''(evilnc-quick-comment-or-uncomment-paragraphs :which-key "comment paragraph")'';
      "cc" = '''(evilnc-copy-and-comment-lines :which-key "copy & comment lines")'';
      "cp" = '''(evilnc-comment-or-uncomment-paragraphs :which-key comment paragraph)'';
      "cr" = '''(comment-or-uncomment-region :which-key "comment region")'';
      "cv" = '''(evilnc-toggle-invert-comment-line-by-line :which-key "invert comments")'';
      "cy" = '''(evilnc-copy-and-comment-operator :which-key "copy & comment operator")'';
      "co" = '''(evilnc-comment-operator :which-key "copy operator")'';
    };
  };

  evil-mc = {
    enable = true;
    defer = true;
    command = ["evil-mc-pause-cursors" "evil-mc-make-cursor-here"];
    generalOne = {
      "'(normal visual)"."bz" = "'evil-mc-hydra/body";
      "efs/leader-keys"."C" = "'evil-mc-hydra/body";
    };
    config = ''
      <<Emacs Evil-MC Config>>
    '';
    extraConfig = ''
      :pretty-hydra
      ((:color pink :pre (evil-mc-pause-cursors))
       ("Search"
        (("m" #'evil-mc-make-and-goto-next-match "Search forward")
         ("M" #'evil-mc-make-and-goto-prev-match "Search backward")
         ("C-m" #'evil-mc-skip-and-goto-next-match "Skip forward")
         ("C-M" #'evil-mc-skip-and-goto-prev-match "Skip backward"))
        "Undo"
        (("q" #'evil-mc-undo-all-cursors)
         ("j" #'evil-mc-undo-last-added-cursor))
        "Pause/Resume"
        (("r" #'evil-mc-resume-cursors "Resume")
         ("p" #'evil-mc-pause-cursors "Pause")
         ("<return>" #'evil-mc-resume-cursors "Quit" :color blue))
        "Create Cursors"
        (("h" #'evil-mc-make-all-cursors "All")
         ("s" #'evil-mc-make-cursor-here "Here")
         ("E" #'evil-mc-make-cursor-move-next-line "Next Line")
         ("O" #'evil-mc-make-cursor-move-prev-line "Prev Line"))))
    '';
  };
#+end_src

#+NAME: Emacs Evil Collection Config
#+begin_src emacs-lisp
  (defun my-hjkl-rotation (_mode mode-keymaps &rest _rest)
    (evil-collection-translate-key 'normal mode-keymaps
      "e" "j"
      "o" "k"
      "i" "l"
      "n" "h"
      "x" "B"
      "X" "b"
      "u" "W"
      "U" "w"
      "j" "u"
      "a" ":"
      "m" "n"
      "M" "N"
      "h" "m"
      "b" "g"))
  (general-add-hook 'evil-collection-setup-hook #'my-hjkl-rotation)
  (evil-collection-init)
#+end_src

#+NAME: Emacs Evil Surround Config
#+begin_src emacs-lisp
  (general-def 'visual evil-surround-mode-map "R" 'evil-surround-region)
  (general-def 'operator evil-surround-mode-map
    "s" nil
    "r" 'evil-surround-edit
    "R" 'evil-Surround-edit)
  (global-evil-surround-mode)
#+end_src

#+NAME: Emacs Evil Easymotion Config
#+begin_src emacs-lisp
  ;; Stolen from karthink
  (defun avy-action-cursor (pt)
    (save-excursion
      (goto-char pt)
      (evil-mc-make-cursor-here))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-helpful (pt)
    (save-excursion
      (goto-char pt)
      (helpful-at-point))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-fold (pt)
    (save-excursion
      (goto-char pt)
      (evil-toggle-fold))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
#+end_src

#+NAME: Emacs Evil-MC Config
#+begin_src emacs-lisp
  (global-evil-mc-mode)

  (general-add-hook 'doom-escape-hook (lambda () (when (evil-mc-has-cursors-p)
  						 (evil-mc-undo-all-cursors)
  						 (evil-mc-resume-cursors) t)))

  ;; Don't mess with my macros.
  ;; https://github.com/gabesoft/evil-mc/issues/83
  (gsetq evil-mc-cursor-variables
         (mapcar
  	(lambda (s)
  	  (remove 'register-alist
  		  (remove 'evil-markers-alist
  			  (remove evil-was-yanked-without-register s))))
  	evil-mc-cursor-variables))
#+end_src

**** Symex
Gives us an entire state where we can rapidly make specific edits to code.
#+NAME: Emacs Evil Symex
#+begin_src nix :noweb yes
  symex = {
    enable = true;
    defer = true;
    package = epkgs: (epkgs.callPackage ./emacs-packages/symex2.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild tsc tree-sitter evil evil-surround seq paredit;
    });
    generalTwo."'normal"."(org-mode-map toml-ts-mode-map evil-markdown-mode-map racket-repl-mode-map racket-mode-map python-ts-mode-map java-ts-mode-map ess-r-mode-map groovy-mode-map c-ts-mode-map js-ts-mode-map json-ts-mode-map bibtex-mode-map nxml-mode-map css-ts-mode-map nix-mode-map makefile-mode-map sql-mode-map lisp-interaction-mode-map lisp-mode-map emacs-lisp-mode-map)"."RET" = "'symex-mode-interface";
    init = ''
      <<Emacs Symex Init>>    
    '';
    config = ''
      <<Emacs Symex Config>>    
    '';
  } ;
#+end_src

#+NAME: Emacs Symex Init
#+begin_src emacs-lisp
  (with-eval-after-load 'evil-easymotion
    (evilem-make-motion-plain evilem-symex-forward 'symex-traverse-forward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-backward 'symex-traverse-backward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-next-visual-line 'symex-next-visual-line :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-previous-visual-line 'symex-previous-visual-line :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-go-forward 'symex-go-forward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-go-backward 'symex-go-backward :post-hook 'symex-select-nearest-in-line))
  (gsetq symex--evil-keyspec
         '(("n" . symex-go-backward)
           ("e" . symex-go-down)
           ("o" . symex-go-up)
           ("i" . symex-go-forward)
           ("be" . symex-next-visual-line)
           ("bE" . evilem-symex-next-visual-line)
           ("bO" . evilem-symex-previous-visual-line)
           ("bo" . symex-previous-visual-line)
           ("(" . symex-create-round)
           ("[" . symex-create-square)
           (")" . symex-wrap-round)
           ("]" . symex-wrap-square)
           ("C-'" . symex-cycle-quote)
           ("C-," . symex-cycle-unquote)
           ("`" . symex-add-quoting-level)
           ("C-`" . symex-remove-quoting-level)
           ("u" . symex-traverse-forward)
           ("x" . symex-traverse-backward)
           ("C-u" . evilem-symex-forward)
           ("C-x" . evilem-symex-backward)
           ("U" . symex-traverse-forward-skip)
           ("X" . symex-traverse-backward-skip)
           ("{" . symex-leap-backward)
           ("}" . symex-leap-forward)
           ("M-{" . symex-soar-backward)
           ("M-}" . symex-soar-forward)
           ("C-o" . symex-climb-branch)
           ("C-e" . symex-descend-branch)
           ("C-n" . evilem-symex-go-backward)
           ("C-i" . evilem-symex-go-forward)
           ("d" . symex-yank)
           ("D" . symex-yank-remaining)
           ("G" . symex-paste-after)
           ("g" . symex-paste-before)
           ("k" . symex-delete)
           ("v" . symex-delete-backwards)
           ("V" . symex-delete-remaining)
           ("K" . symex-change)
           ("C-v" . symex-change-remaining)
           ("C--" . symex-clear)
           ("s" . symex-replace)
           ;; ("S" . symex-change-delimiter)
           ("N" . symex-shift-backward)
           ("I" . symex-shift-forward)
           ("M-N" . symex-shift-backward-most)
           ("M-I" . symex-shift-forward-most)
           ("O" . paredit-raise-sexp)	; revisit kb
           ("C-S-e" . symex-emit-backward)
           ("C-(" . symex-capture-backward)
           ("C-S-n" . symex-capture-backward)
           ("C-{" . symex-emit-backward)
           ("C-S-i" . symex-capture-forward)
           ("C-}" . symex-emit-forward)
           ("C-S-o" . symex-emit-forward)
           ("C-)" . symex-capture-forward)
           ("z" . symex-swallow)
           ("Z" . symex-swallow-tail)
           ("p" . symex-evaluate)
           ("B" . symex-evaluate-remaining)
           ("C-M-j" . symex-evaluate-pretty)
           ("d" . symex-evaluate-definition)
           ("M-j" . symex-eval-recursive)
           ;; ("T". symex-evaluate-thunk)
           ;; ("t" . symex-switch-to-scratch-buffer)
           ("H" . symex-switch-to-messages-buffer)
           ("l" . symex-repl)
           ("L" . symex-run)
           ("|" . symex-split)
           ("&" . symex-join)
           ("-" . symex-splice)
           ("S" . symex-open-line-after)
           ("R" . symex-open-line-before)
           (">" . symex-insert-newline)
           ("<" . symex-join-lines-backwards)
           ("C->" . symex-append-newline)
           ("C-<" . symex-join-lines)
           ("C-S" . symex-append-newline)
           ("E" . symex-join-lines)
           ("M-E" . symex-collapse)
           ("M-<" . symex-collapse)
           ("M->" . symex-unfurl)
           ("C-M-<" . symex-collapse-remaining)
           ("C-M->" . symex-unfurl-remaining)
           ("0" . symex-goto-first)
           ("M-n" . symex-goto-first)
           ("$" . symex-goto-last)
           ("M-i" . symex-goto-last)
           ("M-e" . symex-goto-lowest)
           ("M-o" . symex-goto-highest)
           ("=" . symex-tidy)
           ("<tab>" . symex-tidy)
           ("C-=" . symex-tidy-remaining)
           ("C-<tab>" . symex-tidy-remaining)
           ("M-=" . symex-tidy-proper)
           ("M-<tab>" . symex-tidy-proper)
           ("s" . symex-append-after)
           ("T" . symex-insert-at-end)
           ("t" . symex-insert-at-beginning)
           ("r" . symex-insert-before)
           ("w" . symex-wrap)
           ("W" . symex-wrap-and-append)
           ("C-d" . symex--evil-scroll-down)
           (";" . symex-comment)
           ("M-;" . symex-comment-remaining)
           ("C-;" . symex-eval-print)	; weird pre-offset (in both)
           ("s-;" . symex-evaluate)
           ("H-h" . symex--toggle-highlight) ; treats visual as distinct mode
           ("C-?" . symex-describe)
           ("<return>" . symex-enter-lower)
           ("<escape>" . symex-escape-higher)))
#+end_src

#+NAME: Emacs Symex Config
#+begin_src emacs-lisp
  (gsetq symex-modal-backend 'evil)
  (symex-initialize)
  (repeaters-define-maps
   '(("symex-visual-line"
      symex-next-visual-line "e"
      symex-previous-visual-line "o")))

#+end_src

***** Package Definitions
#+begin_src nix :tangle emacs/emacs-packages/symex2.nix
  { inputs, trivialBuild, tsc, tree-sitter, paredit, evil, evil-surround, seq } :

  trivialBuild rec {
    pname = "symex2";
    version = "current";
    src = inputs.symex2;

    propagatedUserEnvPkgs = [
      tsc
      tree-sitter
      paredit
      evil
      evil-surround
      seq
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

**** God State
God state lets you use emacs bindings faster, & without hanging on modifier keys.
By default, any key pressed while in god state is treated as if it was pressed with control.

=bindings:=
+ SPC- removes control
+ g- switches from control to meta
+ G- switches from just control to control & meta
+ ,- enter god state
+ ESC- exit god state
#+NAME: Emacs Evil God State
#+begin_src nix
  evil-god-state = {
    enable = true;
    defer = true;
    command = ["evil-god-state"];
    gfhook = ["('doom-escape-hook 'evil-god-state-bail)"];
    generalOne = {
      "'normal"."," = "'evil-execute-in-god-state";
      "'emacs"."<escape>" = "'evil-god-state";
      evil-god-state-map = {
        "<escape>" = "'evil-god-state-bail";
        "<return>" = "'evil-emacs-state";
      };
    };
  };
#+end_src

**** Compats
#+NAME: Emacs Evil Compats
#+begin_src nix :noweb yes
  evil-org = {
    enable = true;
    defer = true;
    ghook = ["('org-mode-hook 'evil-org-mode)"];
    custom.evil-org-movement-bindings = ''
      '((up . "o")
        (down . "e")
        (left . "n")
        (right . "i"))
    '';
    generalTwo."'normal".org-mode-map = {
      "]h" = '''(org-forward-heading-same-level :which-key "next heading")'';
      "[h" = '''(org-backward-heading-same-level :which-key "prev heading")'';
      "]c" = '''(org-babel-next-src-block :which-key "next src block")'';
      "[c" = '''(org-babel-previous-src-block :which-key "prev src block")'';
      "]l" = '''(org-next-link :which-key "next link")'';
      "[l" = '''(org-previous-link :which-key "prev link")'';
    };
    config = ''
      <<Emacs Evil Org Config>>
    '';
  };

  evil-org-agenda = {
    enable = true;
    config = ''(evil-org-agenda-set-keys)'';
    generalTwo."'motion".evil-org-agenda-mode-map = {
      "e" = "'org-agenda-next-line";
      "o" = "'org-agenda-previous-line";
      "bn" = "'org-agenda-next-item";
      "be" = "'org-agenda-previous-item";
      "bI" = "'evil-window-bottom";
      "C-e" = "'org-agenda-next-item";
      "C-o" = "'org-agenda-previous-item";
      "E" = "'org-agenda-priority-down";
      "O" = "'org-agenda-priority-up";
      "I" = "'org-agenda-do-date-later";
      "M-e" = "'org-agenda-drag-line-forward";
      "M-o" = "'org-agenda-drag-line-backward";
      "C-S-i" = "'org-agenda-todo-nextset"; # Original binding "C-S-<right>"
      "l" = "'org-agenda-diary-entry";
    };
    generalOne."efs/leader-keys"."oa" = '''(org-agenda :which-key "agenda")'';
  };

  evil-markdown = {
    enable = true;
    defer = true;
    ghook = ["('markdown-mode-hook 'evil-markdown-mode)"];
    custom.evil-markdown-movement-bindings = ''
      '((up . "o")
        (down . "e")
        (left . "n")
        (right . "i"))
    '';
  };

  ewal-evil-cursors = {
    enable = true;
    demand = true;
    config = ''(ewal-evil-cursors-get-colors :apply t)'';
  };
#+end_src

#+NAME: Emacs Evil Org Config
#+begin_src emacs-lisp
  (evil-define-key 'operator 'evil-org-mode
    "i" 'evil-forward-char)
  (evil-define-key 'normal 'evil-org-mode
    "o" 'evil-previous-visual-line
    "O" 'evil-scroll-up
    "R" 'evil-org-open-above
    "S" 'evil-org-open-below
    "x" 'evil-backward-WORD-begin
    "d" 'evil-yank
    "M-e" 'evilem-motion-next-visual-line
    "M-o" 'evilem-motion-previous-visual-line)
  (evil-define-key 'visual 'evil-org-mode
    "i" 'evil-forward-char
    "s" evil-inner-text-objects-map)
  (evil-collection-unimpaired-defvar-keymap org-forward-heading-same-level-repeat-map
    "h" #'org-forward-heading-same-level
    "H" #'org-backward-heading-same-level)
  (evil-collection-unimpaired-defvar-keymap org-backward-heading-same-level-repeat-map
    "h" #'org-backward-heading-same-level
    "H" #'org-forward-heading-same-level)
  (evil-collection-unimpaired-defvar-keymap org-babel-next-src-block-repeat-map
    "c" #'org-babel-next-src-block
    "C" #'org-babel-previous-src-block)
  (evil-collection-unimpaired-defvar-keymap org-babel-previous-src-block-repeat-map
    "c" #'org-babel-previous-src-block
    "C" #'org-babel-next-src-block)
  (evil-collection-unimpaired-defvar-keymap org-next-link-repeat-map
    "l" #'org-next-link
    "L" #'org-previous-link)
  (evil-collection-unimpaired-defvar-keymap org-previous-link-repeat-map
    "l" #'org-previous-link
    "L" #'org-next-link)
  (dolist (cmd '(org-forward-heading-same-level
                 org-backward-heading-same-level
                 org-babel-next-src-block
                 org-babel-previous-src-block
                 org-next-link
                 org-previous-link))
    (put cmd 'repeat-map (intern (format "%s-repeat-map" cmd))))
#+end_src

**** Undo
Undo-Fu lets us have linear undos. It's our undo system in evil
#+NAME: Emacs Evil Undo
#+begin_src nix
  undo-fu = {
    enable = true;
    custom.undo-fu-session-compression = "'zst";
    afterCall = ["on-first-buffer-hook"];
    config = ''(gsetq evil-undo-system 'undo-fu)'';
  };
#+end_src

*** Completion System
My completions system is based around vertico, because that's what all the cool kids use nowadays.
#+begin_src nix :noweb yes :tangle emacs/completion-system.nix
  { inputs, pkgs, ... }:

  {
    home.packages = with pkgs; [
      fd
      ripgrep
    ];

    <<Emacs Templates File>>

    programs.emacs.init.usePackage = {
      <<Emacs Vertico>>
      
      <<Emacs Corfu>>

      <<Emacs Prescient>>

      <<Emacs Orderless>>

      <<Emacs Marginalia>>

      <<Emacs Consult Main Package>>

      <<Emacs Consult Extensions>>

      <<Emacs Embark>>

      <<Emacs App Launcher>>

      <<Emacs Search>>

      <<Emacs Snippets>>

      <<Emacs Ezf>>
    };
  }
#+end_src

**** Vertico
Vertico is basically dmenu for emacs. It lists out all the options in a command menu.
#+NAME: Emacs Vertico
#+begin_src nix :noweb yes
  vertico = {
    enable = true;
    defer = true;
    ghook = ["('on-first-input-hook 'vertico-mode)"];
    # Enable cycling for 'vertico-next & 'vertico-previous'.
    custom.vertico-cycle = "t";
    # This is for exwm's minibuffer issue
    generalTwo."'normal".vertico-map = {
      "RET" = "'vertico-exit";
      "C-o" = "'vertico-scroll-down";
      "C-e" = "'vertico-scroll-up";
      "e" = "'vertico-next";
      "o" = "'vertico-previous";
      "I" = "'vertico-last";
      "N" = "'vertico-first";
      "B" = "'vertico-last";
      "bg" = "'vertico-first";
    };
  };

  vertico-quick = {
    enable = true;
    defer = true;
    generalTwo."'normal".vertico-map = {
      "H-o" = "'vertico-quick-jump";
      "H-e" = "'vertico-quick-jump";
    };
  };
#+end_src

**** Corfu
I took a lot of this from Gavin Freeborn's config
#+NAME: Emacs Corfu
#+begin_src nix :noweb yes
  corfu = {
    enable = true;
    ghook = [
      "('minibuffer-setup-hook 'corfu-enable-in-minibuffer)"
      "('on-first-buffer-hook 'global-corfu-mode)"
    ];
    custom = {
      corfu-cycle = "t";
      corfu-autodelay = "0";
      corfu-auto-prefix = "2";
      corfu-auto = "t";
      corfu-on-exact-match = "'show";
    };
    general."M-/" = "'completion-at-point";
    generalOne.corfu-map = {
      "RET" = "nil";
      "TAB" = "nil";
      "S-<return>" = "'corfu-insert";
      "[tab]" = "nil";
    };
    generalTwo."'(insert emacs)".corfu-map = {
      "S-SPC" = "'corfu-insert-separator";
      "C-e" = "'corfu-next";
      "C-p" = "nil";
      "C-o" = "'corfu-previous";
    };
    config = ''
      <<Emacs Corfu Config>>
    '';
  };

  nerd-icons-corfu = {
    enable = true;
    config = ''(add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)'';
    after = ["corfu"];
  };

  corfu-quick = {
    enable = true;
    generalTwo."'(insert emacs)".corfu-map = {
      "M-o" = "'corfu-quick-insert";
      "M-e" = "'corfu-quick-insert";
    };
  };

  corfu-popupinfo = {
    enable = true;
    ghook = ["('corfu-mode-hook 'corfu-popupinfo-mode)"];
  };

  cape = {
    enable = true;
    after = ["corfu"];
    config = ''
      <<Emacs Cape Config>>
    '';
  };
#+end_src

#+NAME: Emacs Corfu Config
#+begin_src emacs-lisp
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer."
    (when (local-variable-p 'completion-at-point-functions)
      (setq-local corfu-auto t) ;; Enable/disable auto completion
      (corfu-mode 1)))
#+end_src

#+NAME: Emacs Cape Config
#+begin_src emacs-lisp
  (dolist (src (list 'cape-dabbrev 'cape-file))
          (add-to-list 'completion-at-point-functions src))
#+end_src

**** Prescient
Prescient is a big-braned history package that orders completion options by recency & frequency.
#+NAME: Emacs Prescient
#+begin_src nix
  prescient = {
    enable = true;
    defer = true;
    config = ''(prescient-persist-mode)'';
    custom.prescient-history-length = "100";
    afterCall = ["on-first-input-hook"];
  };

  vertico-prescient = {
    enable = true;
    defer = true;
    ghook = ["('minibuffer-mode-hook 'vertico-prescient-mode)"];
    custom = {
      vertico-prescient-enable-filtering = "nil";
      vertico-prescient-completion-styles = "'(orderless prescient basic)";
      vertico-prescient-enable-sorting = "t";
    };
  };

  corfu-prescient = {
    enable = true;
    defer = true;
    ghook = ["('corfu-mode-hook 'corfu-prescient-mode)"];
    custom.corfu-prescient-completion-styles = "'(basic prescient)";
  };
#+end_src

**** Orderless
Orderless basically turns the completion system into a fuzzy finder. It's here to help me sift through my notes.
This config is stolen directly from David Wilson
#+NAME: Emacs Orderless
#+begin_src nix
  orderless = {
    enable = true;
    defer = true;
    custom = {
      completion-styles = "'(orderless prescient basic)";
      completion-category-defaults = "nil";
      completion-category-overrides = "'((file (styles . (partial-completion))))";
    };
    afterCall = ["on-first-input-hook"];
  };
#+end_src

**** Marginalia
Marginalia provides extra information on the options in a vertico completion, that way you know what you're getting ahead of time.
#+NAME: Emacs Marginalia
#+begin_src nix
  marginalia = {
    enable = true;
    defer = true;
    config = ''(marginalia-mode)'';
    afterCall = ["on-first-input-hook"];
  };
#+end_src

**** Consult
***** Main Package
Replaces a bunch of commands with new commands.
Evil integration is from noctuid & minad
#+NAME: Emacs Consult Main Package
#+begin_src nix :noweb yes
  consult = {
    enable = true;
    defer = true;
    ghook = ["('minibuffer-setup-hook 'consult-initial-narrow)"];
    command = ["consult-goto-line" "consult-keep-lines" "noct-consult-ripgrep-or-line"];
    general = {
      "C-x C-f" = "'consult-find";
      "C-x b" = "'nil";
      "M-y" = "'nil";
      # C-c bindings (mode-specific-map)
      "C-c m" = "'consult-mode-command";
      "C-c k" = "'consult-kmacro";
      # C-x bindings (ctl-x-map)
      "C-x M-:" = "'consult-complex-command"; # orig. repeat-complex-command
      "C-x 5 b" = "'consult-buffer-other-frame"; # orig. switch-to-buffer-other-frame
      # Custom M-# bindings for fast register access
      "M-#" = "'consult-register-load";
      "M-'" = "'consult-register-store";       # orig. abbrev-prefix-mark (unrelated)
      "C-M-#" = "'consult-register";
      # M-g bindings (goto-map)
      "M-g e" = "'consult-compile-error";
      "M-g f" = "'consult-flymake"; # Alternative: consult-flycheck
      "M-g m" = "'consult-mark";
      "M-g k" = "'consult-global-mark";
      "M-g i" = "'consult-imenu-multi";
      # M-s bindings (search-map)
      "M-s D" = "'consult-locate";
      "M-s G" = "'consult-git-grep";
      "M-s g" = "'consult-ripgrep";
      "M-s m" = "'consult-multi-occur";
      "M-s u" = "'consult-focus-lines";
      # Isearch integration
      "M-s e" = "'consult-isearch-history"; # orig. isearch-edit-string
      "M-s L" = "'consult-line-multi"; # needed by consult-line to detect isearch
    };
    custom = {
      consult-buffer-sources = "'(consult--source-buffer)";
      xref-show-xrefs-function = "#'consult-xref";
    };
    generalOne = {
      "'normal" = {
        "?" = "'consult-line-multi";
        "H-m" = "'evil-collection-consult-mark";
        "M-g" = "'consult-yank-pop"; # orig. evil-paste-pop
        "M-E" = "'consult-isearch-history "; # orig. isearch-edit-string
      };  
      "efs/leader-keys" = {
         "b" = '''(consult-bookmark :which-key "bookmarks")'';
         "j" = '''(evil-collection-consult-jump-list :which-key "jump")'';
         "i" = '''consult-imenu'';
         "h C-a" = '''(consult-apropos :which-key "apropos")'';
      };
    };
    config = ''
      <<Emacs Consult Config>>
    '';
  } ;
#+end_src

#+NAME: Emacs Consult Config
#+begin_src emacs-lisp
  (defun efs/save-search-history (pattern)
  	"Gets history from pattern, & saves it where evil mode can find it"
  	(add-to-history 'evil-search-forward-history pattern)
  	(add-to-history 'search-ring pattern)
  	(add-to-history 'regexp-search-ring pattern)
  	(setq evil-ex-search-pattern (list pattern t t))
  	(setq evil-ex-search-direction 'forward)
  	(when evil-ex-search-persistent-highlight
            (evil-ex-search-activate-highlight evil-ex-search-pattern)))

  (defun noct-consult-line-evil-history (&rest _)
    "Add latest `consult-line' search pattern to the evil search history ring.
  This only works with orderless and for the first component of the search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'isearch))
      (efs/save-search-history (cadr (orderless-compile
  				    (car consult--line-history))))))

  (general-add-advice #'consult-line :after #'noct-consult-line-evil-history)

  (defvar consult--bufler-workspace+
    `(:name "Workspace"
            :narrow ?w
            :category buffer
            :face consult-buffer
            :history  buffer-name-history
            :state    ,#'consult--buffer-state
            :enabled  ,(lambda () (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find)))
            :items
            ,(lambda ()
               (let ((bufler-vc-state nil))
                 (mapcar #'buffer-name
                         (mapcar #'cdr
                                 (bufler-buffer-alist-at
                                  (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find))
                                  :filter-fns bufler-filter-buffer-fns))))))
    "Bufler workspace buffers source for `consult-buffer'.")

  (push #'consult--bufler-workspace+ consult-buffer-sources)

  ;; Stolen from the wiki
  (defun consult-initial-narrow ()
    (when (and (eq this-command #'consult-buffer)
               (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find)))
      (setq unread-command-events (append unread-command-events (list ?w 32)))))

  (defcustom noct-consult-ripgrep-or-line-limit 1000000
    "Buffer size threshold for `noct-consult-ripgrep-or-line'.
  When the number of characters in a buffer exceeds this threshold,
  `consult-ripgrep' will be used instead of `consult-line'."
    :type 'integer)

  (defun noct-consult-ripgrep-or-line (&optional initial)
    "Call `consult-line' for small buffers or `consult-ripgrep' for large files."
    (interactive)
    (if (or (not buffer-file-name)
            (buffer-narrowed-p)
            (ignore-errors
              (file-remote-p buffer-file-name))
            (jka-compr-get-compression-info buffer-file-name)
            (<= (buffer-size)
                (/ noct-consult-ripgrep-or-line-limit
                   (if (eq major-mode 'org-mode) 4 1))))
        (consult-line initial)
      ((lambda ()
         (when (file-writable-p buffer-file-name)
  	 (save-buffer))
         (let ((consult-project-function (lambda (x) nil)))
  	 (consult-ripgrep (list (shell-quote-argument buffer-file-name)) (concat " " initial))
  	 (efs/save-search-history (string-trim-left (car consult--grep-history) "# ")))))))
#+end_src

***** Extensions
#+NAME: Emacs Consult Extensions
#+begin_src nix
  consult-dir = {
    enable = true;
    defer = true;
    generalOne.vertico-map = {
      "C-x d" = "'consult-dir";
      "C-x j" = "'consult-dir-jump-file";
    };
  };
#+end_src

**** Embark
Embark lets you manipulate the content of vertico buffers.

Credits:
Which-key indicator from the embark wiki
Ace-window & avy actions from karthink
#+NAME: Emacs Embark
#+begin_src nix :noweb yes
  embark = {
    enable = true;
    package = epkgs: (epkgs.callPackage ./emacs-packages/better-embark.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild org compat consult avy;
    });
    defer = true;
    command = ["embark-act"];
    general."M-a" = "'embark-dwim";
    custom = {
      # Replace key help with a completing-read interface
      prefix-help-command = "#'embark-prefix-help-command";
      embark-indicators = ''
        '(embark-which-key-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator)
      '';
    };
    generalTwo."'normal" = {
      embark-collect-mode-map."q" = "'evil-record-macro";
      minibuffer-local-map."a" = "'embark-act";
    };
    generalOne = {
      embark-file-map = {
        "o" = "(my/embark-ace-action find-file)";
        "2" = "(my/embark-split-action find-file split-window-below)";
        "3" = "(my/embark-split-action find-file split-window-right)";
      };
      embark-buffer-map = {
        "o" = "(my/embark-ace-action switch-to-buffer)";
        "2" = "(my/embark-split-action switch-to-buffer split-window-below)";
        "3" = "(my/embark-split-action switch-to-buffer split-window-right)";
      };
      embark-bookmark-map = {
        "o" = "(my/embark-ace-action bookmark-jump)";
        "2" = "(my/embark-split-action bookmark-jump split-window-below)";
        "3" = "(my/embark-split-action bookmark-jump split-window-right) ";
      };
    };
    config = ''
      <<Emacs Embark Config>>
    '';
    init = ''
      <<Emacs Embark Init>>
    '';
  } ;

  embark-consult = {
    enable = true;
    after = ["embark" "consult"];
    ghook = ["('embark-collect-mode-hook 'consult-preview-at-point-mode)"];
  };
#+end_src

#+NAME: Emacs Embark Config
#+begin_src emacs-lisp
  (cl-defun embark--beginning-of-target (&key bounds &allow-other-keys)
    "Go to beginning of the target BOUNDS."
    (goto-char (car bounds)))

  (cl-defun embark--end-of-target (&key bounds &allow-other-keys)
    "Go to end of the target BOUNDS."
    (goto-char (cdr bounds)))
#+end_src

#+NAME: Emacs Embark Init
#+begin_src emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
      The which-key help message will show the type and value of the
      current target followed by an ellipsis if there are further
      targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)

  (eval-when-compile
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn)))))))

  (eval-when-compile
    (defmacro my/embark-split-action (fn split-type)
      `(defun ,(intern (concat "my/embark-"
                               (symbol-name fn)
                               "-"
                               (car (last  (split-string
                                            (symbol-name split-type) "-"))))) ()
         (interactive)
         (funcall #',split-type)
         (call-interactively #',fn))))

  ;; Hide the modeline of embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
#+end_src

***** Package Definition
#+begin_src nix :tangle emacs/emacs-packages/better-embark.nix
  { inputs, trivialBuild, org, compat, consult, avy } :

  trivialBuild rec {
    pname = "better-embark";
    version = "current";
    src = inputs.emacs-embark;

    propagatedUserEnvPkgs = [
      org
      compat
      consult
      avy
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

**** App Launcher
#+NAME: Emacs App Launcher
#+begin_src nix
  app-launcher = {
    enable = true;
    defer = true;
    package = epkgs: (epkgs.callPackage ./emacs-packages/app-launcher.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild;
    });
    command = ["app-launcher-run-app"];
  };
#+end_src

***** Package Definition
#+begin_src nix :tangle emacs/emacs-packages/app-launcher.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "app-launcher";
    version = "current";
    src = inputs.app-launcher;
  }

#+end_src

**** Search
#+NAME: Emacs Search
#+begin_src nix :noweb yes
  ace-isearch = {
    enable = true;
    demand = true;
    gfhook = ["('pdf-view-mode-hook (lambda () (ace-isearch-mode -1)))"];
    generalOne.isearch-mode-map."C-a" = "'avy-isearch";
    config = ''
      <<Emacs Search Config>>
    '';
    custom = {
      ace-isearch-on-evil-mode = "t";
      ace-isearch-input-length = "5";
      ace-isearch-jump-based-on-one-char = "nil";
      ace-isearch-function-from-isearch = "'ace-isearch-consult-ripgrep-or-line-from-isearch";
    };
  };
#+end_src

#+NAME: Emacs Search Config
#+begin_src emacs-lisp
  (global-ace-isearch-mode)
  (defun ace-isearch-consult-ripgrep-or-line-from-isearch ()
    "Invoke `noct-consult-ripgrep-or-line' from ace-isearch."
    (interactive)
    (let (($query (if isearch-regexp
  		    isearch-string
  		  (regexp-quote isearch-string))))
      (isearch-update-ring isearch-string isearch-regexp)
      (let (search-nonincremental-instead)
        (ignore-errors (isearch-done t t)))
      (noct-consult-ripgrep-or-line $query)))
#+end_src

**** Snippets
#+NAME: Emacs Snippets
#+begin_src nix :noweb yes
  tempel = {
    enable = true;
    command = ["tempel-complete"];
    custom.tempel-path = ''"~/.config/emacs/templates.eld"'';
    init = ''
      <<Emacs Templ Init>>
    '';
  };

  tempel-collection = {
    enable = true;
    after = ["tempel"];
  };
#+end_src

#+NAME: Emacs Templ Init
#+begin_src emacs-lisp
  (defun tempel-setup-capf ()
    " Add the Tempel Capf to `completion-at-point-functions'.
    `tempel-expand' only triggers on exact matches. Alternatively use
    `tempel-complete' if you want to see all matches, but then you
    should also configure `tempel-trigger-prefix', such that Tempel
    does not trigger too often when you don't expect it. NOTE: We add
    `tempel-expand' *before* the main programming mode Capf, such
    that it will be tried first."
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))
#+end_src

#+NAME: Emacs Templates File
#+begin_src nix
  home.file.".config/emacs/templates.eld".text = ''
    nix-mode
    (upackage p "= {" n "  enable = true;" q "  }")

    js-ts-mode
    (clg "console.log(" p ");")
    (doc "/**" n> " * " q n " */")
    (anfn "(" p ") => {" n> q n "};")
    (qs "document.querySelector(\"" q "\");")
    (if "if (" p ") {" n> q n "}")

    c-ts-mode
    (doc "/**" n> " * " q n " */")
    (if "if (" p ") {" n> q n "}")
    (for "for (int i = " p "; i < " p "; i++) {" n> q n "}")
    (while "while (" p ") {" n> q n "}")
    (stdio "#include <stdio.h>")
    (stdlib "#include <stdlib.h>")
    (string "#include <string.h>")
    (unistd "#include <unistd.h>")
    (mpi "#include <mpi.h>")
    (math "#include <math.h>")
    (define "#define " p)
    (function p " " p " (" p ") {" n> q n "}" ) 
    (main "int main (int argc, char **argv) {" n> q n "}" ) 

    org-mode
    (au "#+author: " q)
    (ti "#+title: " q)
    (ci "* Works Cited" n "#+cite_export: csl ~/.config/csl/ieee.csl" n "#+print_bibliography:" q)
    (pdf "#+auto-export-pandoc: to-latex-pdf")
    (odt "#+auto-export-pandoc: to-odt")

    java-ts-mode
    (doc "/**" n> " * " q n " */")
    (if "if (" p ") {" n> q n "}")
    (class "class " p " {" n> q n "}")
    (method p " " p " " p "(" p ") {" n> q n "}")
    (while "while (" p ") {" n> q n "}")
    (for "for (int i = " p "; i < " p "; i++) {" n> q n "}")

    bash-ts-mode
    (bang "#!/bin/sh" n q)
    (safebang "#!/bin/sh" n "set -euo pipefail" n q)

    ledger-mode
    (payroll p "Rose-Hulman Payroll" n> "Income:TeachingAssistant" > "-" p n> "*Assets:Checking")
    (checking "Assets:Checking")

    racket-mode
    (let "(let [(" p ")]" n q ")")
    (letrec "(letrec [(" p ")]" n q ")")
    (letstar "(let* [(" p ")]" n q ")")
    (namelet "(let " p " [(" p ")]" n q ")")
    (defun "(define " p " (lambda (" p ")" n q "))")
  '';
#+end_src

**** Ezf
An alternative to fzf.
#+NAME: Emacs Ezf
#+begin_src nix
  ezf = {
    enable = true;
    package = epkgs: (epkgs.callPackage ./emacs-packages/ezf.nix {
        inherit inputs;
        inherit (epkgs) trivialBuild;
    });
    deferIncrementally = true;
  };
#+end_src

***** Package Definitions
#+begin_src nix :tangle emacs/emacs-packages/ezf.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "ezf";
    version = "current";
    src = inputs.ezf;
  }
#+end_src

*** Help System
An improved help system that I lifted from emacs from scratch.
Helpful gives more information, & which-key tells what keybinds you have available
#+begin_src nix :tangle emacs/help-system.nix
  { ... }:

  {
    programs.emacs.init.usePackage = {
      which-key = {
        enable = true;
        defer = true;
        config = ''(which-key-enable-god-mode-support)'';
        ghook = ["('on-first-input-hook 'which-key-mode)"];
        custom = {
          which-key-idle-delay = "1";
          # which-key-popup-type = "'minibuffer";
        };
      };

      helpful = {
        enable = true;
        defer = true;
        generalOne."efs/leader-keys" = {
          "hf" = "'helpful-function";
          "hs" = "'helpful-symbol";
          "hv" = "'helpful-variable";
          "hx" = "'helpful-command";
          "hk" = "'helpful-key";
        };
      };
    };
  }
#+end_src

*** File Management
We use the default dirvish config. It's like ranger.el, but without the bugs.
#+begin_src nix :noweb yes :tangle emacs/file-management.nix
  { inputs, ... }:

  {
    programs.emacs.init.usePackage = {
      dired = {
        enable = true;
        gfhook = ["('dired-mode-hook 'dired-omit-mode)"];
        general = {
          "C-x C-j" = "'dired-jump";
          "C-x d" = "'consult-dir";
        };
        custom = {
          dired-recursive-deletes = "'always";
          dired-listing-switches = ''"-agho --group-directories-first"'';
          # We're doing our best to get rid of that 1st extraneous line
          dired-free-space = "nil";
        };
        generalOne."efs/leader-keys"."d" = '''(dired :which-key "dired")'';
      };

      openwith = {
        enable = true;
        defer = true;
        ghook = ["('dired-mode-hook 'openwith-mode)"];
        config = ''
      <<Emacs Openwith Config>>
    '';
      };

      dired-hide-dotfiles = {
        enable = true;
        defer = true;
        ghook = ["('dired-mode-hook 'dired-hide-dotfiles-mode)"];
        config = ''(general-def 'normal dired-mode-map "H" 'dired-hide-dotfiles-mode)'';
      };

      dirvish = {
        enable = true;
        general."H-f" = "'dirvish-fd";
        custom = {
          dirvish-use-mode-line = "nil";
          dirvish-attributes = "'(nerd-icons file-size subtree-state)";
          dirvish-yank-overwrite-existing-files = "'always";
          dirvish-side-window-parameters = "nil";
          dirvish-quick--entries = ''
         '(("h" "~/" "Home"
            "r" "~/game/rejuvenation/"))
      '';
        };
        afterCall = ["on-first-buffer-hook"];
        generalTwo = {
          local-leader.dirvish-mode-map."s" = "'dirvish-setup-menu";
          "'normal".dirvish-mode-map = {
            "d" = "'dired-do-async-delete";
            "/" = "'consult-line";
            "c" = "'dirvish-quick-access";
            "w" = "'wdired-change-to-wdired-mode";
            "q" = "'evil-record-macro";
            "m" = "'evil-search-next";
            "I" = "'dirvish-file-info-menu";
            "y" = "'dirvish-yank-menu";
            "N" = "'dirvish-narrow";
            "B" = "'evil-goto-line";
            "^" = "'dirvish-history-last";
            "u" = "'dirvish-history-jump";
            "j" = "'dired-unmark";
            "s" = "'dirvish-quicksort ;remapped 'dired-sort-toggle-or-edit'";
            "v" = "'dirvish-vc-menu ;remapped 'dired-view-file'";
            "TAB" = "'dirvish-subtree-toggle";
            "M-f" = "'dirvish-history-go-forward";
            "M-b" = "'dirvish-history-go-backward";
            "M-l" = "'dirvish-ls-switches-menu";
            "M-m" = "'dirvish-mark-menu";
            "M-E" = "'dirvish-emerge-menu";
            "M-j" = "'dirvish-fd-jump";
          };
        };
        generalOne."efs/leader-keys"."t" = '''(dirvish-side :which-key "side-bar")'';
        config = ''
      <<Emacs Dirvish Config>>
    '';
      };

      dired-single = {
        enable = true;
        package = epkgs: (epkgs.callPackage ./emacs-packages/dired-single.nix {
          inherit inputs;
          inherit (epkgs) trivialBuild;
        });
        generalTwo = {
          "'normal".dirvish-mode-map = {
            "i" = "'dired-single-prev";
            "n" = "'dired-single-next";
          };
        };
      };

      diredfl = {
        enable = true;
        ghook = ["('dired-mode-hook 'diredfl-mode)"];
      };

      dired-posframe = {
        enable = true;
        generalTwo."'normal".dirvish-mode-map."M-t" = "'dired-posframe-mode";
      };
      
      image = {
        enable = true;
        generalTwo."'normal".image-map = {
          "E" = "'image-next-file";
          "O" = "'image-previous-file";
        };
        custom.image-animate-loop = "t";
      };
    };
  }
#+end_src

#+NAME: Emacs Openwith Config
#+begin_src emacs-lisp
  (gsetq openwith-associations
       (list
        (list (openwith-make-extension-regexp
               '("ff"))
              "lel"
              '(file))
        (list (openwith-make-extension-regexp
               '("odt" "doc" "docx" "odp" "pptx" "xlsx"))
              "libreoffice"
              '(file))
        (list (openwith-make-extension-regexp
               '("mpg" "mpeg" "mp3" "mp4"
                 "avi" "wmv" "wav" "mov" "flv"
                 "ogm" "ogg" "mkv" "webm" "opus"
                 "flac"))
              "mpv"
              '(file))))

  (defun dired-do-async-delete (&optional arg)
    "Delete all marked (or next ARG) files.
  `dired-recursive-deletes' controls whether deletion of
  non-empty directories is allowed."
    ;; This is more consistent with the file marking feature than
    ;; dired-do-flagged-delete.
    (interactive "P")
    (let (markers)
      (dired-internal-do-deletions
       (nreverse
        ;; this may move point if ARG is an integer
        (dired-map-over-marks (cons (dired-get-filename)
                                    (let ((m (point-marker)))
                                      (push m markers)
                                      m))
                              arg))
       arg t)
      (async-start (lambda ()
  		   (dolist (m markers) (set-marker m nil)))
  		 'ignore)))
#+end_src

#+NAME: Emacs Dirvish Config
#+begin_src emacs-lisp
  (dirvish-override-dired-mode)
  (dirvish-peek-mode)
  (require 'dirvish-yank)
#+end_src

**** Package Definition
#+begin_src nix :tangle emacs/emacs-packages/dired-single.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "dired-single";
    version = "current";
    src = inputs.dired-single;
  }
#+end_src

*** Development
This was more directly stolen than the other parts
I think most of it was from the github page for lsp mode, but it's been a while, & I don't remember much.
#+begin_src nix :noweb yes :tangle emacs/development.nix
  { inputs, pkgs, pkgs-stable, ... }:

  {
    home.packages = with pkgs; [
      pkgs-stable.python311Packages.python-lsp-server
      ccls
      vscode-langservers-extracted
      typescript-language-server
      lemminx
      marksman
      nodePackages.bash-language-server
      nixd
      sqls
    ];

    programs.emacs.init.usePackage = {
        <<Emacs Development Misc>>
        
        <<Emacs Development Direnv>>

        <<Emacs Development Treesitter Setup>>

        <<Emacs Development Treesitter Context>>
        
        <<Emacs Development Project>>

        <<Emacs Development DevDocs>>

        <<Emacs Development Plantuml>>

        <<Emacs Development Eglot>>
        
        # <<Emacs Development Dape>>
        
        <<Emacs Development Python>>

        <<Emacs Development Java>>
        
        <<Emacs Development Nix>>

        # <<Emacs Development Webdev>>

        # <<Emacs Development Racket>>

        # <<Emacs Development R>>

        <<Emacs Development Zenscript>>
    };
  }
#+end_src

**** Misc
#+NAME: Emacs Development Misc
#+begin_src nix
  nxml = {
    enable = true;
    generalTwo.local-leader.nxml-mode-map = {
      "a" = '''(eglot-code-actions :which-key "code actions")'';
      "n" = '''(flymake-goto-next-error :which-key "next error")'';
      "e" = '''(flymake-goto-prev-error :which-key "previous error")'';
      "f" = '''(eglot-format :which-key "format")'';
    };
    deferIncrementally = true;
  };

  editorconfig = {
    enable = true;
    afterCall = ["on-first-file-hook"];
    config = ''(editorconfig-mode)'';
  };

  rainbow-delimiters = {
    enable = true;
    ghook = ["('prog-mode-hook 'rainbow-delimiters-mode)"];
  };
#+end_src

**** Treesitter
https://github.com/jdtsmith/indent-bars

***** Setup
#+NAME: Emacs Development Treesitter Setup
#+begin_src nix :noweb yes
  treesit-auto = {
    enable = true;
    custom.treesit-auto-install = "'prompt";
    deferIncrementally = ["treesitter"];
    config = ''
      <<Emacs Treesit Auto Config>>
    '';
    extraConfig = ''
      :preface (defun mp-setup-install-grammars ()
                 "Install Tree-sitter grammars if they are absent."
                 (interactive)
                 (dolist (grammar
                          '(;(xml "https://github.com/ObserverOfTime/tree-sitter-xml")
                            (toml "https://github.com/ikatyang/tree-sitter-toml")
                            (elisp "https://github.com/Wilfred/tree-sitter-elisp")))
                   (add-to-list 'treesit-language-source-alist grammar)
                   ;; Only install `grammar' if we don't already have it
                   ;; installed. However, if you want to *update* a grammar then
                   ;; this obviously prevents that from happening.
                   (unless (treesit-language-available-p (car grammar))
                     (treesit-install-language-grammar (car grammar)))))
    '';
  };

  # tree-sitter = {
  #   enable = true;
  #   afterCall = ["on-first-file-hook"];
  #   config = ''
  #     <<Emacs Treesitter Config>>
  #   '';
  # };

  # tree-sitter-langs = {
  #   enable = true;
  #   custom.tree-sitter-langs-grammar-dir = ''"~/.cache/emacs/tree-sitter"'';
  #   afterCall = ["global-tree-sitter-mode-hook"];
  # };
#+end_src

#+NAME: Emacs Treesit Auto Config
#+begin_src emacs-lisp
  (mp-setup-install-grammars)
  (global-treesit-auto-mode)
#+end_src

#+NAME: Emacs Treesitter Config
#+begin_src emacs-lisp
  (global-tree-sitter-mode)
  (dolist (mode (list '(java-ts-mode . java)
  		    '(html-ts-mode . html)
  		    '(python-ts-mode . python)
  		    '(js-ts-mode . javascript)
  		    '(json-ts-mode . json)
  		    '(gfm-mode . markdown)
  		    '(css-ts-mode . css)
  		    '(c-ts-mode . c)
  		    '(racket-repl-mode . racket)
  		    '(ess-r-mode . r)
  		    '(inferior-ess-r-mode . r)
  		    '(toml-ts-mode . toml)))
    (add-to-list 'tree-sitter-major-mode-language-alist mode))
#+end_src

***** Context
#+NAME: Emacs Development Treesitter Context
#+begin_src nix
  treesitter-context = {
    enable = true;
    package = epkgs: (epkgs.callPackage ./emacs-packages/treesitter-context.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild posframe;
    });
    ghook = ["('(js-ts-mode-hook java-ts-mode-hook c-ts-mode-hook python-mode-hook json-ts-mode-hook) 'treesitter-context-mode)"];
    custom.treesitter-context-frame-min-width = "30";
  };

  treesitter-context-fold = {
    enable = true;
    ghook = ["('treesitter-context-mode-hook 'treesitter-context-fold-mode)"];
    generalTwo."'normal".treesitter-context-fold-mode-map = {
      "zm" = "'treesitter-context-fold-hide";
      "zo" = "'treesitter-context-fold-show";
      "za" = "'treesitter-context-fold-toggle";
    };
  };

  treesitter-context-focus = {
    enable = true;
    command = ["treesitter-context-focus-mode"];
  };
#+end_src

****** Package Definitions
#+begin_src nix :tangle emacs/emacs-packages/treesitter-context.nix
  { inputs, trivialBuild, posframe } :

  trivialBuild rec {
    pname = "treesitter-context";
    version = "current";
    src = inputs.treesitter-context;

    propagatedUserEnvPkgs = [
      posframe
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

**** Project
#+NAME: Emacs Development Project
#+begin_src nix :noweb yes
  magit = {
    enable = true;
    custom.magit-display-buffer-function = "#'magit-display-buffer-same-window-except-diff-v1";
    config = ''
      <<Emacs Magit Config>>
    '';
    generalOne.project-prefix-map = {
      "v" = "'magit-status";
      "c" = "'magit-commit";
      "p" = "'magit-pull";
      "P" = "'magit-push";
    };
  };

  project = {
    enable = true;
    generalOne."efs/leader-keys"."P" = "project-prefix-map";
  };

  projection-multi = {
    enable = true;
    generalOne.project-prefix-map."RET" = "'projection-multi-compile";
    config = ''
      <<Emacs Development Projection Config>>
    '' ;
  };

  projection-multi-embark = {
      enable = true;
      after = ["embark" "projection-multi"];
      config = ''(projection-multi-embark-setup-command-map)'';
  };
#+end_src

#+NAME: Emacs Development Projection Config
#+begin_src emacs-lisp
  (require 'projection)
  (global-projection-hook-mode)
  (oset projection-project-type-maven build "mvn -B clean compile")
#+end_src

#+NAME: Emacs Magit Config
#+begin_src emacs-lisp
  (defun dired-git-add ()
      (interactive)
      (start-process "git" nil "git" "add" (dired-get-marked-files)))
#+end_src

**** DevDocs
#+NAME: Emacs Development DevDocs
#+begin_src nix
  devdocs = {
    enable = true;
    generalOne."efs/leader-keys"."hO" = "'devdocs-lookup";
  };
#+end_src

**** Plantuml
#+NAME: Emacs Development Plantuml
#+begin_src nix :noweb yes
  plantuml-mode = {
    enable = true;
    mode = [''"\\.plantuml\\'"'' ''"\\.puml\\'"''];
    custom = {
      org-plantuml-exec-mode = "'plantuml";
      # plantuml-default-exec-mode = "'executable";
      # plantuml-executable-path = ''"${pkgs.plantuml}/bin/plantuml"'';
      org-plantuml-executable-path = ''"${pkgs.plantuml}/bin/plantuml"'';
    }; 
    config = ''
      <<Emacs Development Plantuml Config>>
    '';
  };
#+end_src

#+NAME: Emacs Development Plantuml Config
#+begin_src emacs-lisp
  (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t)))

  (defun hex-encode (str)
    (string-join (mapcar (lambda (c) (format "%02x" c)) str)))

  (defun plantuml-server-encode-url (string)
    "Encode the string STRING into a URL suitable for PlantUML server interactions."
    (let* ((encoded-string (hex-encode string)))
      (concat plantuml-server-url "/" plantuml-output-type "/~h" encoded-string)))
#+end_src

**** Eglot
#+NAME: Emacs Development Eglot
#+begin_src nix :noweb yes
  eglot = {
    enable = true;
    ghook = ["('(html-ts-mode-hook js-ts-mode-hook ess-r-mode-hook css-ts-mode-hook json-ts-mode-hook racket-mode-hook bibtex-mode-hook nxml-mode-hook nix-mode-hook markdown-mode-hook LaTeX-mode-hook bash-ts-mode-hook java-ts-mode-hook c-ts-mode-hook python-ts-mode-hook sql-mode-hook) 'eglot-ensure)"];
    gfhook = ["('eglot-managed-mode-hook 'my/eglot-capf)"];
    generalTwo.local-leader.eglot-mode-map = {
      "f" = "'eglot-format-buffer";
      "a" = "'eglot-code-actions";
    };
    config = ''
      <<Emacs Eglot Config>>
    '';
  } ;

  eldoc-box = {
    enable = true;
    ghook = [
      "('(eglot-managed-mode-hook emacs-lisp-mode-hook) 'eldoc-box-hover-at-point-mode)"
      "('org-mode-hook 'eldoc-box-hover-mode)"
    ];
  };

  flymake = {
    enable = true;
    defer = true;
    config = ''(evil-ex-define-cmd "trouble" 'flymake-show-buffer-diagnostics)'';
  };

  eglot-tempel = {
    enable = true;
    after = ["eglot"];
    config = ''(eglot-tempel-mode)'';
  };

  # breadcrumb = {
  #   enable = true;
  #   ghook = ["('(bibtex-mode-hook nxml-mode-hook nix-mode-hook racket-mode-hook markdown-mode-hook LaTeX-mode-hook bash-ts-mode-hook ess-r-mode-hook html-ts-mode-hook css-ts-mode-hook emacs-lisp-mode-hook) 'breadcrumb-local-mode)"];
  # };
#+end_src

#+NAME: Emacs Eglot Config
#+begin_src emacs-lisp
  (dolist (server (list '((nxml-mode) . ("lemminx"))
  		      '((html-ts-mode) . ("vscode-html-language-server" "--stdio"))
  		      '((sql-mode) . ("sqls"))))
    (add-to-list 'eglot-server-programs server))
  (defun my/eglot-capf ()
    (setq-local completion-at-point-functions
                (list (cape-capf-super
                       #'tempel-complete
                       #'eglot-completion-at-point
                       #'cape-file)
                      #'cape-dabbrev)))
  (general-add-advice 'evil-collection-eglot-setup
    :after '(lambda ()
               (general-def 'normal eglot-mode-map "K" 'evil-substitute)))
#+end_src

***** Package Definitiions
#+begin_src nix :tangle emacs/emacs-packages/eglot-booster.nix
  { inputs, trivialBuild, eglot, emacs-lsp-booster, jsonrpc } :

  trivialBuild rec {
    pname = "eglot-booster";
    version = "current";
    src = inputs.eglot-booster;

    propagatedUserEnvPkgs = [
      eglot
      emacs-lsp-booster
      jsonrpc
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

#+begin_src nix :tangle emacs/emacs-packages/eglot-x.nix
  { inputs, trivialBuild, eglot  } :

  trivialBuild rec {
    pname = "eglot-booster";
    version = "current";
    src = inputs.eglot-booster;

    propagatedUserEnvPkgs = [
      eglot
    ];

    buildInputs = propagatedUserEnvPkgs;
  }
#+end_src

**** Dape
#+NAME: Emacs Development Dape
#+begin_src nix
  dape = {
    enable = true;
    after = ["eglot"];
    gfhook = ["('dape-on-stopped-hooks (list 'dape-info 'dape-repl))"];
    custom = {
      dape-window-arrangement = "gud";
      dape-key-prefix = ''"\C-x\C-a"'';
    };
  };
#+end_src

**** Python
Sets up emacs as a python IDE. (It can do anything pycharm can)
pyenv allows us to use virtual environments.

=bindings=
,cp- open a python repl
,cc- evaluate your code in the repl that you just opened up.
#+NAME: Emacs Development Python
#+begin_src nix
  python-ts-mode = {
    enable = true;
    mode = [''"\\.py\\'"''];
    custom = {
      python-shell-interpreter = ''"ipython"'';
    	python-shell-interpreter-args = ''"-i --simple-prompt"'';
    };
  };
#+end_src

**** Java
#+NAME: Emacs Development Java
#+begin_src nix
  groovy-mode = {
    enable = true;
    mode = [''"\\.gradle\\'"''];
  };
#+end_src

**** Nix
#+NAME: Emacs Development Nix
#+begin_src nix
  nix-mode = {
    enable = true;
    mode = [''"\\.nix\\'"''];
  };
#+end_src

**** Web Development
#+NAME: Emacs Development Webdev
#+begin_src nix
  html-ts-mode = {
    enable = true;
    mode = [''"\\.[px]?html?\\'"''];
  };

  emmet-mode = {
    enable = true;
    ghook = ["('(js-ts-mode-hook sgml-mode-hook css-ts-mode-hook html-ts-mode-hook) 'emmet-mode)"];
    custom.emmet-move-cursor-between-quotes = "t";
  };

  pug-mode = {
    enable = true;
    mode = [''"\\.pug\\'"''];
  };
#+end_src

**** Racket
#+NAME: Emacs Development Racket
#+begin_src nix
  racket-mode = {
    enable = true;
    mode = [''"\\.rkt\\'"''];
    gfhook = ["('racket-mode-hook 'hs-minor-mode)"];
    init = ''(setq auto-mode-alist (delete '("\\.rkt\\'" . scheme-mode) auto-mode-alist))'';
    config = ''(setq auto-mode-alist (delete '("\\.rkt\\'" . scheme-mode) auto-mode-alist))'';
    generalTwo.local-leader.racket-mode-map = {
      "RET" = "'geiser-racket";
      "." = "'racket-xp-describe";
      "r" = "'racket-run";
    };
  };
#+end_src

**** R
#+NAME: Emacs Development R
#+begin_src nix
  ess-r-mode = {
    enable = true;
    package = epkgs: epkgs.ess;
    mode = [''"\\.R\\'"''];
    custom.ess-ask-for-ess-directory = "nil";
  };
#+end_src

**** Zenscript
#+NAME: Emacs Development Zenscript
#+begin_src nix :noweb yes
  zenscript-mode = {
    enable = true;
    mode = [''"\\.zs\\'"''];
    # There's no way we're fixing the completion system, so we'll turn it off
    config = ''
      <<Emacs Zenscript Config>>
    '';
  };
#+end_src

#+NAME: Emacs Zenscript Config
#+begin_src emacs-lisp
  (defun zenscript-get-dumpzs (&optional prompt)
    "Returns nothing, because I can't fix the dumpfile problem"
    '(() . ()))
#+end_src

*** Password Management
#+begin_src nix :noweb yes :tangle emacs/passwords.nix
  { pkgs, ... }:

  {
    home.packages = with pkgs; [ pass ];

    programs.emacs.init.usePackage = {
      <<Emacs Pass>>
      
      <<Emacs Pinentry>>
    };
  }
#+end_src

**** Pass
This is an emacs wrapper for pass.
Password-store-otp has more functions, if they are of intrest.
Everything is bound to SPC p
#+NAME: Emacs Pass
#+begin_src nix
  password-store = {
    enable = true;
    defer = true;
    generalOne."efs/leader-keys" = {
      "p" = '''(:ignore t :which-key "pass")'';
      "py" = '''(password-store-copy :which-key "yank")'';
      "pi" = '''(password-store-insert :which-key "insert")'';
      "pg" = '''(password-store-generate :which-key "generate")'';
    };
    extraConfig = ":autoload pass-entries password-store-list";
  };

  password-store-otp = {
    enable = true;
    defer = true;
    generalOne."efs/leader-keys"."po" = '''(password-store-otp-token-copy :which-key "copy otp")'';
  };
#+end_src

**** Pinentry
This is a pinentry program (alternative to pinentry-dmenu)
When you're prompted for your gpg password, the place for entry will be your modeline.
#+NAME: Emacs Pinentry
#+begin_src nix :noweb yes
  pinentry = {
    enable = true;
    custom.epa-pinentry-mode = "'loopback";
    deferIncrementally = true;
    config = ''
      <<Emacs Pinentry Config>>
    '';
  };
#+end_src

#+NAME: Emacs Pinentry Config
#+begin_src emacs-lisp
  (pinentry-start)
  (shell-command "gpgconf --launch-agent")
  (shell-command "gpg-connect agent updatestartuptty /bye >/dev/null")
#+end_src

*** Writing
#+begin_src nix :noweb yes :tangle emacs/writing.nix
  { inputs, pkgs, ... }:

  {
    home.packages = with pkgs; [
      libreoffice-fresh
      hunspell
      hunspellDicts.en-us-large
      pandoc
      texliveFull
      unzip #for nov
    ];

    programs.emacs.init.usePackage = {
      <<Emacs Org Main>>

      <<Emacs Org Extensions>>
      
      <<Emacs Org Denote>>
      
      <<Emacs Latex>>
      
      <<Emacs Markdown>>
      
      <<Emacs Writeroom>>

      <<Emacs Spellcheck>>
      
      <<Emacs Citations>>

      <<Emacs Epub Reader>>
    };
  }
#+end_src

**** Org
***** Main Config
The org agenda syntax:
DEADLINE:<year-month-date>
How to add a latex package
: #+LATEX_HEADER: \usepackage{times}

#+NAME: Emacs Org Main
#+begin_src nix :noweb yes
  org = {
    enable = true;
    mode = [''("\\.org\\'" . org-mode)''];
    gfhook = ["('org-mode-hook '(efs/org-mode-setup my/org-capf))"];
    custom = {
      org-confirm-babel-evaluate = "nil";
      org-src-fontify-natively = "t";
      org-src-tab-acts-natively = "t";
      org-ellipsis = ''" ▾"'';
      org-log-done = "nil";
      org-log-into-drawer = "t";
      org-hide-emphasis-markers = "t";
      org-agenda-files = '''("~/doc/tasks.org")'';
      org-capture-templates = '''(("t" "Task" entry
                                    (file "~/doc/tasks.org")
                                    "* TODO %?\nDEADLINE: %^t"))'';
      org-emphasis-alist = '''(("*" bold)
                                 ("/" italic)
                                 ("=" org-verbatim verbatim)
                                 ("~" org-code verbatim)
                                 ("+" (:strike-through t))
                                 ("!" (:overline t) verbatim))'';
    };
    generalOne."efs/leader-keys" = {
      "o" = '''(:ignore t :which-key "org")'';
      "op" = '''org-capture'';
    };
    generalTwo.local-leader.org-mode-map = {
      "e" = '''(org-export-dispatch :which-key "export")'';
      "o" = '''(consult-org-heading :which-key "outline")'';
      "a" = '''(avy-org-goto-heading-timer :which-key "avy")'';
      "i" = '''(org-toggle-inline-images :which-key "show images")'';
      "b" = '''(org-edit-special :which-key "edit block")'';
    };

    config = ''
      <<Emacs Org Config>>
    '';
    init = ''
      <<Emacs Org Init>>
    '';
    deferIncrementally = ["calendar" "find-func" "format-spec" "org-macs" "org-compat" "org-faces" "org-entities" "org-list" "org-pcomplete" "org-src" "org-footnote" "org-macro" "ob" "org" "org-agenda" "org-capture" "evil-org-agenda"];
  };
#+end_src

#+NAME: Emacs Org Config
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t )
     (python . t)
     (R . t)))
  (push '("conf-unix" . conf-unix) org-src-lang-modes)

  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (dolist (mode (list '("sh" . "src shell")
  		    '("sg" . "src sage")
  		    '("el" . "src emacs-lisp")
  		    '("cc" . "src C")
  		    '("cs" . "src css")
  		    '("hl" . "src html")
  		    '("js" . "src javascript")
  		    '("nx" . "src nix")
  		    '("jv" . "src java")
  		    '("py" . "src python")))
    (add-to-list 'org-structure-template-alist mode))

  (defun my/org-capf ()
    (setq-local completion-at-point-functions
                (list (cape-capf-super
                       #'tempel-complete
                       #'cape-file)
  		    #'pcomplete-completions-at-point
  		    #'cape-dabbrev
  		    #'cape-dict)))

  (add-to-list 'evil-fold-list
  	     `((org-mode)
  	       :open org-cycle
  	       :open-all nil
  	       :close org-cycle
  	       :close-all nil
  	       :toggle org-cycle
  	       :delete nil
  	       :open-rec nil))
#+end_src

https://emacs.stackexchange.com/questions/20339/easiest-way-to-render-an-overline-in-org-mode
#+NAME: Emacs Org Init
#+begin_src emacs-lisp
  ;; (add-to-list 'org-emphasis-alist '("‾" (:overline t)))

  (defun efs/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^*\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

    ;;Set faces for heading levels
    (dolist (face '((org-document-title . 1.4)
                    (org-level-1 . 1.4)
                    (org-level-2 . 1.3)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.05)
                    (org-level-6 . 1.05)
                    (org-level-7 . 1.05)
                    (org-level-8 . 1.05)))
      (set-face-attribute (car face) nil :font "SF Pro" :weight 'regular :height (cdr face)))

    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (dolist (face (list 'org-block 'org-table 'org-formula 'org-checkbox 'line-number 'line-number-current-line))
      (set-face-attribute face nil :inherit 'fixed-pitch))
    (dolist (face (list 'org-code 'org-table 'org-verbatim))
      (set-face-attribute face nil :inherit '(shadow fixed-pitch)))
    (dolist (face (list 'org-special-keyword 'org-meta-line))
      (set-face-attribute face nil :inherit '(font-lock-comment-face fixed-pitch))))

  (defun efs/org-mode-setup ()
    (org-indent-mode)
    (ispell-minor-mode)
    (org-toggle-pretty-entities)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    (efs/org-font-setup))

#+end_src

***** Extensions
#+NAME: Emacs Org Extensions
#+begin_src nix :noweb yes
  org-contrib = {
    enable = true;
    config = ''(ox-extras-activate '(ignore-headlines))'';
    deferIncrementally = ["ox-extra"];
  };

  org-modern = {
    enable = true;
    ghook = ["('org-mode-hook 'global-org-modern-mode)"];
    custom = {
      org-modern-star = "'replace";
      org-modern-hide-stars = "'leading";
    };
  };

  org-modern-indent = {
    enable = true;
    package = epkgs: (pkgs.callPackage ./emacs-packages/org-modern-indent.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild compat;
    });
    afterCall = ["org-mode-hook"];
    config = ''(general-add-hook 'org-mode-hook 'org-modern-indent-mode 90)'';
  };

  org-auto-tangle = {
    enable = true;
    ghook = ["('org-mode-hook 'org-auto-tangle-mode)"];
  };

  org-auto-export-pandoc = {
    enable = true;
    ghook = ["('after-save-hook (lambda () (when (equal major-mode 'org-mode) (org-auto-export-pandoc))))"];
  };
#+end_src

****** Package Definition
#+begin_src nix :tangle emacs/emacs-packages/org-modern-indent.nix
  { inputs, trivialBuild, compat } :

  trivialBuild rec {
    pname = "org-modern-indent";
    version = "current";
    src = inputs.org-modern-indent;

    propagatedUserEnvPkgs = [
      compat
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

***** Denote
#+NAME: Emacs Org Denote
#+begin_src nix :noweb yes
  denote = {
    enable = true;
    defer = true;
    gfhook = ["('dired-mode-hook 'denote-dired-mode-in-directories)"];
    custom = {
      denote-directory = ''(expand-file-name "~/doc/denote")'';
      denote-known-keywords = '''("quotes" "chem" "emacs" "java" "physics" "calculus" "minecraft" "de" "proofs" "csse230" "os" "databases" "scifi" "softwarerequirements" "anthropology" "theoryofcomputation" "parallelcomp" "cybersecurity" "probstats" "scheme" "dreams" "softwaredevelopment" "ethics")'';
      denote-file-type = "nil";
      denote-dired-directories = "(list denote-directory)";
      
    };
    generalOne."efs/leader-keys" = {
      "oc" = '''(denote :which-key "create note")'';
      "or" = '''(denote-rename-file :whick-key "denote rename")'';
      "oi" = '''(denote-link :which-key "link to note")'';
    };
  };

  consult-notes = {
    enable = true;
    defer = true;
    config = ''
      <<Emacs Consult Notes Config>>
    '';
    generalOne."efs/leader-keys" = {
      "of" = '''(consult-notes :which-key "find note")'';
      "os" = '''(consult-notes-search-in-all-notes :which-key "search notes")'';
    };
  };
#+end_src

#+NAME: Emacs Consult Notes Config
#+begin_src emacs-lisp
  (with-eval-after-load 'embark
    (defvar-keymap consult-notes-map
      :doc "Keymap for Embark notes actions."
      :parent embark-file-map)
    (add-to-list 'embark-keymap-alist `(,consult-notes-category . consult-notes-map))
    ;; make embark-export use dired for notes
    (setf (alist-get consult-notes-category embark-exporters-alist) #'embark-export-dired))

  (when (locate-library "denote")
    (consult-notes-denote-mode))

#+end_src

**** Latex
Auctex turns emacs into a LaTeX IDE.

This configuration was taken from the emacs wiki. [[https://www.emacswiki.org/emacs/RefTeX][Reftex]] 
[[https://libredd.it/r/emacs/comments/4zvln1/editing_tex_documents/
][Also this reddit post]]
Reftex seems to do references
Magic latex buffer makes your source file look more like the pdf.
No idea what the rest of this is for.

| Key | CDLatex effect                    |
| `n  | greek letter \nu                    |
| TAB | magic. Ususally involves jumping. |
| equ | becomes an equation after tab     |
| beg | becomes an environment after tab  |

#+NAME: Emacs Latex
#+begin_src nix :noweb yes
  tex = {
    enable = true;
    package = epkgs: epkgs.auctex;
    init = ''(setq-default TeX-master nil)'';
    gfhook = [
      ''
        ('LaTeX-mode-hook (list 'magic-latex-buffer
                                       'visual-line-mode
                                       'LaTeX-math-mode
                                       'flyspell-mode))
      ''
      ''
        ('reftex-load-hook (lambda ()
                              (gsetq reftex-section-levels
                                 (cons '("poemtitle" . -3) reftex-section-levels))))
      ''
    ];
    custom = {
      reftex-label-alist = '''(("\\poemtitle" ?P "poem:" "\\ref{%s}" nil ("poem" "poemtitle")))'';
      reftex-format-cite-function = ''
        '(lambda (key fmt)
           (let ((cite (replace-regexp-in-string "%l" key fmt))
                 (if ( or (= ?~ (string-to-char fmt))
                       (member (preceding-char) '(?\ ?\t |/n ?~)))
                     cite
                   (concat "~" cite)))))
      '';
      TeX-auto-save = "t";
      TeX-parse-self = "t";
      reftex-plug-into-AUCTeX = "t";
    };
    generalTwo.local-leader.LaTeX-mode-map = {
      "p" = '''(preview-at-point :which-key "preview")'';
      "a" = '''(eglot-code-actions :which-key "code actions")'';
      "n" = '''(flymake-goto-next-error :which-key "next error")'';
      "e" = '''(flymake-goto-prev-error :which-key "previous error")'';
      "f" = '''(eglot-format :which-key "format")'';
      "u" = '''(preview-clearout-at-point :which-key "unpreview")'';
    };
  };
  pdf-tools = {
    enable = true;
    defer = true;
    generalOne.pdf-view-mode-map."C-s" = "'search-forward";
    custom = {
      # Makes PDFtools the default
      TeX-view-program-selection = '''((output-pdf "PDF Tools"))'';
      TeX-view-program-list = '''(("PDF Tools" TeX-pdf-tools-sync-view))'';
      TeX-source-correlate-start-server = "t";
    };
    config = ''
      <<Emacs Pdf Tools Config>>
    '';
    gfhook = [
      "('TeX-after-compilation-finished-functions #'TeX-revert-document-beffer)"
      "('pdf-view-mode-hook 'pdf-view-midnight-minor-mode)"];
    init = ''(setq-default pdf-view-display-size 'fit-width)'';
    extraConfig = '':magic ("%PDF" . pdf-view-mode)'';
  };
  magic-latex-buffer = {
    enable = true;
    defer = true;
    afterCall = ["LaTeX-mode-hook"] ;
  };

  cdlatex = {
    enable = true;
    defer = true;
    ghook = [
      "('LaTeX-mode-hook 'turn-on-cdlatex)"
      "('org-mode-hook 'org-cdlatex-mode)"
    ];
    generalTwo."'insert" = {
      cdlatex-mode-map."TAB" = "'cdlatex-tab";
      org-cdlatex-mode-map."TAB" = "'cdlatex-tab";
    };
  };
#+end_src

#+NAME: Emacs Pdf Tools Config
#+begin_src emacs-lisp
  (pdf-tools-install)
  (with-eval-after-load 'evil-collection-pdf
    (general-def 'normal pdf-view-mode-map
      "C-e" 'pdf-view-scroll-up-or-next-page
      "E" 'pdf-view-scroll-up-or-next-page
      "C-o" 'pdf-view-scroll-down-or-previous-page
      "O" 'pdf-view-scroll-down-or-previous-page))
#+end_src

**** Markdown
#+NAME: Emacs Markdown
#+begin_src nix :noweb yes
  markdown = {
    enable = true;
    defer = true;
    generalOne.markdown-mode-map."C-c C-e" = "'markdown-do";
    gfhook = ["('markdown-mode-hook (list 'outline-minor-mode 'efs/markdown-font-setup))"];
    mode = [''("\\.md\\'" . gfm-mode)''];
    custom = {
      markdown-command = ''"multimarkdown"'';
      markdown-hide-markup = "t";
    };
    generalTwo = {
      "'normal".markdown-mode-map = {
        "[h" = "'markdown-previous-visible-heading";
        "]h" = "'markdown-next-visible-heading";
      };  
      local-leader.markdown-mode-map = {
        "o" = '''(consult-outline :which-key "go to heading")'';
        "a" = '''(eglot-code-actions :which-key "code actions")'';
        "n" = '''(flymake-goto-next-error :which-key "next error")'';
        "e" = '''(flymake-goto-prev-error :which-key "previous error")'';
      };
    };
    init = ''
      <<Emacs Markdown Init>>
    '';
  };
#+end_src

#+NAME: Emacs Markdown Init
#+begin_src emacs-lisp
  (defun efs/markdown-font-setup ()
    (variable-pitch-mode)
    (dolist (face '((markdown-header-face-1 . 1.4)
                    (markdown-header-face-2 . 1.2)
                    (markdown-header-face-3 . 1.1)
                    (markdown-header-face-4 . 1.05)
                    (markdown-header-face-5 . 1.05)
                    (markdown-header-face-6 . 1.05)))
      (set-face-attribute (car face) nil :font "SF Pro" :weight 'regular :height (cdr face))))
#+end_src

**** Writeroom
I couldn't get olivetti to work.
#+NAME: Emacs Writeroom
#+begin_src nix
  writeroom-mode = {
    enable = true;
    ghook = ["('(woman-mode-hook org-agenda-mode-hook org-mode-hook Info-mode-hook markdown-mode-hook) 'writeroom-mode)"];
    gfhook = ["('writeroom-mode-hook 'visual-line-mode)"];
    custom = {
      writeroom-mode-line = "t";
      writeroom-maximize-window = "nil";
      writeroom-global-effects = "nil";
    };
    generalOne."efs/leader-keys"."w" = '''(writeroom-mode :which-key "writeroom")'';
  };
#+end_src

**** Spellcheck
#+NAME: Emacs Spellcheck
#+begin_src nix
  flyspell = {
    enable = true;
    custom.ispell-personal-dictionary = "~/.config/emacs/ispell.txt";
    ghook = [
      "('text-mode-hook 'flyspell-mode)"
      "('prog-mode-hook 'flyspell-prog-mode)"
    ];
  };
#+end_src

**** Citations
#+NAME: Emacs Citations
#+begin_src nix :noweb yes
  citar = {
    enable = true;
    config = ''(citar-denote-mode)'';
    ghook = ["('(LaTeX-mode-hook org-mode-hook) 'citar-capf-setup)"];
    custom = {
      org-cite-insert-processor = "'citar";
      org-cite-follow-processor = "'citar";
      org-cite-activate-processor = "'citar";
      citar-bibliography = '''("~/doc/uni.bib")'';
      org-cite-global-bibliography = '''("~/doc/uni.bib")'';
    };
  };

    citar-embark = {
      enable = true;
      after = ["citar" "embark"];
      config = ''(citar-embark-mode)'';
      custom.citar-at-point-function = "'embark-act";
    };

    citar-denote = {
      enable = true;
      command = ["citar-denote-mode"];
      generalOne."efs/leader-keys" = {
        "on" = '''(citar-create-note :which-key "new citar note")'';
        "oo" = '''(citar-denote-open-note :which-key "open citar note")'';
        "od" = "'citar-denote-dwim";
        "oe" = "'citar-denote-open-reference-entry";
        "ok" = "'citar-denote-add-citekey";
        "oK" = "'citar-denoter-remove-citekey";
        "ol" = "'citar-denote-link-reference";
        "ob" = "'citar-denote-find-reference";
        "ow" = "'citar-denote-find-citation";
      };
      config = ''
        <<Emacs Writing Citar Denote Config>>
      '';
      afterCall = ["citar"];
    };
#+end_src

#+NAME: Emacs Writing Citar Denote Config
#+begin_src emacs-lisp
  (defun citar-denote--create-note (citekey &optional _entry)
    "Create a bibliographic note for CITEKEY with properties ENTRY.

  The note file type is determined by `citar-denote-file-type'.

  The title format is set by `citar-denote-title-format'.

  When `citar-denote-subdir' is non-nil, prompt for a subdirectory.

  When `citar-denote-template' is a symbol, use the specified
  template, if otherwise non-nil, prompt for a Denote template.

  When `citar-denote-signature' is non-nil, prompt for a signature or
  use citation key."
    (denote
     (read-string "Title: " (citar-denote--generate-title citekey))
     (citar-denote--keywords-prompt citekey)
     citar-denote-file-type
     (when citar-denote-subdir
       (if (stringp citar-denote-subdir)
           (expand-file-name
            (concat denote-directory citar-denote-subdir))
         (denote-subdirectory-prompt)))
     nil
     (when citar-denote-template
       (or (alist-get citar-denote-template denote-templates)
           (denote-template-prompt)))
     (cond ((eq citar-denote-signature 'ask)
            (denote-signature-prompt nil "Signature: "))
           ((eq citar-denote-signature 'citekey)
            citekey)
           (nil nil)))
    (citar-denote--add-reference citekey)
    ;; Open available atachment in other window
    (when (one-window-p)
      (split-window-right))
    (other-window 1)
    (citar-open-files citekey))
#+end_src

**** Epub Reader
Nov allows you to read an epub file in a very similar way to an org file.
You can't get page numbers, though, which becomes unfortunate for doing citations.
#+NAME: Emacs Epub Reader
#+begin_src nix
  nov = {
    enable = true;
    defer = true;
    mode = [''("\\.epub\\'" . nov-mode)''];
  };
#+end_src

** Window Management
Almost everything here was copied from David Wilson. Thank you, David, for practically writing my config for me.

#+begin_src nix :noweb yes :tangle emacs/window-manager.nix
  { inputs, pkgs, config, ... }:

  {
    programs = {
      <<i3status>>

      emacs.init.usePackage = {
        <<Emacs Window Management Tab Bar>>
        
        <<Emacs Window Management Bufler>>

        <<Emacs Window Management Ace Window>>
        
        <<Emacs Window Management ELWM>>

        <<Emacs Window Management Golden Ratio>>
        
        <<Emacs Window Management EXWM>>
        
        <<Emacs Window Management Popper & Proced>>
      };
    };
  }
#+end_src

*** Tab Bar
I borrowed pretty heavily from here: https://github.com/jamescherti/vim-tab-bar.el
#+NAME: Emacs Window Management Tab Bar
#+begin_src nix
  tab-bar = {
    enable = true;
    config = ''(general-add-advice 'tab-new :after #'dashboard-open)'';
    ghook = ["('exwm-init-hook 'tab-bar-mode)"];
    general."s-u" = "'tab-bar-hydra/body";
    custom = {
      tab-bar-format = "'(tab-bar-format-tabs-groups tab-bar-separator doom-nano-tabline tab-bar-format-align-right tab-bar-format-global)";
      tab-bar-close-button-show = "nil";
      # tab-bar-auto-width = "nil";
    };
    extraConfig = ''
      :pretty-hydra
      ((:color amaranth)
       ("Navigation"
        (("e" #'evil-tab-next "next")
         ("o" #'tab-bar-switch-to-prev-tab "prev")
         ("v" #'tab-recent "recent")
         ("b" #'tab-bar-lost-commands-switch-to-first-tab "first")
         ("B" #'tab-bar-lost-commands-switch-to-last-tab "last")
         ("/" #'tab-bar-select-tab-by-name "search" :color blue))
        "Creation/Deletion"
        (("s" #'tab-new "new")
         ("k" #'tab-close "close")
         ("r" #'tab-rename "rename")
         ("u" #'tab-undo "undo"))
        "Groups"
        (("g" #'tab-group "add to group")
         ("K" #'tab-close-group "close group"))
        "Organization"
        (("E" #'tab-bar-lost-commands-move-tab-forward "forward")
         ("O" #'tab-bar-lost-commands-move-tab-backward "backward"))
        "Exit"
        (("<return>" nil "" :color blue)
         ("<escape>" nil "" :color blue))))
    '';
  };

  tab-bar-lost-commands = {
    enable = true;
    command = [
      "tab-bar-lost-commands-move-tab-forward"
      "tab-bar-lost-commands-move-tab-backward" 
      "tab-bar-lost-commands-switch-to-first-tab" 
      "tab-bar-lost-commands-switch-to-last-tab" 
    ];
  };
#+end_src

*** Bufler
Bufler is the other half of tab bar. It lets us automatically narrow buffers down to a given workspace
#+NAME: Emacs Window Management Bufler
#+begin_src nix :noweb yes
  bufler = {
    enable = true;
    ghook = ["('tab-bar-mode-hook 'bufler-mode)"];
    general = {
      "s-h" = "'hydra:bufler/body";
      "s-b" = "'bufler-hydra/body";
      "s-f" = "'bufler-workspace-focus-buffer";
      "s-F" = "'bufler-workspace-set";
    };
    generalTwo."'normal".evil-collection-unimpaired-mode-map = {
      "]b" = "'bufler-cycle-buffers-forward";
      "[b" = "'bufler-cycle-buffers-backward";
    };
    custom.bufler-groups = ''
      <<Emacs Bufler Defgroups>>
    '' ;
    init = ''
      <<Emacs Bufler Init>>
    '';
    config = ''
      <<Emacs Bufler Config>>
    '';
    extraConfig = ''
      :pretty-hydra
      ((:color amaranth)
        ("Move"
         (("o" bufler-cycle-buffers-backward "prev")
          ("e" bufler-cycle-buffers-forward "next"))
         "Tricks"
         (("/" consult-buffer "search" :color blue :exit t)
          ("i" ibuffer "list (ibuffer)" :color blue :exit t)
          ("k" kill-current-buffer "delete"))
         "Quit"
         (("<escape>" nil "quit" :color blue :exit t)
          ("<return>" nil "quit" :color blue :exit t))))
    '';
  };

  bufler-workspace-tabs = {
    enable = true;
    ghook = ["('bufler-mode-hook 'bufler-workspace-workspaces-as-tabs-mode)"];
    gfhook = ["('bufler-workspace-workspaces-as-tabs-mode-hook '(global-tab-line-mode burly-tabs-mode))"];
  };
#+end_src

#+NAME: Emacs Bufler Defgroups
#+begin_src emacs-lisp
  (bufler-defgroups
    ;; Subgroup collecting all named workspaces.
    (group (auto-workspace))
    ;; Subgroup collecting buffers in a project.
    (group (auto-project))
    ;; Subgroup collecting tramp buffers
    (group (auto-tramp))
    ;; Grouping browser windows
    (group
     (group-or "Browsers"
               (name-match "Qutebrowser" (rx bos "Qutebrowser"))
               (mode-match "eww-mode" (rx bos "eww-"))
               (name-match "Tor Browser" (rx bos "Tor Browser"))))
    (group
     (group-or "Chat"
               (name-match "Thunderbird" (rx bos "Thunderbird"))
               (name-match "teams-for-linux" (rx bos "teams-for-linux"))
               (mode-match "ement" (rx bos "ement-"))
               (name-match "Vesktop" (rx bos "Vesktop"))))
    (group
     (group-or "Media"
               (name-match "mpv" (rx bos "Mpv"))
               (mode-match "elfeed-search-mode" (rx bos "elfeed-"))
               (mode-match "elfeed-show-mode" (rx bos "elfeed-"))
  	     (mode-match "yeetube-mode" (rx bos "yeetube-"))))
    (group
     (group-or "Agenda"
               (name-match "tasks.org" (rx bos "tasks.org"))
               (mode-match "org-agenda-mode" (rx bos "org-agenda-"))))
    (group
     (group-or "Notes"
               (dir "~/doc/denote/")))
    ;; (group
    ;;  (group-or "Writing"
    ;;            (name-match "libreoffice" (rx bos "libreoffice"))
    ;;            (mode-match "org-mode" (rx bos "org-"))
    ;;            (mode-match "gfm-mode" (rx bos "gfm-"))))
    (group
     (group-or "AV"
               (name-match "lmms" (rx bos "lmms"))
               (name-match "Gimp-2.10" (rx bos "Gimp-2.10"))
               (name-match "kdenlive" (rx bos "kdenlive"))))
    (group
     (group-or "Games"
               (dir "~/.local/PrismLauncher/")
               (name-match "Minecraft" (rx bos "Minecraft"))
               (name-match "PrismLauncher" (rx bos "PrismLauncher"))))
    (group
     ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
     (group-or "Help/Info"
               (mode-match "*Help*" (rx bos (or "help-" "helpful-")))
               (mode-match "*Info*" (rx bos "info-"))))
    (group
     ;; Subgroup collecting all special buffers (i.e. ones that are not
     ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
     ;; through to other groups, so they end up grouped with their project buffers).
     (group-and "*Special*"
                (name-match "**Special**"
                            (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace" "Pinentry") "*"))
                (lambda (buffer)
                  (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                       buffer)
                              (funcall (mode-match "Dired" (rx bos "dired"))
                                       buffer)
                              (funcall (auto-file) buffer))
                    "*Special*"))))
    (auto-directory))
#+end_src

#+NAME: Emacs Bufler Init
#+begin_src emacs-lisp
  ;; These functions were adapted from perspective-exwm
  (defun bufler-cycle-buffers (proc)
    "Switches to the next or previous buffer in the workspace, if one exists, or the next buffer anywhere, if one doesn't exist."
    (let* ((workspace (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find))))
      (if workspace
          (let* ((current (current-buffer))
                 (buffer-list (mapcar #'cdr
                                      (bufler-buffer-alist-at workspace :filter-fns bufler-filter-buffer-fns)))
                 (current-pos (or (cl-position current buffer-list) -1))
                 (len (length buffer-list))
                 (next-pos (% (+ current-pos len
                                 (if (eq proc 'evil-next-buffer) (- len 1) -1))
                              len))
                 (next-buffer (nth next-pos buffer-list)))
            (switch-to-buffer next-buffer))
        (funcall proc))))
  (defun bufler-cycle-buffers-forward ()
    "Cycles the buffers in the workspace forward."
    (interactive)
    (bufler-cycle-buffers 'evil-next-buffer))
  (defun bufler-cycle-buffers-backward ()
    "Cycles the buffers in the workspace backward."
    (interactive)
    (bufler-cycle-buffers 'evil-prev-buffer))

#+end_src

#+NAME: Emacs Bufler Config
#+begin_src emacs-lisp
  (defun bufler-bar ()
    (interactive)
    (bufler-sidebar)
    (with-selected-window (get-buffer-window "*Bufler*")
      (gsetq window-size-fixed 'width)
      (window-resize (selected-window) (- 35 (window-total-width)) t t)))
  (evil-ex-define-cmd "ls" 'bufler-bar)

  (evil-collection-define-key 'normal 'bufler-list-mode-map
    (kbd "RET") 'bufler-list-buffer-switch
    (kbd "M-RET") 'bufler-list-buffer-peek
    "D" 'bufler-list-buffer-kill)

#+end_src

*** Ace Window
#+NAME: Emacs Window Management Ace Window
#+begin_src nix
  ace-window = {
    enable = true;
    defer = true;
    command = ["ace-window"];
    general."C-x o" = "'ace-window";
    config = ''(ace-window-posframe-mode)'';
    custom = {
      aw-scope = "'visible";
      aw-keys = "'(?a ?r ?s ?t ?d ?h ?n ?e ?i ?c)";
    };
  };
#+end_src

*** ELWM
#+NAME: Emacs Window Management ELWM
#+begin_src nix :noweb yes
  elwm = {
    enable = true;
    defer = true;
    command = ["elwm-next" "elwm-prev" "elwm-rotate-window" "elwm-derotate-window" "elwm-split-window"];
    config = ''
      <<Emacs Elwm Config>>
    '';
    init = ''
      <<Emacs Elwm Init>>
    '';
  };
#+end_src

#+NAME: Emacs Elwm Config
#+begin_src emacs-lisp
  (defun elwm-split-window ()
    "Split window according to the current layout.
    
    Window in the master area can't be split, instead the last window
    in the stack will be split.
    
    If selected window is window on the stack, the new window will be
    created next to it, according to the current layout."
    (interactive)
    (let ((buf (current-buffer)))
      (if (eq (count-windows) 1)
          (evil-window-vsplit)
        (cond
         ((eq elwm-current-layout 'tile-vertical-left)
          (if (elwm--in-master-area-p)
              ;; split the last window on the stack instead
              (set-window-buffer
               (select-window (split-window (car (last (elwm--sorted-window-list))) nil nil))
               buf)
            (evil-window-split)))
         ((eq elwm-current-layout 'tile-horizontal-top)
          (if (elwm--in-master-area-p)
              ;; split the last window on the stack instead
              (set-window-buffer
               (select-window (split-window (car (last (elwm--sorted-window-list))) nil t))
               buf)
            (evil-window-split)))))))

#+end_src

#+NAME: Emacs Elwm Init
#+begin_src emacs-lisp
  (defun elwm-next ()
    "Go to the next visible window, or if there is 1 window, the next buffer in the workspace"
    (interactive)
    (if (eq (count-windows) 1)
        (bufler-cycle-buffers-forward)
      (elwm-activate-window)))
  (defun elwm-deactivate-window () (interactive) (elwm-activate-window (prefix-numeric-value -1)))
  (defun elwm-prev ()
    "Go to the previous visible window, or if there is 1 window, the previous buffer in the workspace"
    (interactive)
    (if (eq (count-windows) 1)
        (bufler-cycle-buffers-backward)
      (elwm-deactivate-window)))
  (defun elwm-derotate-window () (interactive) (elwm-rotate-window (prefix-numeric-value -1)))

#+end_src

*** Golden Ratio
#+NAME: Emacs Window Management Golden Ratio
#+begin_src nix
  golden-ratio = {
    enable = true;
    defer = true;
    ghook = ["('on-first-input-hook 'golden-ratio-mode)"];
  };
#+end_src

*** EXWM
Installs exwm, deals with randr, executes autostart, & sets up binds.
| Binding | Command                |
| s-i     | Window managment hydra |
| s-s     | slock                  |
| s-'     | toggle popup           |
| s-"     | cycle popup            |
| s-C-'   | add/remove popup tag   |
| s-b     | switch buffer          |
| s-d     | launch program         |
| s-t     | task manager           |

+ exwm-mff: When you move to a different window, the mouse teleports to the center.
=exwm-edit Keybindings=
+ C-c C-' or C-c ': edit
+ C-c C-' or C-c C-c: finish editing
+ C-c C-k: cancel edit
#+NAME: Emacs Window Management EXWM
#+begin_src nix :noweb yes
  exwm = {
    enable = true;
    gfhook = [
      # When window "class" updates, use it to set the buffer name
      "('exwm-update-class-hook 'efs/exwm-update-class)"
      # When EXWM starts up, do some extra configuration
      "('exwm-init-hook 'efs/exwm-init-hook)"
      "('exwm-mode-hook 'evil-motion-state)"
      # When window title updates, use it to set the buffer name
      "('exwm-update-title-hook 'efs/exwm-update-title)"
    ];
    # Ctrl+q will enable the next key to be sent directly
    generalOne.exwm-mode-map."C-q" = "'exwm-input-send-next-key";
    generalTwo.local-leader.exwm-mode-map = {
      "n" = '''(lambda () (interactive) (start-process-shell-command "warpd" nil "warpd --normal"))'';
      "x" = '''(lambda () (interactive) (start-process-shell-command "warpd" nil "warpd --hint"))'';
      "g" = '''(lambda () (interactive) (start-process-shell-command "warpd" nil "warpd --grid"))'';
    };
    custom = {
      exwm-manage-force-tiling = "t";
      # Emacs everywhere
      exwm-input-simulation-keys = '''(([?\C-h] . [backspace]))'';
      exwm-workspace-number = "1";
      # Automatically move EXWM buffer to current workspace when selected
      exwm-layout-show-all-buffers = "t";
      # Display all EXWM buffers in every workspace buffer list
      exwm-workspace-show-all-buffers = "t";
      # This will need to be updated to the name of a display!  You can find
      # the names of your displays by looking at arandr or the output of xrandr
      exwm-randr-workspace-monitor-plist = '''(1 "eDP-1-1") (2 "HDMI-0")'';
      # Automatically send the mouse cursor to the selected workspace's display
      exwm-workspace-warp-cursor = "t";
      # Window focus should follow the mouse pointer
      mouse-autoselect-window = "nil";
      focus-follows-mouse = "nil";
      # These keys should always pass through to Emacs
      exwm-input-prefix-keys = '''(?\M-`
                                   ?\C-^
                                   ?\M-&
                                   ?\s-\M-'
                                   ?\s-b
                                   ?\M-u
                                   ?\M-:
                                   ?\s-o
                                   ?\s-c
                                   ?\s-v
                                   ?\s-n
                                   ?\s-i
                                   ?\s-e
                                   ?\s-f
                                   ?\s-F
                                   ?\s-u
                                   ?\s-'	;; popper-toggle-latest
                                   ?\s-\" ;; popper-toggle-type
                                   ?\C-\ 
                                   XF86AudioRaiseVolume
                                   XF86AudioLowerVolume
                                   XF86AudioMute
                                   ?\M-\ )'';
      # Set up global key bindings.  These always work, no matter the input state!
      # Keep in mind that changing this list after EXWM initializes has no effect.
      exwm-input-global-keys = ''`(;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
                                     ([?\s-r] . exwm-reset)
                                     ([?\s-a] . evil-ex)
      
                                      ;; Launch applications (basically dmenu)
                                      ([?\s-d] . app-launcher-run-app)
                                      ([?\s-t] . proced)
      
                                      ;;Movement
                                      ([?\s-e] . elwm-next)
                                      ([?\s-o] . elwm-prev)
                                      ([?\s-/] . ace-window)
      
                                      ;; Arrangement
                                      ([?\s-E] . elwm-rotate-window)
                                      ([?\s-O] . elwm-derotate-window)
                                      ([?\s-c] . elwm-split-window)
                                      ([?\s-n] . evil-window-move-far-left)
                                      ([?\s-i] . evil-window-move-far-right)
                                      ([?\s-j] . winner-undo)
                                      ([?\s-J] . winner-redo)
                                      ([?\s-r] . exwm-reset)
                                      ([?\s-m] . toggle-single-window)
                                      ([?\s-k] . evil-window-delete)
                                      ([?\s-K] . evil-delete-buffer-and-window)
      
                                      ;; Shell bindings
                                      ([?\s-s] . (lambda () (interactive) (shell-command "slock")))
                                      ([?\s-y] . (lambda () (interactive) (start-process-shell-command
                                                                           "maim" nil  "${pkgs.maim}/bin/maim ~/pic/screenshot.png"))))'';
      
    };
    afterCall = ["on-init-ui-hook"];
    init = ''
      <<Emacs Exwm Init>>
    '';
    config = ''
      <<Emacs Exwm Config>>
    '';
    after = ["repeaters"];
  };

  exwm-mff = {
    enable = true;
    defer = true;
    ghook = ["('exwm-init-hook 'exwm-mff-mode)"];
  };

  exwm-edit = {
    enable = true;
    generalTwo.local-leader.exwm-mode-map."c" = "'exwm-edit--compose";
    after = ["exwm"];
  };

  exwm-outer-gaps = {
    enable = true;
    package = epkgs: (epkgs.callPackage ./emacs-packages/exwm-outer-gaps.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild exwm xelb;
    });
    demand = true;
    config = ''(exwm-outer-gaps-mode)'';
    after = ["exwm"];
  };
#+end_src

#+NAME: Emacs Exwm Init
#+begin_src emacs-lisp
  (defun efs/exwm-init-hook ()
    ;; Make workspace 0 be the one where we land at startup
    (exwm-workspace-switch-create 0)
    
    ;; Show status in the mode line
    (start-process-shell-command "xbanish" nil "${pkgs.xbanish}/bin/xbanish"))
  (defun efs/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))

  (defun efs/exwm-update-title ()
    (pcase exwm-class-name
      ("qutebrowser" (exwm-workspace-rename-buffer (format "Qutebrowser: %s" exwm-title)))
      ("mpv" (exwm-workspace-rename-buffer (format "Mpv: %s" exwm-title)))))

  ;; From dmacs
  (defvar single-window--last-configuration nil "Last window configuration before calling `delete-other-windows'.")
  ;; From dmacs
  (defun toggle-single-window ()
    "Un-maximize current window.
    If multiple windows are active, save window configuration and
    delete other windows.  If only one window is active and a window
    configuration was previously save, restore that configuration."
    (interactive)
    (if (= (count-windows) 1)
        (when single-window--last-configuration
          (set-window-configuration single-window--last-configuration)
  	(when treesitter-context-mode (treesitter-context-focus-mode -1)))
      (setq single-window--last-configuration (current-window-configuration))
      (delete-other-windows)
      (when (and treesitter-context-mode)
        (treesitter-context-focus-mode 1))))

  (defun evil-delete-buffer-and-window ()
    "kill the current buffer & its window"
    (interactive)
    (kill-current-buffer)
    (unless (one-window-p)
      (evil-window-delete)))

#+end_src

#+NAME: Emacs Exwm Config
#+begin_src emacs-lisp
  ;; Set the screen resolution (update this to be the correct resolution for your screen!)
  (winner-mode)
  (require 'exwm-randr)
  (exwm-randr-mode)

  (repeaters-define-maps
   '(("delete-windows"
      evil-delete-buffer-and-window "q")))
  (repeaters-define-maps
   '(("input-keys"
      exwm-input-send-next-key "q")))
  (exwm-input-set-key (kbd "s-<return>") 'efs/make-eshell)
  (exwm-enable)

  ;; (defun exwm-workspace-attach-minibuffer ()
  ;;   "Attach the minibuffer making it always visible."
  ;;   (interactive)
  ;;   (unless efs/vertico-active
  ;;     (exwm--log)
  ;;     (when (and (exwm-workspace--minibuffer-own-frame-p)
  ;;                (not (exwm-workspace--minibuffer-attached-p)))
  ;;       ;; Reset the frame size.
  ;;       (set-frame-height exwm-workspace--minibuffer 1)
  ;;       (redisplay)                       ;FIXME.
  ;;       (setq exwm-workspace--attached-minibuffer-height
  ;;             (frame-pixel-height exwm-workspace--minibuffer))
  ;;       (exwm-workspace--show-minibuffer)
  ;;       (let ((container (frame-parameter exwm-workspace--minibuffer
  ;; 					'exwm-container)))
  ;; 	(push (cons container
  ;;                     (if (eq exwm-workspace-minibuffer-position 'top)
  ;; 			(vector 0 0 exwm-workspace--attached-minibuffer-height 0)
  ;;                       (vector 0 0 0 exwm-workspace--attached-minibuffer-height)))
  ;;               exwm-workspace--id-struts-alist)
  ;; 	(exwm-workspace--update-struts)
  ;; 	(exwm-workspace--update-workareas)
  ;; 	(dolist (f exwm-workspace--list)
  ;;           (exwm-workspace--set-fullscreen f))))))
#+end_src

**** Package Definitions
#+begin_src nix :tangle emacs/emacs-packages/exwm-outer-gaps.nix
  { inputs, trivialBuild, xelb, exwm } :

  trivialBuild rec {
    pname = "exwm-outer-gaps";
    version = "current";
    src = inputs.exwm-outer-gaps;

    propagatedUserEnvPkgs = [
      xelb
      exwm
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

*** Popper & Proced
#+NAME: Emacs Window Management Popper & Proced
#+begin_src nix :noweb yes
  popper = {
    enable = true;
    ghook = ["('on-first-buffer-hook 'popper-mode)"];
    general = {
      "s-'" = "'popper-toggle";
      "s-\\\"" = "'popper-cycle";
      "C-s-'" = "'popper-toggle-type";
    };
    custom = {
      popper-window-height = "30";
      popper-group-function = "'popper-group-by-project";
      popper-reference-buffers = '''(help-mode
                                       helpful-mode
                                       compilation-mode
                                       inferior-python-mode
                                       occur-mode
                                       grep-mode
                                       "^\\*.*eshell\\*"
                                       "^\\*eat\\*"
                                       "^\\*Sage\\*"
                                       flymake-diagnostics-buffer-mode
    			                             geiser-repl-mode
                                       dape-repl-mode
    			                             racket-repl-mode
                                       inferior-ess-r-mode
                                       ;; sage-shell-mode
                                       cider-repl-mode)'';
    };
  };

  proced = {
    enable = true;
    command = ["proced"];
    config = ''
      <<Emacs Proced Config>>
    '';
  };
#+end_src

#+NAME: Emacs Proced Config
#+begin_src emacs-lisp
  (general-def 'normal proced-mode-map
    "j" 'proced-unmark
    "k" 'proced-send-signal)
#+end_src

*** i3status
#+NAME: i3status
#+begin_src nix
  i3status-rust = {
    enable = true;
    bars."default" = {
      blocks = [
  		  {
  			  block = "time";
  			  format =  "$icon $timestamp.datetime(f:'%a %d/%m %R')";
  			  interval = 60;
  		  }
        # {
        #   block = "music";
        # }
        {
  			  block = "battery";
  			  format =  "$icon $percentage";
  			  interval = 60;
  		  }
  	  ];
      icons = "awesome6";
      settings.theme.overrides = {
        idle_bg = "#" + config.lib.stylix.colors.base00;
        idle_fg = "#" + config.lib.stylix.colors.base05;
        info_bg = "#" + config.lib.stylix.colors.base00;
        info_fg = "#" + config.lib.stylix.colors.base05;
        good_bg = "#" + config.lib.stylix.colors.base00;
        good_fg = "#" + config.lib.stylix.colors.base05;
        warning_bg = "#" + config.lib.stylix.colors.base00;
        warning_fg = "#" + config.lib.stylix.colors.base05;
        critical_bg = "#" + config.lib.stylix.colors.base00;
        critical_fg = "#" + config.lib.stylix.colors.base05;
        # alternating_tint_bg = "#" + config.lib.stylix.colors.base00;
        separator_bg = "#" + config.lib.stylix.colors.base00;
        separator_fg = "#" + config.lib.stylix.colors.base05;
        separator = "  ";
      };
    };
  };

  emacs.init.usePackage.i3bar = {
    enable = true;
    ghook = ["('tab-bar-mode-hook 'i3bar-mode)"];
    
    custom = {
      i3bar-command = ''"${(import ../scripts/i3status-rust.nix {inherit pkgs;})}/bin/i3status-rust"'';
    };
  };
#+end_src

** Multimedia
This is where all the audio/video stuff goes
#+begin_src nix :tangle multimedia.nix :noweb yes
  { pkgs, config, inputs, ... }:

  {
    home.packages = with pkgs; [
      yt-dlp
      (config.lib.nixGL.wrap obs-studio)
      (config.lib.nixGL.wrap kdenlive)
      lmms
      mpc-cli
      (import ./scripts/doomer.nix { inherit pkgs; })
      (import ./scripts/masstube.nix { inherit pkgs; }) # Doesn't have its tor dependency declared.
      (import ./scripts/cast.nix { inherit pkgs; })
    ];

    <<Mpd>>

    <<Mpv>>

    programs.emacs.init.usePackage = {
      <<Emacs Pulseaudio Control>>
    };
  }
#+end_src

*** MPD
#+NAME: Mpd
#+begin_src nix :noweb yes
  services.mpd = {
    enable = true;
    musicDirectory = "${config.home.homeDirectory}/mus/mpd";
    extraConfig = ''
      audio_output {
        type "pipewire"
        name "My Pipewire Output"
        mixer_type "hardware"
        mixer_device "default"
        mixer_control "PCM"
      }
    '';
  };

  programs.emacs.init.usePackage.mpc-wrapper = {
    enable = true;
    package = epkgs: (epkgs.callPackage ./emacs/emacs-packages/mpc-wrapper.nix {
      inherit inputs;
      inherit (epkgs) trivialBuild;
    });    
    generalOne."efs/leader-keys" = {
      "m" = '''(:ignore t :which-key "mpd")'';
      "mp" = '''(mpc-play :which-key "replay file")'';
      "mm" = '''(music-menu :which-key "menu")'';
      "ms" = '''(mpc-stop :which-key "stop")'';
    };
    deferIncrementally = true;
    config = ''
      <<Emacs Mpc Wrapper Config>>
    '';
  };
#+end_src

#+NAME: Emacs Mpc Wrapper Config
#+begin_src emacs-lisp
  (defun mpc-add (file)
    "Add FILE to the queue. FILE is a string."
    (shell-command (concat "mpc add " "\"" file "\"")))
  (defun music-menu ()
    "Play music from a menu."
    (interactive)
    (mpc-clear)
    (mpc-add (completing-read "Choose a song: " (mpc-ls)))
    (mpc-play))

#+end_src


**** Package Definitions
#+begin_src nix :tangle emacs/emacs-packages/mpc-wrapper.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "mpc-wrapper";
    version = "current";
    src = inputs.mpc-wrapper;
  }
#+end_src

*** MPV
The mpv package lets us start an mpv process & puppeteer it with emacs. I'm definitely not using it to its full potential.
=efs/mpv-browse-url= originates from https://karthinks.com/software/lazy-elfeed/
#+NAME: Mpv
#+begin_src nix :noweb yes
  programs.emacs.init.usePackage.mpv = {
    enable = true;
    command = ["efs/mpv-browse-url" "efs/mpv-eww-url"];
    config = ''
    <<Emacs Mpv Config>>
  '';
  };

  programs.mpv = {
    enable = true;
    package = (config.lib.nixGL.wrap (pkgs.mpv.override {
      scripts = with pkgs.mpvScripts; [
        thumbnail
        sponsorblock
      ];
    }));
    config = {
      fs = "no";
      hwdec = "auto";
      x11-bypass-compositor = "no";
      volume-max = "250";
    };
  };
#+end_src

#+NAME: Emacs Mpv Config
#+begin_src emacs-lisp
  (defun efs/mpv-browse-url (url &optional single)
    (mpv-play-url url))

  (defun efs/mpv-eww-url ()
    (interactive)
    (mpv-play-url (eww-current-url)))
#+end_src

*** Pulseaudio Control
#+NAME: Emacs Pulseaudio Control
#+begin_src nix
  pulseaudio-control = {
    enable = true;
    custom.pulseaudio-control-volume-step = ''"5%"'';
    general = {
      "<XF86AudioRaiseVolume>" = "'pulseaudio-control-increase-sink-volume";
      "<XF86AudioLowerVolume>" = "'pulseaudio-control-decrease-sink-volume";
      "<XF86AudioMute>" = "'pulseaudio-control-toggle-current-sink-mute";
      "s-v" = "'pulseaudio-control-default-sink-mode";
    };
  };
#+end_src

** Sagemath
Sagemath is my goto for dealing with complex math. It makes for a wonderful maple replacement.
#+begin_src nix :tangle sage.nix :noweb yes
  { pkgs, ... }:
  {
    home.packages = with pkgs; [ sage ];

    <<Sage Emacs>>

    home.file.".config/sage/ipython-5.0.0/profile_default/startup/00nix.py".text = ''
      <<sage-config>>
    '';
  }
#+end_src

*** Useful functions
I wrote these to help me with a class I was taking. I don't really use them anymore
#+NAME: sage-config
#+begin_src python-ts
  # Combo functions
  def permutation(n, r):
    return factorial(n)/factorial(n - r)

  def combo(n, r):
    return permutation(n, r)/factorial(r)

  # Probstats functions
  def pbinary(n, p, x):
    """Returns the probability of a binary distribution"""
    return combo(n, x)*(p**x)*((1-p)**(n-x))

  def ebinary(n, p):
    """Returns the expectation (mean) of a binary distribution"""
    return n*p

  def ppoisson(x, lam):
    """Returns the probability of the poisson distribution"""
    return (exp(-lam)*lam**x)/factorial(x)
  def poisprocess(lam, s, t, n):
    """Returns the probability of the poisson process
          lam: lambda (the rate)
          s: the start time
          t: the end time
          n: the number of occurrances"""
    return (((lam*(t - s))**n)*exp(-lam*(t - s)))/factorial(n)

  def expecpoisprocess(lam, s, t):
    """Returns the expectancy of a poisson process
         lam: lambda (the rate)
          s: the start time
          t: the end time"""
    return lam*(t-s)

  def pnormal(x, mu, sigma):
    """Returns the probability of a normal random variable
       x: the other variable
       mu: the expectancy
       sigma: the variance"""
    return exp(-((x-mu)**2)/(2*sigma))/sqrt(2*pi*sigma)
#+end_src

*** Emacs
Putting =:session= in an org block is necessary for evaluation
,cgo clears your sage buffer.
,cc evaluates the sage commands in an org file.
#+NAME: Sage Emacs
#+begin_src nix
  programs.emacs.init.usePackage = {
    sage-shell-mode = {
      enable = true;
      defer = true;
      custom."sage-shell-edit:display-function" = ''"display-buffer"'';
      config = ''(sage-shell:define-alias)'';
      generalOne."efs/leader-keys"."S" = '''(run-sage :which-key "sage")'';
      generalTwo."local-leader"."sage-shell-mode-map"."h" = "'sage-shell:help";
    };

    ob-sagemath = {
      enable = true;
      afterCall = ["sage-shell-mode" "ob"];
    };
  };
#+end_src

** Internet
#+begin_src nix :tangle internet.nix :noweb yes
  { inputs, config, pkgs, pkgs-stable, lib, ... }:

  {
    home.packages = with pkgs; [
      pkgs-stable.python39Packages.adblock
      (config.lib.nixGL.wrap tor-browser)
    ];

    programs.emacs.init.usePackage = {
      <<Emacs Internet Browse URL>>

      <<Emacs Internet EWW>>

      <<Emacs Internet Yeetube>>

      # <<Emacs Internet Ement>>

      <<Emacs Internet Webjump>>

      <<Emacs Internet Elfeed>>
    };

    <<Internet Qutebrowser>>
  }
#+end_src

*** Browse URL
This lets us decide how emacs will handle certain urls
+ Under most circumstances, a youtube link will be opened by mpv (notable exception being if we're searching)
You need regexes to do this, & you can build them easily using =rx=
#+NAME: Emacs Internet Browse URL
#+begin_src nix
  browse-url = {
    enable = true;
    config = "(defun qutebrowser-browse-url (url &rest args) (qutebrowser-open-url url 'tab))";
    custom = {
      browse-url-handlers = ''
        '(("https:\\/\\/www\\.youtu\\.*be." . efs/mpv-browse-url)
          ("https:\\/\\/yewtu\\.*be." . efs/mpv-browse-url)
          ("https:\\/\\/inv\\.*nadeko\\.*net\\/watch." . efs/mpv-browse-url)
          ("search\\.nixos\\.org[^z-a]*" . qutebrowser-browse-url)
          ("melpa\.org\.*" . qutebrowser-browse-url)
          ("." . (lambda (url &rest args) (eww url (prefix-numeric-value 4)))))
      '';
      browse-url-secondary-browser-function = "'browse-url-default-browser";
    };
  };

#+end_src

*** EWW
It's a simple text based web browser. I use it for short web searches & for finding youtube videos
#+NAME: Emacs Internet EWW
#+begin_src nix :noweb yes
  eww = {
    enable = true;
    custom = {
      eww-search-prefix = ''"https://search.inetol.net/?q="'';
      eww-header-line-format = "nil";
      eww-desktop-remove-duplicates = "t";
      eww-download-directory = ''(expand-file-name "~/dwn")'';
      eww-history-limit = "10";
      # External Browser
      eww-use-external-browser-for-content-type = ''"\\`\\(video/\\|audio\\)"''; # On GNU/Linux check your mimeapps.list
      eww-browse-url-new-windowis-tab = "nil";
      eww-form-checkbox-selected-symbol = ''"[X]"'';
      eww-form-checkbox-symbol = ''"[ ]"'';
      eww-auto-rename-buffer = "'title";
    };
    generalTwo."'normal".eww-mode-map = {
      "N" = "#'eww-back-url";
      "I" = "#'eww-forward-url";
      "P" = "#'eww-copy-page-url";
      "R" = "'eww-readable";
    };
    init = ''
      <<Emacs Internet Eww Config>>
    '';
  };
#+end_src

#+NAME: Emacs Internet Eww Config
#+begin_src emacs-lisp
  (with-eval-after-load 'evil-collection-eww
    (general-add-advice 'evil-collection-eww-setup
  		      :after
  		      '(lambda ()
  			 (general-def 'normal eww-mode-map
  			   "d" 'evil-yank
  			   "p" 'efs/mpv-eww-url))))
#+end_src

*** Yeetube
#+NAME: Emacs Internet Yeetube
#+begin_src nix
  yeetube = {
    enable = true;
    generalOne."efs/leader-keys"."y" = '''(yeetube-search :which-key "search")'';
    generalTwo."'normal"."yeetube-mode-map" = {
      "RET" = "'yeetube-play";
      "r" = "'yeetube-channel-videos";
      "s" = "'yeetube-channel-search";
    };
  };
#+end_src

*** Ement
Ement username: @holscherhead:matrix.org
Use S-SPC to load old messages
#+NAME: Emacs Internet Ement
#+begin_src nix :noweb yes
  ement = {
    enable = true;
    defer = true;
    generalOne = {
      "efs/leader-keys"."e" = '''(ement-connect :which-key "element")''; 
      local-leader."s" = '''(ement-sidebar :which-key "sidebar")'';
    };
    init = ''
      <<Emacs Internet Ement Init>>
    '';
  };
#+end_src

#+NAME: Emacs Internet Ement Init
#+begin_src emacs-lisp
  (defun ement-sidebar ()
    (interactive)
    (ement-room-list-side-window)
    (with-selected-window (get-buffer-window "*Ement Room List*")
      (gsetq window-size-fixed 'width)
      (window-resize (selected-window) (- 45 (window-total-width)) t t)))
#+end_src

*** Webjump
#+NAME: Emacs Internet Webjump
#+begin_src nix :noweb yes
  webjump = {
    enable = true;
    generalOne."efs/leader-keys"."s" = "'webjump";
    custom.webjump-sites = ''
      '(("DuckDuckGo" . [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
        ("Invidious" . [simple-query "inv.nadeko.net" "inv.nadeko.net/search?q=" ""])
        ("Aur" . [simple-query "aur.archlinux.org" "aur.archlinux.org/packages/?K=" ""])
        ("Nixpkgs" . [simple-query "search.nixos.org" "search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=" ""])
        ("Curseforge" . webjump-to-curseforge))
    '';
    config = ''
      <<Emacs Internet Webjump Config>>
    '';
  };
#+end_src

https://search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=vesktop
#+NAME: Emacs Internet Webjump Config
#+begin_src emacs-lisp
  (defun webjump-to-curseforge (name)
    (let* ((prefix "legacy.curseforge.com/minecraft/")
           (category (completing-read "Choose a category" '("mc-mods" "modpacks" "shaders" "data-pack" "texture-packs")))
  	 (url (concat prefix category))
  	 (term (webjump-read-string (concat name " Search for"))))
      (concat url "/search?search=" (webjump-url-encode term))))
#+end_src

*** Elfeed
#+NAME: Emacs Internet Elfeed
#+begin_src nix
  elfeed = {
    enable = true;
    defer = true;
    custom.elfeed-feeds = '''("https://lukesmith.xyz/index.xml"
                              "https://youtube.com/feeds/videos.xml?channel_id=UCSJPFQdZwrOutnmSFYtbstA"
                              "https://planet.emacslife.com/atom.xml"
                              "https://youtube.com/feeds/videos.xml?channel_id=UC_GQ4mac4oN3wl1UdbFuTEA"
                              "https://youtube.com/feeds/videos.xml?channel_id=UC6UBbvEA8uh6Ulc6ax1Zs0g"
                              "https://youtube.com/feeds/videos.xml?channel_id=UCNzZD3otfZVlIdvYYRRqNSw"
      		                    "https://youtube.com/feeds/videos.xml?channel_id=UC9OZkS1Mhl5UvKSiPrYqsxg"
      		                    "https://youtube.com/feeds/videos.xml?channel_id=UCgVLFBokgO85hyVl7tIoJvw"
                              "https://notrelated.xyz/rss")
      '';
    generalOne."efs/leader-keys"."r" = '''((lambda () (interactive) (elfeed) (elfeed-update)) :which-key "rss")'';
  };

#+end_src

*** Qutebrowser
https://greasyfork.org/en/scripts/374833-yt2invidio
#+NAME: Internet Qutebrowser
#+begin_src nix :noweb yes
  programs.qutebrowser = {
    enable = true;
    enableDefaultBindings = true;
    package = (config.lib.nixGL.wrap pkgs.qutebrowser);

    <<Internet Qutebrowser Keybinds>>

    <<Internet Qutebrowser Greasemonkey>>

    <<Internet Qutebrowser Aliases>>

    <<Internet Qutebrowser Search>>
    
    settings = {
      <<Internet Qutebrowser Privacy>>

      <<Internet Qutebrowser Dir>>

      <<Internet Qutebrowser Transparency>>

      <<Internet Qutebrowser File Selection>>

      <<Internet Qutebrowser Tabs>>

      <<Internet Qutebrowser Links>>

    };

    <<Internet Qutebrowser Extraconfig>>
  };

  <<Internet Qutebrowser Emacs Integration>>
#+end_src

**** Keybinds
https://redlib.northboot.xyz/r/qutebrowser/comments/eh10i7/config_share_qute_with_emacs_keybindings/
#+NAME:Internet Qutebrowser Keybinds
#+begin_src nix
  keyBindings = {
    normal = {
      "m" = "search-next";
      "M" = "search-prev";
      "e" = "fake-key <Down>";
      "o" = "fake-key <Up>";
      "O" = "scroll-page 0 -0.5";
      "E" = "scroll-page 0 0.5";
      "<ctrl-o>" = "scroll-page 0 -1";
      "<ctrl-e>" = "scroll-page 0 1";
      "t" = "mode-enter insert";
      "I" = "forward";
      "i" = "fake-key <Right>";
      "n" = "fake-key <Left>";
      "N" = "back";
      "k" = "hint links spawn mpv {hint-url}";
      "h" = "spawn --userscript emacsclient-wrapper '(qutebrowser-launcher)'";
      "H" = "spawn --userscript emacsclient-wrapper '(qutebrowser-launcher-tab)'";
      ";l" = "spawn --userscript qute-pass";
      ";u" = "spawn --userscript qute-pass --username-only";
      ";p" = "spawn --userscript qute-pass --password-only";
      ";o" = "spawn --userscript qute-pass --otp-only";
      ";P" = "spawn --userscript emacsclient-wrapper '(qutebrowser-pass \"{url}\")'";
      "a" = "cmd-set-text :";
      "<ctrl-f>" = "hint links spawn mpv {hint-url}";
    };
  };
#+end_src

**** Greasemonkey Scripts
#+NAME: Internet Qutebrowser Greasemonkey
#+begin_src nix :noweb yes
  greasemonkey = [
    (pkgs.fetchurl {
  		url = "https://raw.githubusercontent.com/afreakk/greasemonkeyscripts/1d1be041a65c251692ee082eda64d2637edf6444/youtube_sponsorblock.js";
  		sha256 = "sha256-e3QgDPa3AOpPyzwvVjPQyEsSUC9goisjBUDMxLwg8ZE=";
  	})
    (pkgs.fetchurl {
  		url = "https://raw.githubusercontent.com/afreakk/greasemonkeyscripts/refs/heads/master/youtube_adblock.js";
  		sha256 = "sha256-AyD9VoLJbKPfqmDEwFIEBMl//EIV/FYnZ1+ona+VU9c=";
  	})
  ];
#+end_src

**** Aliases
#+NAME: Internet Qutebrowser Aliases
#+begin_src nix
  aliases = {
          "q" = "quit";
          "w" = "session-save";
          "wq" = "quit --save";
        };
#+end_src

**** Autoconfig & Search Engines
#+NAME: Internet Qutebrowser Search
#+begin_src nix
  loadAutoconfig = false;
  searchEngines = {
    "DEFAULT" = "https://search.inetol.net/search?q={}";
  };
#+end_src

**** Some privacy Settings
#+NAME: Internet Qutebrowser Privacy
#+begin_src nix
  content = {
    blocking = {
      enabled = true;
      method = "both";
      adblock.lists = [
        "https://easylist.to/easylist/easylist.txt"
        "https://easylist.to/easylist/easyprivacy.txt"
        "https://easylist.to/easylist/fanboy-social.txt"
        "https://secure.fanboy.co.nz/fanboy-annoyance.txt"
        "https://easylist-downloads.adblockplus.org/abp-filters-anti-cv.txt"
        #"https://gitlab.com/curben/urlhaus-filter/-/raw/master/urlhaus-filter.txt"
        "https://pgl.yoyo.org/adservers/serverlist.php?showintro=0;hostformat=hosts"
        "https://raw.githubusercontent.com/DandelionSprout/adfilt/master/NorwegianExperimentalList%20alternate%20versions/NordicFiltersABP-Inclusion.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/legacy.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters-2020.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters-2021.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/badware.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/privacy.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/badlists.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/annoyances.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/resource-abuse.txt"
        "https://www.i-dont-care-about-cookies.eu/abp/"
        "https://secure.fanboy.co.nz/fanboy-cookiemonster.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/unbreak.txt"
        "https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/quick-fixes.txt"
      ];
    };
    autoplay = false;
    cookies.store = false;
    geolocation = false;
    private_browsing = true;
  };
  completion = {
    cmd_history_max_items = 0;
    web_history.max_items = 0;
  };
#+end_src

**** Download Dir & Startpage
#+NAME: Internet Qutebrowser Dir
#+begin_src nix
  downloads.location.directory = "~/dwn";
  url = {
    default_page = "https://search.inetol.net";
    start_pages = "https://search.inetol.net";
  };
#+end_src

**** Transparency
This is a very ugly way of doing things
#+NAME: Internet Qutebrowser Transparency
#+begin_src nix
  window.transparent = true;
  colors = {
    completion = {
      category = {
        bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
        border = {
          bottom = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
          top = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
        };
      };
      even.bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
      odd.bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
    };
    statusbar = {
      command = {
        bg = lib.mkForce ("#50" + config.lib.stylix.colors.base00);
        private.bg = lib.mkForce ("#50" + config.lib.stylix.colors.base00);
      };
    };
  };
#+end_src

**** File Selection
#+NAME: Internet Qutebrowser File Selection
#+begin_src nix
  fileselect = {
    handler = "external";
    single_file.command = [
      "emacsclient"
      "{}"
    ];
    folder.command = [
      "emacsclient"
      "{}"
    ];
    multiple_files.command = [
      "emacsclient"
      "{}"
    ];
  };
#+end_src

**** WM Related
#+NAME: Internet Qutebrowser Tabs
#+begin_src nix
  tabs = {
    tabs_are_windows = true;
    show = "never";
  };

  window.title_format = "{current_title}";
  new_instance_open_target = "tab-silent";
  statusbar.show = "never";
#+end_src

**** Link Hints
#+NAME: Internet Qutebrowser Links
#+begin_src nix
  hints.chars = "crstbfneia";
#+end_src

**** Extra Config
#+NAME: Qutebrowser Config
#+begin_src python-ts
  config.set('content.cookies.accept', 'no-3rdparty', 'chrome-devtools://*')
  config.set('content.cookies.accept', 'no-3rdparty', 'devtools://*')

  config.set('content.images', True, 'chrome-devtools://*')
  config.set('content.images', True, 'devtools://*')

  config.set('content.javascript.enabled', True, 'chrome-devtools://*')
  config.set('content.javascript.enabled', True, 'devtools://*')
  config.set('content.javascript.enabled', True, 'chrome://*/*')
  config.set('content.javascript.enabled', True, 'qute://*/*')

  config.set('content.notifications.enabled', False, 'https://www.reddit.com')
  config.set('content.notifications.enabled', False, 'https://www.youtube.com')

  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}) AppleWebKit/{webkit_version} (KHTML, like Gecko) {upstream_browser_key}/{upstream_browser_version} Safari/{webkit_version}', 'https://web.whatsapp.com/')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://accounts.google.com/*')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info} rv:110.0) Gecko/20100101 Firefox/119.0', 'https://*.slack.com/*')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://docs.google.com/*')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://drive.google.com/*')

  c.editor.command = ['emacsclient', '{file}']

  c.fonts.default_family = '"Source Code Pro"'
  c.fonts.default_size = '8pt'
  c.fonts.completion.entry = '8pt "Source Code Pro"'
  c.fonts.debug_console = '8pt "Source Code Pro"'
  c.fonts.prompts = 'default_size sans-serif'
#+end_src

#+NAME: Internet Qutebrowser Extraconfig
#+begin_src nix :noweb yes
      extraConfig = ''
        <<Qutebrowser Config>>
      '';
#+end_src

**** Emacs Integration
#+NAME: Internet Qutebrowser Emacs Integration
#+begin_src nix :noweb yes
  programs.emacs.init.usePackage = {
    qutebrowser = {
      enable = true;
      package = epkgs: (epkgs.callPackage ./emacs/emacs-packages/qutebrowser.nix {
        inherit inputs;
        inherit (epkgs) trivialBuild dash consult exwm password-store evil;
      });
      ghook = [
        "('exwm-init-hook 'global-qutebrowser-exwm-mode)"
      ];
      gfhook = [
        "('server-visit-hook 'qute/dired-hook)"
        "('qutebrowser-exwm-mode-hook 'evil-normal-state)"
      ];
      config = ''
      <<Emacs Internet Qutebrowser Config>>
    '';
    };
    qutebrowser-evil = {
      enable = true;
      package = epkgs: (epkgs.callPackage ./emacs/emacs-packages/qutebrowser.nix {
        inherit inputs;
        inherit (epkgs) trivialBuild dash consult exwm password-store evil;
      });
      ghook = [
        "('global-qutebrowser-exwm-mode-hook 'qutebrowser-evil-state-mode)"
      ];
    };
  };
#+end_src

#+NAME: Emacs Internet Qutebrowser Config
#+begin_src emacs-lisp
  (define-minor-mode qute-dired-mode
    "Used for dired buffers qutebrowser is using as a file picker"
    :keymap '())

  (general-def qute-dired-mode-map
          "C-c C-c" #'qute/choose-file)

  (general-def 'normal qute-dired-mode-map
    "i" 'dired-find-file
    "n" 'dired-up-directory)

  (defun qute/choose-file ()
    (interactive)
    (let ((files (dired-get-marked-files)))
      (with-temp-file qute-filename
        (insert (s-join "\n" files)))
      (remove-hook 'dired-mode-hook 'qute-dired-mode)
      (dolist (buffer dired-buffers) (when qute-dired-mode (kill-buffer (cdr buffer))))))

  (defun qute/dired-hook (&optional _)
    (when (s-starts-with? "/tmp/qutebrowser-fileselect" buffer-file-name)
      (setq qute-filename buffer-file-name)
      (kill-buffer)
      (add-hook 'dired-mode-hook 'qute-dired-mode)
      (setq qute-dired-buffers (list (dired "~/")))))
#+end_src

***** Package Definition
#+begin_src nix :tangle emacs/emacs-packages/qutebrowser.nix
  { trivialBuild, inputs, consult, exwm, password-store, dash, evil, doom-modeline } :

  trivialBuild rec {
    pname = "qutebrowser";
    version = "current";
    src = inputs.exwm-qutebrowser;

    propagatedUserEnvPkgs = [
      consult
      exwm
      password-store
      dash
      evil
      doom-modeline
    ];

    buildInputs = propagatedUserEnvPkgs;
  }
#+end_src

** Keyboard
I use kmonad to manage my keybinds.
Canary is my layout of choice.
#+begin_src nix :tangle keyboard.nix
  { ... }:

  {
    home.file.".config/kmonad/kmonad.kbd".text = ''
    ;; ** For Linux **
    (defcfg
    input  (device-file "/dev/input/by-path/platform-i8042-serio-0-event-kbd") ;; Change this line for your device
    output (uinput-sink "KMonad output")

    fallthrough true)

    (defsrc
      esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
      grv     1    2    3    4    5    6    7    8    9    0    -    =    bspc      ins     home    pgup
      tab     q    w    e    r    t    y    u    i    o    p    [    ]    \         del     end     pgdn
      caps    a    s    d    f    g    h    j    k    l    ;    '    ret
      lsft    z    x    c    v    b    n    m    ,    .    /    rsft                         up
      lctl    lmet lalt           spc            ralt    rctl                       left    down    right)

    (defalias
      def  (tap-macro nlck (layer-switch canary)) ;; Bind 'def' to canary Layer
      caps  (tap-macro nlck (layer-switch canary-shift)) ;; Bind 'def' to canary Layer
      cesc (tap-hold 200 esc (layer-toggle extend))
      sesc (tap-hold 200 S-esc (layer-toggle extend))
      num (sticky-key 500 (layer-toggle num))
      qwerty (tap-macro nlck (layer-switch qwerty)) ;; Bind 'def' to canary Layer
      smet (sticky-key 500 lmet)
      salt (sticky-key 500 lalt)
      sshft (sticky-key 500 lshft)
      spc (tap-hold 200 spc caps)
      SPC (tap-hold 200 S-spc caps)
      c (tap-hold 200 c lmet)
      r (tap-hold 200 r lalt)
      s (tap-hold 200 s lctl)
      t (tap-hold 200 t (layer-toggle canary-shift))
      a (tap-hold 200 a lmet)
      i (tap-hold 200 i lalt)
      e (tap-hold 200 e lctl)
      n (tap-hold 200 n (layer-toggle canary-shift))
      C (tap-hold 200 C lmet)
      R (tap-hold 200 R lalt)
      S (tap-hold 200 S lctl)
      A (tap-hold 200 A lmet)
      I (tap-hold 200 I lalt)
      E (tap-hold 200 E lctl)
      wlft C-left
      wrht C-right
      bhst A-left
      fhst A-right)
    (deflayer canary
      esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
      $       &    [    {    }    \(   =    *    \)   +    ]    !    `    bspc      ins     home    pgup
      tab     w    l    y    p    k    z    x    o    u    ;    -    @    \         del     end     pgdn
      @cesc   @c   @r   @s   @t   b    f    @n   @e   @i   @a   '    ret
      shft   j    v    d    g    q    m    h    /    ,    .    @sshft                      up
      caps   @smet @num           @spc             caps     rctl                    left    down    right)

    (deflayer canary-shift
      S-esc   S-f1 S-f2 S-f3 S-f4 S-f5 S-f6 S-f7 S-f8 S-f9 S-f10 S-f11 S-f12        S-prnt  S-slck  S-pause
      ~       %    7    5    3    1    9    0    2    4    6    8    #  S-bspc      S-ins   S-home  S-pgup
      S-tab   W    L    Y    P    K    Z    X    O    U    :    \_   ^    S-\        S-del   S-end   S-pgdn
      @sesc   @C   @R   @S   T    B    F    N   @E   @I   @A    "    S-ret
      @sshft   J    V    D    G    Q    M    H    ?    <    >    @sshft                     S-up
      caps   @smet @def           @SPC             caps    rctl                   S-left S-down S-right)

    (deflayer qwerty
      esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
      grv     1    2    3    4    5    6    7    8    9    0    -    =    bspc      ins     home    pgup
      tab     q    w    e    r    t    y    u    i    o    p    [    ]    \         del     end     pgdn
      caps    a    s    d    f    g    h    j    k    l    ;    '    ret
      lsft    z    x    c    v    b    n    m    ,    .    /    rsft                         up
      lctl    lmet lalt           spc            @def     rctl                     left    down    right)

    (deflayer extend
      _       _    _    _    _    _    _    _    _    _    _    _    _              _    _    _
      _     f11    f7   f5   f3   f1   f9  f10   f2   f4   f6   f8  f12   _         _    _    _
      _   @bhst @fhst  C-z  C-x   C-c  C-z @wlft up  @wrht  _    _    _    _         _    _    _
      _   @smet @salt lctl @sshft del bspc left down right _    _    _
      _         _    _  @caps    _    _    _    h    _    _    _    _                      _
      _       _    _               ret              @qwerty        _                     _    _    _)

    (deflayer num
      _       _    _    _    _    _    _    _    _    _    _    _    _              _    _    _
      _     f11    f7   f5   f3   f1   f9  f10   f2   f4   f6   f8  f12   _         _    _    _
      _       \_    =    +    -    [    ]    7    8    9   &    ^    _    _         _    _    _
      _   @smet @salt lctl @sshft  {    }    4    5    6   0    *    _
      _        @    !    $     \(  ~  \)    1    2    3    #    _                      _
      _       _    _               ret              _        _                     _    _    _)
        
    '';
  }
#+end_src

