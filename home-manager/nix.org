#+title: Holscher's Home Manager Config
#+startup: overview
#+auto_tangle: t
* Flake
#+begin_src nix :noweb yes :tangle flake.nix
  {
    description = "Nixos config flake";

    inputs = {
      <<Flake Inputs>>
    };

    outputs = { self, home-manager, nixgl, nixpkgs, nixpkgs-stable, stylix, emacs-init, ... }@inputs:
      let
        <<Flake Repo Definitions>>
      in
        {
          gpuWrappers = nixgl.defaultPackage;
          # gpuWrappers = nixgl.nixGLNvidia;
          homeConfigurations."holschcc" = home-manager.lib.homeManagerConfiguration {
            <<Flake Home Manager Definition>>
          } ;
        };
  }

#+end_src

** Inputs
#+NAME: Flake Inputs
#+begin_src nix
nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
nixpkgs-stable.url = "github:nixos/nixpkgs/nixos-24.11";
emacs-overlay.url  = "github:nix-community/emacs-overlay";

stylix.url = "github:danth/stylix";

apple-fonts.url = "github:Lyndeno/apple-fonts.nix";

emacs-init.url = "github:firefoxsalesman/NixEmacs";

home-manager = {
  url = "github:nix-community/home-manager";
  inputs.nixpkgs.follows = "nixpkgs";
};

nixgl = {
  url = "github:nix-community/nixGL"; 
  inputs.nixpkgs.follows = "nixpkgs";
};

kmonad = {
  url = "github:kmonad/kmonad?submodules=1&dir=nix";
  inputs.nixpkgs.follows = "nixpkgs";
};

# packages
gptel-quick = {
  url = "github:karthink/gptel-quick";
  flake = false;
};

repeaters = {
  url = "github:mmarshall540/repeaters";
  flake = false;
};

app-launcher = {
  url = "github:SebastienWae/app-launcher";
  flake = false;
};

emacs-embark = {
  url = "github:oantolin/embark";
  flake = false;
};

dired-single = {
  url = "github:firefoxsalesman/dired-single";
  flake = false;
};

ezf = {
  url = "github:firefoxsalesman/ezf";
  flake = false;
};

doom-nano-modeline = {
  url = "github:ronisbr/doom-nano-modeline";
  flake = false;
};

treesitter-context = {
  url = "github:zbelial/treesitter-context.el";
  flake = false;
};

org-modern-indent = {
  url = "github:alphapapa/org-modern-indent";
  flake = false;
};

org-novelist = {
  url = "github:sympodius/org-novelist";
  flake = false;
};

mpc-wrapper = {
  url = "github:FirefoxSalesman/mpc-wrapper";
  flake = false;
};

exwm-outer-gaps = {
  url = "github:firefoxsalesman/exwm-outer-gaps";
  flake = false;
};

exwm-qutebrowser = {
  url = "github:lrustand/qutebrowser.el/18f98f0";
  flake = false;
};
#+end_src

** Outputs
*** Repo Definitions
#+NAME: Flake Repo Definitions
#+begin_src nix
  system = "x86_64-linux";

  pkgs = import nixpkgs {
    inherit system;
    config.allowUnfree = true;
    overlays = [
      (final: prev: import ./overlay.nix final prev pkgs inputs)
      inputs.emacs-init.overlay
      inputs.emacs-overlay.overlay
    ];
  };
  pkgs-stable = import nixpkgs-stable {
    inherit system;
    config.allowUnfree = true;
  };
#+end_src

*** Home Manager Definition
#+NAME: Flake Home Manager Definition
#+begin_src nix
  inherit pkgs;
  extraSpecialArgs = {
    inherit self;
    inherit inputs;
    inherit system;
    inherit (inputs)  apple-fonts doom-utils repeaters ezf dired-single launcher doom-nano-modeline symex2 treesitter-context gptel-quick org-modern-indent org-novelist mpc-wrapper exwm-qutebrowser exwm-outer-gaps;
    inherit pkgs-stable;
  };
  modules = [
    ./home.nix
    stylix.homeModules.stylix
    emacs-init.homeModules.emacs-init
    emacs-init.homeModules.emacs-presets
  ];
#+end_src

* Overlay
#+begin_src nix :tangle overlay.nix
  final: prev: pkgs: inputs: {
    # shell scripts
    ezf = (import ./scripts/ezf.nix { inherit pkgs; });
    cast = (import ./scripts/cast.nix { inherit pkgs; });
    doomer = (import ./scripts/doomer.nix { inherit pkgs; });
    ffmpeg-bulk = (import ./scripts/ffmpeg-bulk.nix { inherit pkgs; });
    masstube = (import ./scripts/masstube.nix { inherit pkgs; });
    pkg = (import ./scripts/pkg.nix { inherit pkgs; });
    udisksmenu = (import ./scripts/udisksmenu.nix { inherit pkgs; });
    wiki = (import ./scripts/wiki.nix { inherit pkgs; });

    # overrides
    vesktop = (prev.vesktop.override {withSystemVencord = true;});
    mpv = (prev.mpv.override {
      scripts = with prev.mpvScripts; [
        thumbnail
        sponsorblock
      ];
    });

    #emacs packages
    emacsPackagesFor = emacs: (
      (prev.emacsPackagesFor emacs).overrideScope (
        nfinal: nprev: {
          qutebrowser = (prev.emacsPackages.callPackage ./packages/emacs/qutebrowser.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild dash consult exwm password-store evil;
          });
          doom-nano-modeline = (prev.emacsPackages.callPackage ./packages/emacs/doom-nano-modeline.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild doom-themes;
          });
          treesitter-context = (prev.emacsPackages.callPackage ./packages/emacs/treesitter-context.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild posframe;
          });
          dired-single = (prev.emacsPackages.callPackage ./packages/emacs/dired-single.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild;
          });
          repeaters = (prev.emacsPackages.callPackage ./packages/emacs/repeaters.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild;
          });
          app-launcher = (prev.emacsPackages.callPackage ./packages/emacs/app-launcher.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild;
          });
          ezf = (prev.emacsPackages.callPackage ./packages/emacs/ezf.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild;
          });
          org-modern-indent = (prev.emacsPackages.callPackage ./packages/emacs/org-modern-indent.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild compat;
          });
          org-novelist = (prev.emacsPackages.callPackage ./packages/emacs/org-novelist.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild org;
          });
          exwm-outer-gaps = (prev.emacsPackages.callPackage ./packages/emacs/exwm-outer-gaps.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild exwm xelb;
          });
          gptel-quick = (prev.emacsPackages.callPackage ./packages/emacs/gptel-quick.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild gptel;
          });
          mpc-wrapper = (prev.emacsPackages.callPackage ./packages/emacs/mpc-wrapper.nix {
            inherit inputs;
            inherit (prev.emacsPackages) trivialBuild;
          });
          embark = prev.emacsPackages.callPackage (
            {
              org,
              consult,
              avy,
              compat,
              elpaBuild,
              fetchurl,
              lib,
            }:
            elpaBuild {
              pname = "embark";
              ename = "embark";
              version = "1.1";
              src = fetchurl {
                url = "https://elpa.gnu.org/packages/embark-1.1.tar";
                sha256 = "074ggh7dkr5jdkwcndl6znhkq48jmc62rp7mc6vjidr6yxf8d1rn";
              };
              packageRequires = [
                org
                consult
                avy
                compat
              ];
              meta = {
                homepage = "https://elpa.gnu.org/packages/embark.html";
                license = lib.licenses.free;
              };
            }
          ) { };
        }));
  }
#+end_src

* Packages
** Emacs
*** Doom Nano Modeline
#+begin_src nix :tangle packages/emacs/doom-nano-modeline.nix
  { inputs, trivialBuild, doom-themes } :

  trivialBuild rec {
    pname = "doom-nano-modeline";
    version = "current";
    src = inputs.doom-nano-modeline;

    propagatedUserEnvPkgs = [
      doom-themes
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

*** Treesitter Context
#+begin_src nix :tangle packages/emacs/treesitter-context.nix
  { inputs, trivialBuild, posframe } :

  trivialBuild rec {
    pname = "treesitter-context";
    version = "current";
    src = inputs.treesitter-context;

    propagatedUserEnvPkgs = [
      posframe
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

*** Dired Single
#+begin_src nix :tangle packages/emacs/dired-single.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "dired-single";
    version = "current";
    src = inputs.dired-single;
  }
#+end_src
*** Repeaters
#+begin_src nix :tangle packages/emacs/repeaters.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "repeaters";
    version = "current";
    src = inputs.repeaters;
  }
#+end_src

*** App Launcher
#+begin_src nix :tangle packages/emacs/app-launcher.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "app-launcher";
    version = "current";
    src = inputs.app-launcher;
  }

#+end_src

*** Ezf
#+begin_src nix :tangle packages/emacs/ezf.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "ezf";
    version = "current";
    src = inputs.ezf;
  }
#+end_src

*** Org Modern Indent
#+begin_src nix :tangle packages/emacs/org-modern-indent.nix
  { inputs, trivialBuild, compat } :

  trivialBuild rec {
    pname = "org-modern-indent";
    version = "current";
    src = inputs.org-modern-indent;

    propagatedUserEnvPkgs = [
      compat
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

*** Org Novelist
#+begin_src nix :tangle packages/emacs/org-novelist.nix
  { inputs, trivialBuild, org }:

  trivialBuild rec {
    pname = "org-novelist";
    version = "current";
    src = inputs.org-novelist;

    propogatedUserEnvPkgs = [
      org
    ];

    buildInputs = propogatedUserEnvPkgs;
  }
#+end_src

*** EXWM Outer Gaps
#+begin_src nix :tangle packages/emacs/exwm-outer-gaps.nix
  { inputs, trivialBuild, xelb, exwm } :

  trivialBuild rec {
    pname = "exwm-outer-gaps";
    version = "current";
    src = inputs.exwm-outer-gaps;

    propagatedUserEnvPkgs = [
      xelb
      exwm
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

*** GPT.el
#+begin_src nix :tangle packages/emacs/gptel-quick.nix
  { inputs, trivialBuild, gptel } :

  trivialBuild rec {
    pname = "gptel-quick";
    version = "current";
    src = inputs.gptel-quick;

    propagatedUserEnvPkgs = [
      gptel
    ];

    buildInputs = propagatedUserEnvPkgs;
  }

#+end_src

*** MPC Wrapper
#+begin_src nix :tangle packages/emacs/mpc-wrapper.nix
  { trivialBuild, inputs } :

  trivialBuild rec {
    pname = "mpc-wrapper";
    version = "current";
    src = inputs.mpc-wrapper;
  }
#+end_src

*** Qutebrowser
#+begin_src nix :tangle packages/emacs/qutebrowser.nix
  { trivialBuild, inputs, consult, exwm, password-store, dash, evil, doom-modeline } :

  trivialBuild rec {
    pname = "qutebrowser";
    version = "current";
    src = inputs.exwm-qutebrowser;

    propagatedUserEnvPkgs = [
      consult
      exwm
      password-store
      dash
      evil
      doom-modeline
    ];

    buildInputs = propagatedUserEnvPkgs;
  }
#+end_src

* Notes to my future self
+ To get eduroam working, you need ppp & pptclient
+ Don't let xorg use the nvidia card. It breaks everything

* Scripts
** Cast
:PROPERTIES:
:header-args:nix: :tangle scripts/cast.nix
:END:
For moving massive quantities of Jordan Peterson's podcast into my mp3 player
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "cast" ''
    #Exit on fail
    set -e

    #Set Input & Output Filetypes
    in=$(${pkgs.coreutils}/bin/printf 'm4a\nopus\nmp4\nmkv\nwebm' | ${pkgs.ezf}/bin/ezf)
    out=$(${pkgs.coreutils}/bin/printf 'mp3\nflac\nwav\nogg' | ${pkgs.ezf}/bin/ezf)

    #Choose device to transfer to
    device=$(${pkgs.coreutils}/bin/ls /run/media/$USER | ${pkgs.ezf}/bin/ezf)

    #Convert files
    ${pkgs.ffmpeg-bulk}/bin/ffmpeg-bulk *.$in -t $out
    ${pkgs.coreutils}/bin/rm *.$in

    #Remove metadata so the glowies don't see it.
    ${pkgs.python312Packages.mat2}/bin/mat2 *.$out

    #Transfer
    ${pkgs.coreutils}/bin/mv ~/*.cleaned.$out /run/media/$USER/$device/Podcasts
    ${pkgs.coreutils}/bin/rm ~/*.$out
  ''
#+end_src

** Doomer
:PROPERTIES:
:header-args:nix: :tangle scripts/doomer.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "doomer" ''
  ${pkgs.sox}/bin/sox "$1" "$1.flac" pitch -500 treble -20 pad 0 3 reverb 80 tempo .8 highpass 1000 lowpass 700 compand 0.3,0.8 0
  ''
#+end_src

** Ezf
:PROPERTIES:
:header-args:nix: :tangle scripts/ezf.nix
:END:
Borrowed from here: https://github.com/mickeynp/ezf
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "ezf" ''
  set -o nounset -o errexit -o pipefail

  field=0-
  # the elisp function to use for completing read
  candidate_fn=ezf-default
  while getopts c:f: OPT; do
      case $OPT in
          c)
              candidate_fn=$OPTARG
              ;;
          f)
              field=$OPTARG
              ;;
          ,*)
              ${pkgs.coreutils}/bin/echo "usage: ezf [-f field] [-c candidate-fn]"
              exit 2
      esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1

  ezftmp="$(mktemp)"
  trap 'rm -f -- "$ezftmp"' EXIT
  > "$ezftmp" cat -
  # xargs is there to strip the "" from the beginning and end of the
  # output from Emacs.  Ensure "field" is always passed as a string by
  # quoting it.
  selection=$(emacsclient -e "(progn (require 'ezf) (ezf \"$ezftmp\" \"$field\" #'$candidate_fn))" | xargs)
  if [[ "$selection" == "nil" ]]; then
      exit 1
  else
     ${pkgs.coreutils}/bin/echo "$selection"
  fi

  ''
#+end_src

** Ffmpeg-bulk
:PROPERTIES:
:header-args:nix: :tangle scripts/ffmpeg-bulk.nix
:END:
I stole this from this git repo https://github.com/sylsau/ffmpeg-bulk
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "ffmpeg-bulk" ''
  #!/bin/bash - 
  #===============================================================================
  #
  #		  USAGE: ./this.sh --help
  # 
  #	DESCRIPTION: Create a ffmpeg conversion script from a list of input files.
  # 
  #		OPTIONS: ---
  #  REQUIREMENTS: sed, gawk, ffmpeg, tee
  #		   BUGS: ---
  #		  NOTES: ---
  #		 AUTHOR: Sylvain Saubier (ResponSyS), mail@sylsau.com
  #		CREATED: 01/05/16 14:09
  #===============================================================================

  [[ $DEBUG ]] && set -o nounset
  set -o pipefail -o errexit -o errtrace
  trap 'echo -e "''${FMT_BOLD}ERROR''${FMT_OFF}: at $FUNCNAME:$LINENO"' ERR

  readonly FMT_BOLD='\e[1m'
  readonly FMT_UNDERL='\e[4m'
  readonly FMT_OFF='\e[0m'

  readonly PROGRAM_NAME="''${0##*/}"
  readonly SCRIPT_NAME="''${0##*/}"
  RES="$( stat -c %y $0 | cut -d" " -f1 )"
  readonly VERSION=''${RES//-/}

  readonly ERR_NO_CMD=60

  FFMPEG="''${FFMPEG:-ffmpeg}"
  OPT_EXT=
  OPT_ARGS_IN=
  OPT_ARGS_OUT=
  OPT_FORCE=
  OPT_LOGLEVEL="-loglevel error"
  INPUT=( )


  # $1 = command to test (string)
  fn_need_cmd() {
          if ! command -v "$1" > /dev/null 2>&1
                  then fn_err "need '$1' (command not found)" $ERR_NO_CMD
          fi
  }
  # $1 = message (string)
  m_say() {
          echo -e "$PROGRAM_NAME: $1"
  }
  # $1 = error message (string), $2 = return code (int)
  fn_err() {
          m_say "''${FMT_BOLD}ERROR''${FMT_OFF}: $1" >&2
          exit $2
  }

  fn_help() {
          cat << EOF
  $PROGRAM_NAME v$VERSION
          Convert multiple media files at once with ffmpeg.
          In pure and secure bash.
  REQUIREMENTS
          ffmpeg
  USAGE
          $PROGRAM_NAME FILES... (--to|-t) EXTENSION [--args-in|-ai INPUT_ARGS] [--args-out|-ao OUTPUT_ARGS] [--force|-f] [--log-level LOG_LEVEL]
  OPTIONS AND ARGUMENTS
          EXTENSION 		format of output files
          INPUT_ARGS 		ffmpeg arguments for the input file
          OUTPUT_ARGS		ffmpeg arguments for the output file
          --force			overwrite files 
          LOG_LEVEL		change ffmpeg '-loglevel'
                                  (default: 'error', ffmpeg default: 'info')
  EXAMPLE
          Convert all flac and wav files in the current directory to opus with the specified options:
                  $ $PROGRAM_NAME *.flac -t opus --args-out "-b:a 320k" *.wav
  SEE ALSO
          ffmpeg(1)
  AUTHOR
          Written by Sylvain Saubier
  REPORTING BUGS
          Mail at: <feedback@sylsau.com>
  EOF
  }

  fn_show_params() {
          m_say "\n input=''${INPUT[*]}\n -t=$OPT_EXT\n -ai=$OPT_ARGS_IN\n -ao=$OPT_ARGS_OUT\n -f=$OPT_FORCE\n -q=$OPT_LOGLEVEL" >&2
  }


  fn_need_cmd "$FFMPEG"

  # Check args
  if [[ -z "$@" ]]; then
          fn_help
          exit
  else
          while [[ $# -gt 0 ]]; do
                  case "$1" in
                          "--help"|"-h")
                                  fn_help
                                  exit
                                  ;;
                          "--to"|"-t")
                                  OPT_EXT=$2
                                  shift
                                  ;;
                          "--args-in"|"-ai")
                                  OPT_ARGS_IN=$2
                                  shift
                                  ;;
                          "--args-out"|"-ao")
                                  OPT_ARGS_OUT=$2
                                  shift
                                  ;;
                          "--force"|"-f")
                                  OPT_FORCE="-y"
                                  ;;
                          "--log-level")
                                  OPT_LOGLEVEL="-loglevel $2"
                                  shift
                                  ;;
                          ,*)
                                  [[ -e "$1" ]] || fn_err "file '$1' does not exist" 127
                                  INPUT+=( "$1" )
                                  ;;
                  esac	# --- end of case ---
                  shift 	# delete $1
          done
  fi

  [[ $DEBUG ]] && fn_show_params

  [[ $OPT_EXT ]] || fn_err "please specify the output extension with -t EXT" 2

  # Rajoute un point à l'extension si absent
  if [[ ''${OPT_EXT:0:1} != '.' ]]; then
          OPT_EXT=.$OPT_EXT
  fi

  m_say "converting...\n---"
  for F in "''${INPUT[@]}"; do # Just show the commands
          ${pkgs.coreutils}/bin/echo $FFMPEG $OPT_ARGS_IN -i "$F" $OPT_ARGS_OUT $OPT_FORCE $OPT_LOGLEVEL "''${F%.*}$OPT_EXT"
  done ;  ${pkgs.coreutils}/bin/echo "---" ; [[ $DEBUG ]] && exit
  for F in "''${INPUT[@]}"; do # Actually execute
          m_say "converting \"$F\"..."
               $FFMPEG $OPT_ARGS_IN -i "$F" $OPT_ARGS_OUT $OPT_FORCE $OPT_LOGLEVEL "''${F%.*}$OPT_EXT"
  done

  exit
  ''
#+end_src

** Masstube
:PROPERTIES:
:header-args:nix: :tangle scripts/masstube.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "masstube" ''
    emacsclient ~/.download.txt
    # ${pkgs.yt-dlp}/bin/yt-dlp $1 --verbose -ci --batch-file=~/.download.txt --proxy socks://localhost:9050
    ${pkgs.yt-dlp}/bin/yt-dlp $1 --verbose -ci --batch-file=~/.download.txt 
    ${pkgs.coreutils}/bin/rm ~/.download.txt
  ''
#+end_src

** Start-ollama
:PROPERTIES:
:header-args:nix: :tangle scripts/start-ollama.nix
:END:
#+begin_src nix
  { config, pkgs }:

  pkgs.writeShellScriptBin "start-ollama" ''
    if [[ "$(pidof ollama)" -gt 0 ]]; then
        echo "ollama already running"
    else
        ${(config.lib.nixGL.wrap pkgs.ollama)}/bin/ollama serve
    fi
  ''
#+end_src

** Pkg
:PROPERTIES:
:header-args:nix: :tangle scripts/pkg.nix
:END:
A package manager manager

Dev templates: https://github.com/the-nix-way/dev-templates
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "pkg" ''
    optimize() {
      nix-collect-garbage -d
      nix-store --optimise
      doas pacman -Sc --noconfirm
    }

    update() {
      nix flake update --flake ~/.config/home-manager/
      home-manager switch --flake ~/.config/home-manager/#holschcc
      doas nix flake update --flake /etc/system-manager/
      doas nix run 'github:numtide/system-manager' -- switch --flake '/etc/system-manager/'
      yay -Syu
    }

    help() {
      ${pkgs.coreutils}/bin/echo "help: display this message"
      ${pkgs.coreutils}/bin/echo "install [packages]: install packages with yay"
      ${pkgs.coreutils}/bin/echo "optimize: clean up package cache"
      ${pkgs.coreutils}/bin/echo "update: update all packages"
      ${pkgs.coreutils}/bin/echo "add: install a package"
      ${pkgs.coreutils}/bin/echo "rm: uninstall a package"
      ${pkgs.coreutils}/bin/echo "flake: perform a nix flake operation"
      ${pkgs.coreutils}/bin/echo "template: set up a devshell template"
      ${pkgs.coreutils}/bin/echo "tmp: temporarily install a package"
    }

    getTemplates() {
      ${pkgs.coreutils}/bin/printf "bun\nc-cpp\nclojure\ncsharp\ncue\ndhall\nelixir\nelm\nempty\ngleam\ngo\nhashi\nhaskell\nhaxe\njava\njupyter\nkotlin\nlatex\nnickel\nnim\nnix\nnode\nocaml\nopa\nphp\nplatformio\nprotobuf\npulumi\npurescript\npython\nr\nruby\nrust\nrust-toolchain\nscala\nshell\nswi-prolog\nswift\nvlang\nzig" | ${pkgs.ezf}/bin/ezf
    }

    template() {
      nix flake init --template "https://flakehub.com/f/the-nix-way/dev-templates/*#$(getTemplates)" 
      ${pkgs.direnv}/bin/direnv allow
    }

    case "$1" in
      optimize ) optimize ;;
      update ) update ;;
      add ) yay -S ''${@:2} ;;
      rm ) yay -Rs ''${@:2} ;;
      flake ) nix flake ''${@:2} ;;
      tmp ) nix-shell -p ''${@:2};;
      template ) template;;
      help ) help ;;
    esac
  ''
#+end_src
** i3status-rust
:PROPERTIES:
:header-args:nix: :tangle scripts/i3status-rust.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "i3status-rust" ''
  ${pkgs.i3status-rust}/bin/i3status-rs config-default.toml
  ''
#+end_src

** Udisksmenu
:PROPERTIES:
:header-args:nix: :tangle scripts/udisksmenu.nix
:END:
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "udisksmenu" ''
  action=$(${pkgs.coreutils}/bin/printf 'mount\nunmount' | ${pkgs.ezf}/bin/ezf)
  disk=$(${pkgs.coreutils}/bin/ls /dev | ${pkgs.ripgrep}/bin/rg sd[a-z] | ${pkgs.ezf}/bin/ezf)

  ${pkgs.udisks}/bin/udisksctl $action -b /dev/$disk
  ''
#+end_src

** Wiki
:PROPERTIES:
:header-args:nix: :tangle scripts/wiki.nix
:END:
Requires arch-wiki-docs to be installed

Stole it from Derek Taylor
#+begin_src nix
  { pkgs }:

  pkgs.writeShellScriptBin "wiki" ''
  dir="/usr/share/doc/arch-wiki/html/en/"
  doc="$(${pkgs.findutils}/bin/find $dir -iname "*.html" | \
         ${pkgs.coreutils}/bin/cut -d '/' -f8- | \
  ${pkgs.ezf}/bin/ezf)"

  if [ "''${dir}$doc" ]; then
      emacsclient -e "(eww-open-file \"''${dir}$doc\")"
  else
      ${pkgs.coreutils}/bin/echo "Program terminated." && exit 0
  fi
  ''
#+end_src

* Home Manager
** Main Config
*** Inputs & Imports
#+begin_src nix :noweb yes :tangle home.nix
  { lib, config, inputs, ... }:

  {
    # This is some text
    # Home Manager needs a bit of information about you and the paths it should
    # manage.
    home.username = "holschcc";
    home.homeDirectory = "/home/holschcc";

    # This value determines the Home Manager release that your configuration is
    # compatible with. This helps avoid breakage when a new Home Manager release
    # introduces backwards incompatible changes.
    #
    # You should not change this value, even if you update Home Manager. If you do
    # want to update the value, then make sure to first check the Home Manager
    # release notes.
    home.stateVersion = "23.05"; # Please read the comment before changing.

    # Let Home Manager install and manage itself.
    programs.home-manager.enable = true;

    imports =
      [ # Include the results of the hardware scan.
        ./internet.nix
        ./multimedia.nix
        ./aesthetics.nix
        ./extra-packages.nix
        ./development.nix
        ./gui.nix
        ./emacs.nix
        ./shells.nix
        ./gptel.nix
        ./sage.nix
        ./keyboard.nix
      ];

    nix.nixPath = [ "nixpkgs=${inputs.nixpkgs}" ];

    <<glx>>

    <<GPG>>

    <<alsoftrc>>

    <<Environment Variables>>

    <<User Dirs>>
  }
#+end_src

*** glx
#+NAME: glx
#+begin_src nix
  nixGL.packages = inputs.nixgl.packages;

  targets.genericLinux.enable = true;

  home.activation = {
    clearNixglCache = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
        [ -v DRY_RUN ] || rm -f ${config.xdg.cacheHome}/nixgl/result*
      '';
  };

#+end_src

*** gpg
#+NAME: GPG
#+begin_src nix
  home.file.".local/share/gnupg/gpg-agent.conf".text = ''
     pinentry-program /usr/bin/pinentry-emacs
     allow-loopback-pinentry
     allow-emacs-pinentry
     default-cache-ttl 600
     max-cache-ttl 7200
     enable-ssh-support
  '';
  home.file.".local/share/gnupg/gpg.conf".text = ''
     use-agent
  '';
#+end_src

*** alsoftrc
#+NAME: alsoftrc
#+begin_src nix
  home.file.".alsoftrc".text = ''
    [general]
    drivers=pulse
    hrtf=true
  '';
#+end_src

*** Environment variables
#+NAME: Environment Variables
#+begin_src nix
  home.sessionVariables = {
    XDG_DATA_HOME="$HOME/.local";
    XDG_STATE_HOME="$HOME/.local/state";
    XDG_CACHE_HOME="$HOME/.cache";
    XDG_CONFIG_HOME="$HOME/.config";
    XDG_DATA_DIRS= lib.mkForce "$HOME/.nix-profile/share:$XDG_DATA_DIRS";
    # EDITOR = "emacsclient";
    BROWSER="qutebrowser";
    _JAVA_OPTIONS="-Djava.util.prefs.userRoot=$XDG_CONFIG_HOME/java";
    GTK2_RC_FILES="/home/holschcc/.gtkrc-2.0";
    SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)";
    _JAVA_AWT_WM_NONREPARENTING = "1";
    PATH="/run/system-manager/sw/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/holschcc/bin:/home/holschcc/.nix-profile/bin";
  };
#+end_src

*** User Dirs
#+NAME: User Dirs
#+begin_src nix
  xdg.userDirs = {
      enable = true;
      createDirectories = true;
      desktop = null;
      publicShare = null;
      templates = null;
      documents = "${config.home.homeDirectory}/doc";
      download = "${config.home.homeDirectory}/dwn";
      music = "${config.home.homeDirectory}/mus";
      pictures = "${config.home.homeDirectory}/pic";
      videos = "${config.home.homeDirectory}/vid";
    };
#+end_src

** shells
*** boilerplate
#+begin_src nix :noweb yes :tangle shells.nix
  { pkgs, ... }:
  {
    imports = [
          ./dash.nix
    ];

    <<Shell Aliases>>

    programs = {
      <<Fish Shell>>

      <<Bash Shell>>

      <<Starship>>

      <<Direnv>>

      <<Dash Shell>>

      emacs.init.usePackage = {
        <<Eshell>>
      };
    };
  }
#+end_src

*** aliases
#+NAME: Shell Aliases
#+begin_src nix
  home.shellAliases = {
    ffrecord = "ffmpeg -f sndio -i snd/0.mon -f x11grab -r 30 -s 1920x1080 -i :0 -c:v libx164 -preset ultrafast -acodec copy ~/test.mkv";
    ffaud = "ffmpeg -f alsa -channels 1 -sample_rate 44100 -i default:CARD=Mic output.flac";
    sx = "startx";
    otp = "pass otp";
    run = "cd /run/";
    l = "ls";
    ".." = "cd ..";
    tortube = "yt-dlp --proxy socks://localhost:9050";
    wget = "torsocks wget --hsts-file=$XDG_DATA_HOME/wget-hsts";
    ga = "git add";
    gc = "torsocks git clone";
    gp = "git pull";
    gP = "git push";
  };
#+end_src

*** fish
This shell is mostly around for eshell to get completions from, but it can be used interactively, if need be
#+NAME: Fish Shell
#+begin_src nix
  fish = {
    enable = true;
    package = pkgs.fish;
    interactiveShellInit = ''${pkgs.pfetch}/bin/pfetch'';
  };
#+end_src

*** bash
It's mostly here for eshell to get completions from, but it's a usable shell
#+NAME: Bash Shell
#+begin_src nix
  bash = {
    enable = true;
    initExtra = ''${pkgs.pfetch}/bin/pfetch'';
    shellAliases.z = "cd ./$(ls -d */ .*/ | ${pkgs.ezf}/bin/ezf)";
  };
#+end_src

*** starship
a prompt for bash & fish
#+NAME: Starship
#+begin_src nix
  starship = {
    enable = true;
    enableFishIntegration = true;
    enableBashIntegration = true;
  };
#+end_src

*** direnv
#+NAME: Direnv
#+begin_src nix
  direnv = {
    enable = true;
    enableBashIntegration = true;
    nix-direnv.enable = true;
  };

  emacs.init.usePackage.envrc = {
      enable = true;
      ghook = ["('after-init-hook 'envrc-global-mode)"];
      generalOne."efs/leader-keys" = {
        "e" = '''(:ignore t :which-key "direnv")'';
        "ea" = '''(envrc-allow :which-key "allow")'';
        "eu" = '''(envrc-reload :which-key "update dir")'';
      };
  };
#+end_src

*** Eshell
Eshell is a command shell written in elisp, & duplicates many of the GNU coreutils in elisp. It can also call aliases & elisp functions.

=Key Bindings=
+ =[[= / =]]= Go backwards & forwards in the buffer's prompts.

Eat lets us get away with using eshell all the time. It can be used to get into a normal shell, but I doubt I'll be doing that too much.
#+NAME: Eshell
#+begin_src nix :noweb yes
    eshell = {
      enable = true;
      babel = "eshell";
      after = ["evil-collection"];
      ghook = [
        "('eshell-first-time-mode-hook 'efs/configure-eshell)"
        #Save command history when commands are entered
        "('eshell-precommand-hook 'eshell-save-some-history)"
        #pfetch
        ''('eshell-banner-load-hook  (lambda ()
                                       (gsetq eshell-banner-message
                                          (shell-command-to-string "${pkgs.pfetch}/bin/pfetch"))))''
      ];
      general."s-<enter>" = "'efs/make-eshell";
      generalOne.eshell-mode-map = {
        "M-o" = "'eshell-previous-matching-input-from-input";
        "M-e" = "'eshell-next-matching-input-from-input";
      };
      generalTwo.local-leader.eshell-mode-map = {
        "e" = '''(eshell-insert-envvar :which-key "insert environment variable")'';
        "b" = '''(eshell-insert-buffer-name :which-key "insert buffer name")'';
      };
      init = ''
    <<Emacs Eshell Init>>
  '';
      config = ''
    <<Emacs Eshell Config>>
  '';
    } ;

    eshell-syntax-highlighting = {
      enable = true;
      defer = true;
      ghook = ["('eshell-mode-hook 'eshell-syntax-highlighting-global-mode)"];
    };

    fish-completion = {
      enable = true;
      defer = true;
      ghook = ["('eshell-mode-hook 'fish-completion-mode)"];
    };

    eshell-git-prompt = {
      enable = true;
      afterCall = ["eshell-mode"];
      config = ''(eshell-git-prompt-use-theme 'powerline)'';
    };

    eat = {
      enable = true;
      defer = true;
      afterCall = ["eshell-mode"];
      config = ''
        <<Emacs Eat Config>>
      '';
    };
#+end_src

#+NAME: Emacs Eshell Init
#+begin_src emacs-lisp
  (defun efs/make-eshell ()
    (interactive)
    (eshell 'N))
#+end_src

#+NAME: Emacs Eshell Config
#+begin_src emacs-lisp
  (defun efs/configure-eshell ()
    ;; Truncate buffer for perforance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)
    (setenv "TERM" "xterm")
    (gsetq eshell-command-aliases-list '(("gc" "torsocks git clone")
  					 ("nixbuild" "home-manager switch --flake ~/.config/home-manager/#holschcc")
  					 ("l" "ls $*")
  					 ("halt" "doas shutdown -P now")
  					 ("systembuild" "doas nix run 'github:numtide/system-manager' -- switch --flake '/etc/system-manager/'"))
  	   eshell-history-size 0
           eshell-buffer-maximum-lines 100
           eshell-hist-ignoredups t
           eshell-scroll-to-bottom-on-input t))

  (with-eval-after-load 'esh-opt
    (gsetq eshell-destroy-buffer-when-process-dies t))

  (with-eval-after-load 'evil-collection-eshell
    (general-add-advice 'evil-collection-eshell-setup-keys
  		:after
  		'(lambda ()
  		   (general-def 'normal eshell-mode-map
  		     "v" 'evil-collection-eshell-evil-delete
  		     "V" 'evil-collection-eshell-evil-change
  		     "C-v" 'evil-collection-eshell-evil-delete-line
  		     "d" 'evil-yank
  		     "D" 'evil-yank-line
  		     "c" 'evil-visual-state
  		     "C" 'evil-visual-line))))
#+end_src

#+NAME: Emacs Eat Config
#+begin_src emacs-lisp
  (eat-eshell-mode)
  (evil-ex-define-cmd "term" 'eat)
  (defun eat-term-get-suitable-term-name (&optional display)
    "Return the most suitable value for `TERM' for DISPLAY.

    If the number of colors supported by display (as returned by
    `display-color-cells') is more than 256, return \"eat-truecolor\", if
    it is more than 8 but less than or equal to 256, return
    \"eat-256color\", if is more than 1 but less than or equal to 8,
    return \"eat-color\", otherwise return \"eat-mono\"."
    (let ((colors (display-color-cells display)))
      (cond ((> colors 256) "xterm")
            ((> colors 8) "xterm")
            ((> colors 1) "xterm")
            (t "xterm"))))

#+end_src

*** dash
Probably won't use this one interactively much, but it's my login shell, & my /bin/sh, so it may as well be nice
#+NAME: Dash Shell
#+begin_src nix
  dash = {
    enable = true;
    initExtra = ''
      ${pkgs.pfetch}/bin/pfetch
      . ~/.cache/wal/colors.sh
    '';
    shellAliases.z = "cd ./$(ls -d */ .*/ | ${pkgs.ezf}/bin/ezf)";
    profileExtra = ''
      export LEIN_HOME="$XDG_DATA_HOME/lein";
      export NPM_CONFIG_USERCONFIG="$XDG_CONFIG_HOME/npm/npmrc";
      export XCOMPOSECACHE="$XDG_CACHE_HOME/x11/xcompose";
      export GOPATH="$XDG_DATA_HOME/go";
      export DOT_SAGE="$XDG_CONFIG_HOME/sage";
      # export XAUTHORITY="$XDG_RUNTIME_DIR/Xauthority";
      export CARGO_HOME="$XDG_DATA_HOME/cargo";
      export GNUPGHOME="$XDG_DATA_HOME/share/gnupg";
      export PASSWORD_STORE_DIR="$XDG_DATA_HOME/share/pass";
      export CUDA_CACHE_PATH="$XDG_CACHE_HOME/nv";
      export ERRFILE="$XDG_CACHE_HOME/X11/xsession-errors"
      export XINITRC="$XDG_CONFIG_HOME"/X11/xinitrc
      export HISTFILE="''${XDG_STATE_HOME}"/bash/history
      GRADLE_USER_HOME="$XDG_DATA_HOME"/gradle
      
      [ "$(tty)" = "/dev/tty1" ] && ! pidof -s Xorg >/dev/null 2>&1 && exec startx
    '';
  };
#+end_src

**** Configuration template
This one borrows heavily from the bash module

Special note: The profile settings here take precedence over bash's, because I'm too dumb to make them coexist

***** Premble
#+begin_src nix :noweb yes :tangle dash.nix
  { config, lib, pkgs, ... }:

  with lib;

  let

    cfg = config.programs.dash;

    writeBashScript = name: text:
      pkgs.writeTextFile {
        inherit name text;
        checkPhase = ''
          ${pkgs.stdenv.shellDryRun} "$target"
        '';
      };

  in {
    meta.maintainers = [ maintainers.rycee ];
    <<Dash Option Definitions>>
    
    <<Dash File Generation>>
  }
#+end_src

***** Option Definitions
#+NAME: Dash Option Definitions
#+begin_src nix
    options = {
      programs.dash = {
        enable = mkEnableOption "Debian Almquiest Shell";

        shellOptions = mkOption {
          type = types.listOf types.str;
          default = [];
          example = [ "extglob" "-cdspell" ];
          description = ''
            Shell options to set. Prefix an option with
            "`-`" to unset.
          '';
        };

        sessionVariables = mkOption {
          default = { };
          type = types.attrs;
          example = { MAILCHECK = 30; };
          description = ''
            Environment variables that will be set for the dash session.
          '';
        };

        shellAliases = mkOption {
          default = { };
          type = types.attrsOf types.str;
          example = literalExpression ''
            {
              ll = "ls -l";
              ".." = "cd ..";
            }
          '';
          description = ''
            An attribute set that maps aliases (the top level attribute names in
            this option) to command strings or directly to build outputs.
          '';
        };

        profileExtra = mkOption {
          default = "";
          type = types.lines;
          description = ''
            Extra commands that should be run when initializing a login
            shell.
          '';
        };

        initExtra = mkOption {
          default = "";
          type = types.lines;
          description = ''
            Extra commands that should be run when initializing an
            interactive shell.
          '';
        };

        dashrcExtra = mkOption {
          default = "";
          type = types.lines;
          description = ''
            Extra commands that should be placed in {file}`~/.dashrc`.
            Note that these commands will be run even in non-interactive shells.
          '';
        };
      };
    };
#+end_src

***** File generation
#+NAME: Dash File Generation
#+begin_src nix
    config = let
      aliasesStr = concatStringsSep "\n"
        ((mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
          cfg.shellAliases) ++ 
        (mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
          config.home.shellAliases));

      globalAliasesStr = concatStringsSep "\n"
        (mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
          home.shellAliases);

      shoptsStr = let switch = v: if hasPrefix "-" v then "-u" else "-s";
      in concatStringsSep "\n"
      (map (v: "shopt ${switch v} ${removePrefix "-" v}") cfg.shellOptions);

      sessionVarsStr = config.lib.shell.exportAll cfg.sessionVariables;

    in mkIf cfg.enable {
      home.file.".profile".source = lib.mkForce (writeBashScript "profile" ''
        . "${config.home.profileDirectory}/etc/profile.d/hm-session-vars.sh"

        ${sessionVarsStr}

        ${cfg.profileExtra}
      '');

      home.file.".dashrc".source = writeBashScript "dashrc" ''
        ${cfg.dashrcExtra}

        ${shoptsStr}

        ${aliasesStr}

        ${cfg.initExtra}
      '' ;

      home.sessionVariables.ENV = "$HOME/.dashrc";
    };
#+end_src

** Aesthetics
*** Inputs
#+begin_src nix :noweb yes :tangle aesthetics.nix
  { config, inputs, lib, pkgs, ... }:

  {
    <<Stylix Config>>

    <<Aesthetics Picom>>

    programs.emacs.init.usePackage = {
      <<Aesthetics Prettify Symbols>>

      <<Emacs Ricing Icons>>
      
      <<Emacs Ricing Dashboard>>
      
      <<Emacs Ricing Nano>>

      <<Emacs Ricing Theme>>
      
      <<Emacs Ricing Solaire>>
      
      <<Emacs Ricing Posframes>>
    };
  }
#+end_src

*** Picom
For making emacs transparent
#+NAME: Aesthetics Picom
#+begin_src nix
  services.picom = {
    enable = true;
    package = (config.lib.nixGL.wrap pkgs.picom);
    backend = "glx";
    opacityRules = [ "70:class_g = 'lmms'" ];
    settings = {
      glx-no-stencil = true;
      glx-no-rebind-pixmap = true;
      use-damage = true;
      vsync = true;
      blur = {
        method = "gaussian";
        size = 5;
        deviation = 2.0;
      };
      shadow-exclude = [ "class_g != 'emacs'"
      ];
    };
    shadow = true;
  };
#+end_src

*** Stylix
Stylix does a bad job of theming emacs, so we use pywal instead

Pywal integration: https://github.com/danth/stylix/issues/99
#+NAME: Stylix Config
#+begin_src nix
  stylix = {
    enable = true;
    polarity = "dark";
    targets = {
      vencord.enable = false;
      vesktop.enable = true;
      emacs.enable = false;
    };
    image = ./wallpaper.png;
    cursor = {
      package = pkgs.nordzy-cursor-theme;
      name = "Nordzy-cursors-white";
      size = 16;
    };
    opacity = {
      applications = 0.9;
      popups = 0.9;
      terminal = 0.9;
    };
    fonts = with pkgs; rec {
      monospace = {
        package = jetbrains-mono;
        name = "JetBrains Mono";
      };
      sansSerif = {
        package = inputs.apple-fonts.packages.${system}.sf-pro;
        name = "SF Pro";
      };
      serif = sansSerif;
    };
  };

  home.file = {
    ".cache/colors.json".source = config.lib.stylix.colors {
      template = builtins.readFile ./pywal.json.mustache;
      extension = ".json";
    };
  };

  home.activation =  #ALSO ACTIVATES AT REBOOT
    {
      generate_pywal_colors = lib.hm.dag.entryAfter ["writeBoundary"] ''
         $DRY_RUN_CMD ${pkgs.pywal}/bin/wal -f ~/.cache/colors.json
         $DRY_RUN_CMD ${pkgs.pywal}/bin/wal -R
       '';
    } ;
#+end_src

*** Icons
Installs all the icon fonts for dired.

Use =M-x all-the-icons-install-fonts=
#+NAME: Emacs Ricing Icons
#+begin_src nix
  nerd-icons = {
    enable = true;
    command = [
      "nerd-icons-octicon"
      "nerd-icons-faicon"
      "nerd-icons-flicon"
      "nerd-icons-wicon"
      "nerd-icons-mdicon"
      "nerd-icons-codicon"
      "nerd-icons-devicon"
      "nerd-icons-ipsicon"
      "nerd-icons-pomicon"
      "nerd-icons-powerline"
    ];
  };

  all-the-icons = {
    enable = true;
  };

  nerd-icons-completion = {
    enable = true;
    ghook = ["('marginalia-mode-hook 'nerd-icons-completion-marginalia-setup)"];
  };
#+end_src

*** Prettify Symbols
#+NAME: Aesthetics Prettify Symbols
#+begin_src nix
  prettify-symbols = {
    enable = true;
    ghook = ["('prog-mode-hook 'prettify-symbols-mode)"];
  };
#+end_src

*** Dashboard
#+NAME: Emacs Ricing Dashboard
#+begin_src nix :noweb yes
  dashboard = {
    enable = true;
    ghook = ["('on-init-ui-hook '(dashboard-insert-startupify-lists dashboard-initialize))"];
    config = ''
      <<Emacs Dashboard Config>>  
    '' ;
    custom = {
      dashboard-banner-logo-title = ''"Emacs: The one true desktop environment"'';
      dashboard-center-content = true;
      dashboard-items = '''((recents   . 5)
                            (bookmarks . 5)
                            (projects  . 5)
                            (agenda    . 5))'';
      dashboard-icon-type = "'nerd-icons";
      dashboard-set-heading-icons = true;
      dashboard-set-file-icons = true;
      dashboard-agenda-sort-strategy = "'(time-up)";
    };
  };
#+end_src

#+NAME: Emacs Dashboard Config
#+begin_src emacs-lisp
  (dashboard-setup-startup-hook)
  (dashboard-open)
  (evil-collection-dashboard-setup)
  (evil-collection-dashboard-setup-jump-commands)
#+end_src

*** Nano
Using nano modeline to cut down clutter.

I'm not using the minor mode, because its text is being sent to the tab bar.

The powerline separators were borrowed from punchline, because I think they look cool
#+NAME: Emacs Ricing Nano
#+begin_src nix :noweb yes
  doom-nano-modeline = {
    enable = true;
    afterCall = ["after-init-hook"];
    custom.mode-line-format = false;
    config = ''
      <<Emacs Doom Nano Modeline Config>>
    '';
  };
#+end_src

This is just overriding a bunch of functions so that I can put all the info in the tab bar
#+NAME: Emacs Doom Nano Modeline Config
#+begin_src emacs-lisp
  (defun doom-nano-modeline--render (left right &optional hide-evil-mode)
    "Render the doom-nano modeline string.

    LEFT is the information that will be rendered to the left of the modeline. RIGHT
    is the information that will be rendered to the right of modeline. Both
    variables must be a list in which each element has the following syntax:

        (text . face)

    where TEXT will be decorated with FACE.

    If HIDE-EVIL-MODE is nil, the Evil mode state is not shown in the modeline."
    (let* ((window (get-buffer-window (current-buffer)))

           ;; Variable to store if the this window is active.
  	 (active t)

           ;; Status of the buffer.
           (status (doom-nano-modeline-status))

           ;; Check if we are recording a macro and get its name.
           (hasmacro (or defining-kbd-macro executing-kbd-macro))
           (macroname (if (bound-and-true-p evil-this-macro)
                          (char-to-string evil-this-macro)
                        "?"))

           ;; String to indicate the current evil mode.
           (evilstate
            (if hide-evil-mode
                nil
              (concat (cond ((eq evil-state 'emacs)    "E ")
                            ((eq evil-state 'motion)   "M ")
                            ((eq evil-state 'normal)   "N ")
                            ((eq evil-state 'insert)   "I ")
                            ((eq evil-state 'replace)  "R ")
                            ((eq evil-state 'operator) "O ")
                            ((eq evil-state 'god) "G ")
                            ((eq evil-state 'symex) "S ")
                            ((eq evil-state 'visual) (cond ((eq evil-visual-selection 'line)  "L ")
                                                           ((eq evil-visual-selection 'block) "B ")
                                                           (t                                 "V ")))
                            (t "? ")))))

           ;; String to indicate if a macro is being recorded.
           (macrostring (if hasmacro (concat "● " macroname ) nil))

           ;; Select the modeline face.
  	 (modeline-face 'doom-nano-modeline-active-face)

           ;; Select the face to highlight the evil state.
           (evilstate-face
            (cond (hide-evil-mode            modeline-face)
                  ((not active)              modeline-face)
                  ((eq evil-state 'emacs)    'doom-nano-modeline-evil-emacs-state-face)
                  ((or (eq evil-state 'normal) (eq evil-state 'god) (eq evil-state 'symex))   'doom-nano-modeline-evil-normal-state-face)
                  ((eq evil-state 'motion)   'doom-nano-modeline-evil-motion-state-face)
                  ((eq evil-state 'insert)   'doom-nano-modeline-evil-insert-state-face)
                  ((eq evil-state 'replace)  'doom-nano-modeline-evil-replace-state-face)
                  ((eq evil-state 'operator) 'doom-nano-modeline-evil-operator-state-face)
                  ((eq evil-state 'visual)   'doom-nano-modeline-evil-visual-state-face)
                  (t                         modeline-face)))

           ;; Select the face to highlight the macro recording indicator.
           (macro-face (if hasmacro 'doom-nano-modeline-macro-face modeline-face))

           ;; Assemble the left string with the highlights.
           (pleft (concat
                   (propertize " "
                               'face evilstate-face
                               'display `(raise ,doom-nano-modeline-top-padding))

                   ;; Evil state.
                   (when evilstate
                     (concat (propertize evilstate 'face evilstate-face)
                             (propertize " " 'face modeline-face)))

                   ;; Macro recording indicator.
                   (when macrostring
                     (concat (propertize macrostring 'face macro-face)
                             (propertize " " 'face modeline-face)))

                   ;; Left list.
                   (if left
                       (mapconcat
                        (lambda (element)
                          (if (and active (cdr element))
                              (propertize (car element) 'face (cdr element))
                            (propertize (car element) 'face modeline-face)))
                        left
                        "")
                     ""))))

      ;; Concatenate and return the modeline string.
      (concat pleft
              ;; We have one final space as margin, so we make sure it is
              ;; highlighted with the correct face.
              (propertize " " 'face modeline-face))))

  (defun doom-nano-modeline-org-mode-buffer-name-and-major-mode ()
    "Return the buffer name and the major mode for Org buffers."
    (if (derived-mode-p 'org-mode)
        (let* ((org-title (doom-nano-modeline--get-org-title))
               (buffer-name (if org-title
                                org-title
                              (format-mode-line "%b")))
               (buffer-modified (if (and buffer-file-name (buffer-modified-p)) "** " "")))

          `((,(concat buffer-modified buffer-name) . nil)
  	  ("  " . nil)
            (,(nerd-icons-icon-for-buffer) . doom-nano-modeline-major-mode-face)
  	  ("  " . nil)))
      (doom-nano-modeline-default-mode)))

  (defun doom-nano-modeline-buffer-name-vc-and-major-mode ()
    "Return the buffer name and the major mode."
    (let* ((buffer-name (cond
                         ((and (derived-mode-p 'org-mode)
                               (buffer-narrowed-p)
                               (buffer-base-buffer))
                          (format"%s [%s]" (buffer-base-buffer)
                                 (org-link-display-format
                                  (substring-no-properties (or (org-get-heading 'no-tags)
                                                               "-")))))
                         ((and (buffer-narrowed-p)
                               (buffer-base-buffer))
                          (format"%s [narrow]" (buffer-base-buffer)))
                         (t
                          (format-mode-line "%b"))))

           (buffer-modified (if (and buffer-file-name (buffer-modified-p)) "** " ""))

           (vc-branch-name (doom-nano-modeline--get-vc-branch))

           (vc-branch (if vc-branch-name
                          `((vc-branch-name . nil))
                        nil)))

      `((,(concat buffer-modified buffer-name) . nil)
        ("  " . nil)
        (,(if vc-branch-name (concat vc-branch-name " ") "") . doom-nano-modeline-vc-branch-name-face)
        (,(if vc-branch-name " " "") . nil)
        (,(if (or (equal major-mode 'nix-mode) (equal major-mode 'bibtex-mode)) (all-the-icons-icon-for-buffer) (nerd-icons-icon-for-buffer)) . doom-nano-modeline-major-mode-face)
        ("  " . nil))))

  (defun doom-nano-modeline--special-mode-p ()
    "Return t if we are in `special-mode' or nil otherwise."
    (or (derived-mode-p 'special-mode) (and (eq major-mode 'exwm-mode) (not qutebrowser-exwm-mode))))

  (defun doom-nano-tabline ()
    "Format the modeline for the tabline"
    (let* ((the-format '((:eval
  			(funcall
  			 (or (catch 'found
  			       (dolist (elt doom-nano-modeline-mode-formats)
  				 (let* ((config (cdr elt))
  					(mode-p (plist-get config :mode-p))
  					(format (plist-get config :format)))
  				   (when mode-p
  				     (when (funcall mode-p)
  				       (throw 'found format))))))
  			     #'doom-nano-modeline-default-mode-format))))))
      `((global menu-item ,(format-mode-line the-format) ignore))))
#+end_src

*** Emacs Theme
Makes emacs' theme mimic the wallpaper. A good pywal config will get most things to match.
#+NAME: Emacs Ricing Theme
#+begin_src nix :noweb yes
  ewal = {
    enable = true;
    demand = true;
    custom = {
      ewal-use-built-in-always-p = false;
      ewal-use-built-in-on-failure-p = true;
      ewal-built-in-palette = ''"sexy-material"'';
    };
  };

  ewal-doom-themes = {
    enable = true;
    demand = true;
    config = ''
      <<Emacs Ewal Config>>
    '';
    custom = {
      doom-themes-enable-bold = true;
      doom-themes-enable-italic = true;
    };
  };
#+end_src

#+NAME: Emacs Ewal Config
#+begin_src emacs-lisp
  (load-theme 'ewal-doom-one t)
  ;; Stolen from Noctuid
  (let (custom--inhibit-theme-enable)
    (custom-theme-set-faces
     'ewal-doom-one
     `(font-lock-number-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-header-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-header-delimiter-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-bold-face ((t (:foreground ,(ewal-get-color 'green)))))
     `(markdown-list-face ((t (:foreground ,(ewal-get-color 'green)))))
     `(org-code ((t (:foreground ,(ewal-get-color 'green)))))
     `(line-number ((t (:foreground ,(ewal-get-color 'blue)))))
     `(eshell-git-prompt-powerline-dir-face ((t (:background ,(ewal-get-color 'blue)))))
     `(hl-line-face ((t (:background ,(ewal-get-color 'green)))))
     `(solaire-hl-line-face ((t (:background ,(ewal-get-color 'green)))))
     `(tab-bar ((t :inherit mode-line)))
     `(eshell-git-prompt-powerline-clean-face ((t (:background ,(ewal-get-color 'green)))))
     `(eshell-git-prompt-powerline-not-clean-face ((t (:background ,(ewal-get-color 'red)))))))
  (doom-themes-visual-bell-config)
  (doom-themes-org-config)
#+end_src

*** Solaire
Solaire dims certain parts of the frame.
#+NAME: Emacs Ricing Solaire
#+begin_src nix
  solaire-mode = {
    enable = true;
    demand = true;
    config = ''(solaire-global-mode)'';
  };
#+end_src

*** Posframes
Vertico Posframe puts vertico in a separate frame, causing it to actually look like dmenu.
#+NAME: Emacs Ricing Posframes
#+begin_src nix
  vertico-posframe = {
    enable = true;
    defer = true;
    ghook = ["('vertico-mode-hook 'vertico-posframe-mode)"];
    config = ''(set-face-attribute 'vertico-posframe-face nil :family 'variable-pitch)'';
  };

  which-key-posframe = {
    enable = true;
    defer = true;
    ghook = ["('which-key-mode-hook 'which-key-posframe-mode)"];
    custom = {
      which-key-posframe-poshandler = "'posframe-poshandler-frame-bottom-center";
      which-key-posframe-parameters = "'(:parent-frame nil :refposhandler posframe-refposhandler-xwininfo)";
    };
  };
#+end_src

*** Mustache File
#+begin_src json-ts :tangle pywal.json.mustache
  {
      "special": {
          "background": "#{{base00-hex}}",
          "foreground": "#{{base07-hex}}",
          "cursor": "#{{base07-hex}}"
      },
      "colors": {
          "color0": "#{{base00-hex}}",
          "color1": "#{{base01-hex}}",
          "color2": "#{{base02-hex}}",
          "color3": "#{{base03-hex}}",
          "color4": "#{{base04-hex}}",
          "color5": "#{{base05-hex}}",
          "color6": "#{{base06-hex}}",
          "color7": "#{{base07-hex}}",
          "color8": "#{{base08-hex}}",
          "color9": "#{{base09-hex}}",
          "color10": "#{{base0A-hex}}",
          "color11": "#{{base0B-hex}}",
          "color12": "#{{base0C-hex}}",
          "color13": "#{{base0D-hex}}",
          "color14": "#{{base0E-hex}}",
          "color15": "#{{base0F-hex}}"
      }
  }

#+end_src

** Extra Packages
#+begin_src nix :tangle extra-packages.nix
  { config, pkgs, pkgs-stable, ... }:

  {
    home.packages = with pkgs; [
      (config.lib.nixGL.wrap pkgs-stable.gimp)
      (config.lib.nixGL.wrap prismlauncher)
      (config.lib.nixGL.wrap blockbench)
      (config.lib.nixGL.wrap tor-browser)
      wget
      zip
      unzip
      zbar
      # comms
      (config.lib.nixGL.wrap teams-for-linux)
      (config.lib.nixGL.wrap thunderbird)
      vesktop
      # things emacs appreciates
      xclip
      xsel
      xdotool
      # scripts
      ezf
      pkg
    ];
  }
#+end_src

** Gui
#+NAME: xinitrc-config
#+begin_src shell
  #!/usr/bin/sh
  xrandr --setprovideroutputsource modesetting NVIDIA-0
  xrandr --auto
  xrandr --dpi 96
  # xrandr --output eDP-1 --mode 2560x1600
  ${pkgs.xwallpaper}/bin/xwallpaper --stretch ~/.config/home-manager/wallpaper.png 
  xrdb load ~/.cache/wal/colors.Xresources 

  if test -z "$DBUS_SESSION_BUS_ADDRESS"; then
      eval $(dbus-launch --exit-with-session --sh-syntax)
  fi

  xmodmap ~/.Xmodmap

  picom &

  if command -v dbus-update-activation-environment >/dev/null 2>&1; then
      dbus-update-activation-environment DISPLAY XAUTHORITY
  fi

  # exec dbus-launch --exit-with-session emacsclient -c
  exec dbus-launch --exit-with-session emacs -mm --debug-init
#+end_src

#+begin_src nix :noweb yes :tangle gui.nix
  { pkgs, ... }:

  {
    home.file.".config/X11/xinitrc".text = '' 
      <<xinitrc-config>>
    '' ;
  }
#+end_src

** Development
This was more directly stolen than the other parts
I think most of it was from the github page for lsp mode, but it's been a while, & I don't remember much.
https://github.com/joaotavora/eglot/discussions/888
https://gist.github.com/rosholger/e519c04243ae7ccb5bbf7ebef3f1cec2
#+begin_src nix :noweb yes :tangle development.nix
{ inputs, pkgs, lib, pkgs-stable, config, ... }:

{
  imports = [
    ./language-support
    ./syntax-checkers
    ./project-management
  ];

  programs.emacs.init = {
    ide = {
      project = true;
      flymake = {
        enable = true;
        preset = true;
      };
      symex = true;  
      hoverDoc = true;
      evil = true;
      eglot = {
        enable = true;
        preset = true;
      };
      languages = {
        bash.enable = true;
        gradle.enable = true;
        java.enable = true;
        json.enable = true;
        nix.enable = true;
        toml.enable = true;
        xml.enable = true;
        zenscript.enable = true;
        emacs-lisp = {
          enable = true;
          flymake = true;
        };
        org = {
          enable = true;
          aesthetics = {
            enable = true;
            headerFont = config.stylix.fonts.sansSerif.name;
          };
          captureTemplates.enable = true;
        };
        javascript.enable = true;
        ledger.enable = true;
        vimscript.enable = true;
        julia.enable = true;
      };
    };

    usePackage = {
      <<Development Misc>>
      
      # lsp-mode.gfhook = ["('lsp-mode-hook (lambda () (company-mode -1)))"];
      # lsp-java.custom.lsp-java-content-provider-preferred = ''"fernflower"'';

      <<Development Direnv>>

      <<Development Treesitter>>
      
      <<Development Project>>

      <<Development Eglot>>
      
      # <<Development Dape>>

      <<Development Python>>
      
      <<Development Racket>>

      cider.generalTwo.local-leader.cider-mode-map."s" = '''(cider-jack-in :which-key "start cider")''; 

      java-ts-mode = {
        init = ''
          <<Java Config>>
        '';  
        eglot = lib.mkForce ''("jdtls" "-data" "~/.cache/emacs/cache/java-workspace"
                                       :initializationOptions (:java (:contentProvider (:preferred "fernflower"))
                                                               :extendedClientCapabilities (:classFileContentsSupport t)))'';
      };

      prolog-mode.generalTwo."local-leader".prolog-mode-map."r" = '''(run-prolog :which-key "run")'';
    } ;
  };
}
#+end_src

*** Misc
#+NAME: Development Misc
#+begin_src nix
  editorconfig = {
    enable = true;
    afterCall = ["on-first-file-hook"];
    config = ''(editorconfig-mode)'';
  };

  rainbow-delimiters = {
    enable = true;
    ghook = ["('prog-mode-hook 'rainbow-delimiters-mode)"];
  };
#+end_src

*** Treesitter
#+NAME: Development Treesitter
#+begin_src nix
  treesitter-context = {
    enable = true;
    ghook = ["('(js-ts-mode-hook haskell-mode java-ts-mode-hook rustic-mode-hook c-ts-mode-hook python-mode-hook json-ts-mode-hook) 'treesitter-context-mode)"];
    custom.treesitter-context-frame-min-width = "30";
    config = ''
      (dolist (treesit-support '(treesitter-context--supported-mode treesitter-context--focus-supported-mode  treesitter-context--fold-supported-mode))
              (add-to-list treesit-support 'rustic-mode)
              (add-to-list treesit-support 'haskell-mode))
    '';
  };

  treesitter-context-fold = {
    enable = true;
    ghook = ["('treesitter-context-mode-hook 'treesitter-context-fold-mode)"];
    generalTwo."'normal".treesitter-context-fold-mode-map = {
      "zm" = "'treesitter-context-fold-hide";
      "zo" = "'treesitter-context-fold-show";
      "za" = "'treesitter-context-fold-toggle";
    };
  };

  treesitter-context-focus = {
    enable = true;
    command = ["treesitter-context-focus-mode"];
  };
#+end_src

*** Java
Borrowed from here:
https://gitlab.com/skybert/my-little-friends/-/blob/master/emacs/.emacs
#+NAME: Java Config
#+begin_src emacs-lisp
  (defun tkj/java-decompile-class ()
    "Run the FernFlower decompiler on the current .class file using
   fernflower, and opens the decompiled Java file."
    (interactive)
    (let* ((current-file (buffer-file-name))
           (output-dir (concat (file-name-directory current-file) "decompiled/"))
           (decompiled-file (concat output-dir (file-name-base current-file) ".java"))
           (command (format "fernflower %s %s"
                            (shell-quote-argument current-file)
                            (shell-quote-argument output-dir))))
      (if (and current-file (string-equal (file-name-extension current-file) "class"))
          (progn
            (unless (file-directory-p output-dir)
              (make-directory output-dir t))
            (message "Running FernFlower decompiler...")
            (shell-command command)
            (if (file-exists-p decompiled-file)
                (find-file decompiled-file)
              (message "Error: Decompiled file not found at %s" decompiled-file)))
        (message "Error: This command can only be run on .class files"))))
#+end_src

*** Project
#+NAME: Development Project
#+begin_src nix :noweb yes
magit = {
  enable = true;
  custom.magit-display-buffer-function = "#'magit-display-buffer-same-window-except-diff-v1";
  generalOne.project-prefix-map = {
    "v" = "'magit-status";
    "c" = "'magit-commit";
    "p" = "'magit-pull";
    "P" = "'magit-push";
    "b" = "'magit-branch";
    "m" = "'magit-merge";
  };
};

project.generalOne."efs/leader-keys"."P" = "project-prefix-map";

# projection-multi = {
#   enable = true;
#   generalOne.project-prefix-map."RET" = "'projection-multi-compile";
#   config = ''
#     <<Emacs Development Projection Config>>
#   '' ;
# };

projection-multi-embark = {
  enable = true;
  after = ["embark" "projection-multi"];
  config = ''(projection-multi-embark-setup-command-map)'';
};
#+end_src

#+NAME: Emacs Development Projection Config
#+begin_src emacs-lisp
(require 'projection)
(global-projection-hook-mode)
(oset projection-project-type-maven build "mvn -B clean compile")
#+end_src

*** Eglot
#+NAME: Development Eglot
#+begin_src nix :noweb yes
  eglot = {
    gfhook = ["('eglot-managed-mode-hook 'my/eglot-capf)"];
    generalTwo.local-leader.eglot-mode-map = {
      "f" = "'eglot-format-buffer";
      "a" = "'eglot-code-actions";
      "d" = "'eldoc-doc-buffer";
    };
    config = ''
      <<Development Eglot Config>>
    '';
  } ;

  flymake = {
    enable = true;
    defer = true;
    config = ''(evil-ex-define-cmd "trouble" 'flymake-show-buffer-diagnostics)'';
  };

  eglot-tempel = {
    enable = true;
    after = ["eglot"];
    config = ''(eglot-tempel-mode)'';
  };
#+end_src

#+NAME: Development Eglot Config
#+begin_src emacs-lisp
  (defun my/eglot-capf ()
    (setq-local completion-at-point-functions
                (list (cape-capf-super
                       #'tempel-complete
                       #'eglot-completion-at-point
                       #'cape-file)
                      #'cape-dabbrev)))
  (general-add-advice 'evil-collection-eglot-setup
  		    :after '(lambda ()
  			      (general-def 'normal eglot-mode-map "K" 'evil-substitute)))
#+end_src

*** Dape
#+NAME: Development Dape
#+begin_src nix
  dape = {
    enable = true;
    after = ["eglot"];
    gfhook = ["('dape-on-stopped-hooks (list 'dape-info 'dape-repl))"];
    custom = {
      dape-window-arrangement = "gud";
      dape-key-prefix = ''"\C-x\C-a"'';
    };
  };
#+end_src

*** Python
#+NAME: Development Python
#+begin_src nix
  python-ts-mode = {
    generalTwo."local-leader".python-mode-map."r" = "'python-shell-send-buffer";
    custom = {
      python-shell-interpreter = ''"ipython"'';
      python-shell-interpreter-args = ''"-i --simple-prompt"'';
    };
  };

  code-cells.generalTwo = {
    "'normal".code-cells-mode-map = {
      "M-e" = "'code-cells-forward-cell";
      "M-o" = "'code-cells-backward-cell";
    };
    "local-leader".code-cells-mode-map = {
      "e" = "'code-cells-eval";
    };
  };
#+end_src

*** Racket
#+NAME: Development Racket
#+begin_src nix
  racket-mode = {
    gfhook = ["('racket-mode-hook 'hs-minor-mode)"];
    generalTwo.local-leader.racket-mode-map = {
      "." = "'racket-xp-describe";
      "r" = "'racket-run";
    };
  };
#+end_src

*** Language Support
**** Default.nix
#+begin_src nix :tangle language-support/default.nix
  { ... }:

  {
    imports = [
      ./org.nix
      ./vimscript.nix
      ./ledger.nix
      ./julia.nix
    ];
  }
#+end_src
**** Org
Additions to make
+ [ ] Things relating to org capture (requires us to know how to use it first)
#+begin_src nix :tangle language-support/org.nix
{ pkgs, config, lib, ... } :

let
  ide = config.programs.emacs.init.ide;
in
  {
    options.programs.emacs.init.ide.languages.org = {
      enable = lib.mkEnableOption "Enables support for org mode. Borrows a great deal from emacs from scratch & doom emacs";
      aesthetics = {
        enable = lib.mkEnableOption "Enables org-modern & org-modern indent";
        headerFont = lib.mkOption {
          type = lib.types.str;
          default = "Liberation Serif";
          description = "The font to use for org headers. Defaults to Liberation Serif, since that's on most machines & I don't know what I'm doing";
        };
      };
      captureTemplates = {
        enable = lib.mkEnableOption "Enables doom's org-capture templates";
        todoFile = lib.mkOption {
          type = lib.types.str;
          default = "tasks.org";
          description = "The file in your org-directory to put todo entries for your agenda in";
        };
        notesFile = lib.mkOption {
          type = lib.types.str;
          default = "notes.org";
          description = "The file in your org-directory to put your notes in";
        };
        journalFile = lib.mkOption {
          type = lib.types.str;
          default = "journal.org";
          description = "The file in your org-directory to put your journal entries in";
        };
      };
    };

    config = lib.mkIf ide.languages.org.enable {
      programs.emacs.init.usePackage = {
        org = {
          enable = true;
          mode = [''("\\.org\\'" . org-mode)''];
          deferIncrementally = ["calendar" "find-func" "format-spec" "org-macs" "org-compat" "org-faces" "org-entities" "org-list" "org-pcomplete" "org-src" "org-footnote" "org-macro" "ob" "org" "org-agenda" "org-capture"];
          symex = ide.symex;
          babel = "org";
          custom = {
            org-confirm-babel-evaluate = lib.mkDefault false;
            org-src-fontify-natively = lib.mkDefault true;
            org-src-tab-acts-natively = lib.mkDefault true;
            org-log-done = lib.mkDefault false;
            org-log-into-drawer = lib.mkDefault true;
            org-hide-emphasis-markers = lib.mkIf ide.languages.org.aesthetics.enable (lib.mkDefault true);
            org-ellipsis = lib.mkIf ide.languages.org.aesthetics.enable (lib.mkDefault ''" ▾"'');

            # Settings from doom
            org-indirect-buffer-display = lib.mkDefault "'current-window";
            org-enforce-todo-dependencies = lib.mkDefault true;
            org-imenu-depth = lib.mkDefault "6";
            org-tags-column = lib.mkDefault "0";
            org-startup-folded  = lib.mkDefault false;
            org-agenda-inhibit-startup = lib.mkDefault true;
            org-agenda-window-setup = lib.mkDefault "'current-window";
            org-agenda-skip-unavailable-files = lib.mkDefault true;
            org-agenda-span = lib.mkDefault "10";
            org-agenda-start-on-weekday = lib.mkDefault false;
            org-agenda-start-day = lib.mkDefault ''"-3d"'';
            org-refile-targets = lib.mkDefault ''
              '((nil :maxlevel . 3)
                (org-agenda-files :maxlevel . 3))
            '';
            org-refile-use-outline-path = lib.mkDefault "'file";
            org-outline-path-complete-in-steps = lib.mkDefault false;
            org-src-preserve-indentation = lib.mkDefault true;
            org-link-elisp-confirm-function = lib.mkDefault false;
            org-src-window-setup = lib.mkDefault "'other-window";
            org-babel-lisp-eval-fn = lib.mkIf ide.languages.common-lisp.enable (lib.mkDefault "#'sly-eval");
            org-modules = lib.mkDefault "'(ol-bibtex)";
            org-agenda-files = lib.mkIf ide.languages.org.captureTemplates.enable (lib.mkDefault ''(list (expand-file-name "${ide.languages.org.captureTemplates.todoFile}" org-directory))'');
            org-default-notes-file = lib.mkIf ide.languages.org.captureTemplates.enable (lib.mkDefault ''(expand-file-name "${ide.languages.org.captureTemplates.notesFile}" org-directory)'');
            # borrowed from doom
            org-capture-bookmark = lib.mkIf ide.languages.org.captureTemplates.enable (lib.mkDefault false);
            org-capture-templates = lib.mkIf ide.languages.org.captureTemplates.enable (lib.mkDefault ''
              '(("t" "Personal todo" entry
                 (file org-default-todo-file)
                 "* TODO [ ] %?\n%i\n%a" :prepend t)
                ("n" "Personal notes" entry
                 (file org-default-notes-file)
                 "* %u %?\n%i\n%a" :prepend t)
                ("j" "Journal" entry
                 (file+olp+datetree org-default-journal-file)
                 "* %U %?\n%i\n%a" :prepend t)

                ;; Will use {project-root}/{todo,notes,changelog}.org, unless a
                ;; {todo,notes,changelog}.org file is found in a parent directory.
                ;; Uses the basename from `+org-capture-todo-file',
                ;; `+org-capture-changelog-file' and `+org-capture-notes-file'.
                ("p" "Templates for projects")
                ("pt" "Project-local todo" entry ; {project-root}/todo.org
                 (file nix-emacs-project-todo)
                 "* TODO %?\n%i\n%a" :prepend t)
                ("pn" "Project-local notes" entry ; {project-root}/notes.org
                 (file nix-emacs-project-notes)
                 "* %U %?\n%i\n%a" :prepend t)
                ("pc" "Project-local changelog" entry  ; {project-root}/changelog.org
                 (file+headline nix-emacs-project-changelog "Unreleased")
                 "* %U %?\n%i\n%a" :prepend t))
            '');
          };
          hook = ["(org-mode . org-indent-mode)"];
          init = ''
            (defun nix-emacs-project-file (file)
              "Retrieves file from the root of the current project."
              (expand-file-name file (project-root (project-current))))
            (defun nix-emacs-project-todo ()
              "Retrieves the project's todo.org file. Borrowed from doom emacs"
              (nix-emacs-project-file "todo.org"))
            (defun nix-emacs-project-notes ()
              "Retrieves the project's notes.org file. Borrowed from doom emacs"
              (nix-emacs-project-file "notes.org"))
            (defun nix-emacs-project-changelog ()
              "Retrieves the project's changelog.org file. Borrowed from doom emacs"
              (nix-emacs-project-file "changelog.org"))
          '';
          config = ''
            (defvar org-default-todo-file (expand-file-name "${ide.languages.org.captureTemplates.todoFile}" org-directory))
            (defvar org-default-journal-file (expand-file-name "${ide.languages.org.captureTemplates.journalFile}" org-directory))
            ;;(org-babel-do-load-languages
            ;;'org-babel-load-languages
            ;;'((emacs-lisp . t )
              ;;(python . t)
              ;;(R . t)))
            (push '("conf-unix" . conf-unix) org-src-lang-modes)
            ;; borrowed from doom
            (plist-put org-format-latex-options :scale 1.5)
          '';
        };

        org-appear = lib.mkIf ide.languages.org.aesthetics.enable {
          enable = true;
          hook = ["(org-mode . org-appear-mode)"];
        };

        org-contrib = lib.mkIf ide.hoverDoc {
          enable = true;
          config = ''(ox-extras-activate '(ignore-headlines))'';
          deferIncrementally = ["ox-extra"];
        };

        org-modern = lib.mkIf ide.languages.org.aesthetics.enable {
          enable = true;
          hook = [
            "(org-mode . org-modern-mode)"
            "(org-mode . org-toggle-pretty-entities)"
            "(org-mode . variable-pitch-mode)"
            "(org-mode . visual-line-mode)"
            "(org-mode . nix-emacs-org-font-setup)"
          ];
          custom = {
            org-modern-star = "'replace";
            org-modern-hide-stars = "'leading";
          };
          init = ''
            (defun nix-emacs-org-font-setup ()
              "Sets up org fonts. Originates from Emacs from Scratch."
              ;;Set faces for heading levels
              (dolist (face '((org-document-title . 1.4)
                              (org-level-1 . 1.4)
                              (org-level-2 . 1.3)
                              (org-level-3 . 1.2)
                              (org-level-4 . 1.1)
                              (org-level-5 . 1.05)
                              (org-level-6 . 1.05)
                              (org-level-7 . 1.05)
                              (org-level-8 . 1.05)))
                      (set-face-attribute (car face) nil :font "${ide.languages.org.aesthetics.headerFont}" :weight 'regular :height (cdr face)))

              ;; Ensure that anything that should be fixed-pitch in Org files appears that way
              (dolist (face (list 'org-block 'org-table 'org-formula 'org-checkbox 'line-number 'line-number-current-line))
                (set-face-attribute face nil :inherit 'fixed-pitch))
              (dolist (face (list 'org-code 'org-table 'org-verbatim))
                (set-face-attribute face nil :inherit '(shadow fixed-pitch)))
              (dolist (face (list 'org-special-keyword 'org-meta-line))
                (set-face-attribute face nil :inherit '(font-lock-comment-face fixed-pitch))))
          '';
        };

        eldoc-box = lib.mkIf ide.hoverDoc {
          enable = true;
          hook = ["(org-mode . eldoc-box-hover-mode)"];
        };

        org-modern-indent = lib.mkIf ide.languages.org.aesthetics.enable {
          enable = true;
          afterCall = ["org-mode-hook"];
          config = ''(add-hook 'org-mode-hook 'org-modern-indent-mode 90)'';
        };

        evil-org = lib.mkIf ide.evil {
          enable = true;
          ghook = ["('org-mode-hook 'evil-org-mode)"];
          gfhook = ["('org-capture-mode-hook 'evil-insert-state)"];
          # stolen from doom
          generalTwo."'normal".org-mode-map = {
            "]h" = '''(org-forward-heading-same-level :which-key "next heading")'';
            "[h" = '''(org-backward-heading-same-level :which-key "prev heading")'';
            "]c" = '''(org-babel-next-src-block :which-key "next src block")'';
            "[c" = '''(org-babel-previous-src-block :which-key "prev src block")'';
            "]l" = '''(org-next-link :which-key "next link")'';
            "[l" = '''(org-previous-link :which-key "prev link")'';
          };
          init = ''
            (add-to-list 'evil-fold-list
	                       `((org-mode)
	                         :open org-cycle
	                         :open-all nil
	                         :close org-cycle
	                         :close-all nil
	                         :toggle org-cycle
	                         :delete nil
	                         :open-rec nil))        
          '';
          config = ''
            (with-eval-after-load 'evil-collection
              (when (equal evil-collection-unimpaired-want-repeat-mode-integration t)
                (evil-collection-unimpaired-defvar-keymap org-forward-heading-same-level-repeat-map
                  "h" #'org-forward-heading-same-level
                  "H" #'org-backward-heading-same-level)
                (evil-collection-unimpaired-defvar-keymap org-backward-heading-same-level-repeat-map
                  "h" #'org-backward-heading-same-level
                  "H" #'org-forward-heading-same-level)
                (evil-collection-unimpaired-defvar-keymap org-babel-next-src-block-repeat-map
                  "c" #'org-babel-next-src-block
                  "C" #'org-babel-previous-src-block)
                (evil-collection-unimpaired-defvar-keymap org-babel-previous-src-block-repeat-map
                  "c" #'org-babel-previous-src-block
                  "C" #'org-babel-next-src-block)
                (evil-collection-unimpaired-defvar-keymap org-next-link-repeat-map
                  "l" #'org-next-link
                  "L" #'org-previous-link)
                (evil-collection-unimpaired-defvar-keymap org-previous-link-repeat-map
                  "l" #'org-previous-link
                  "L" #'org-next-link)
                (dolist (cmd '(org-forward-heading-same-level
                               org-backward-heading-same-level
                               org-babel-next-src-block
                               org-babel-previous-src-block
                               org-next-link
                               org-previous-link))
                        (put cmd 'repeat-map (intern (format "%s-repeat-map" cmd))))))
          '';
        };

        evil-org-agenda = lib.mkIf ide.evil {
          enable = true;
          config = ''(evil-org-agenda-set-keys)'';
          deferIncrementally = true;
        };

        # org babel additions
        bash-ts-mode.babel = lib.mkIf ide.languages.bash.enable "shell";
        clojure-mode.babel = lib.mkIf ide.languages.clojure.enable "clojure";
        c-ts-mode.babel = lib.mkIf ide.languages.c.enable "C";

        ob-coffeescript = lib.mkIf ide.languages.coffeescript.enable {
          enable = true;
          after = ["org"];
          babel = "coffeescript";
        };

        lisp-mode = lib.mkIf ide.languages.common-lisp.enable {
          enable = true;
          babel = "lisp";
        };

        css-ts-mode.babel = lib.mkIf ide.languages.css.enable "css";
        elisp-mode.babel = lib.mkIf ide.languages.emacs-lisp.enable "emacs-lisp";
        forth-mode.babel = lib.mkIf ide.languages.forth.enable "forth";

        ob-go = lib.mkIf ide.languages.go.enable {
          enable = true;
          babel = "go";
        };

        groovy-mode.babel = lib.mkIf ide.languages.gradle.enable "groovy";
        haskell-mode.babel = lib.mkIf ide.languages.haskell.enable "haskell";

        ob-hy = lib.mkIf ide.languages.hy.enable {
          enable = true;
          babel = "hy";
        };

        java-ts-mode.babel = lib.mkIf ide.languages.java.enable "java";
        js-ts-mode.babel = lib.mkIf ide.languages.javascript.enable "js";

        ob-kotlin = lib.mkIf ide.languages.kotlin.enable {
          enable = true;
          babel = "kotlin";
        };

        latex.babel = lib.mkIf ide.languages.latex.enable "latex";
        lua-ts-mode.babel = lib.mkIf ide.languages.lua.enable "lua";

        ob-nix = lib.mkIf ide.languages.nix.enable {
          enable = true;
          babel = "nix";
        };

        plantuml-mode.babel = lib.mkIf ide.languages.plantuml.enable "plantuml";

        ob-prolog = lib.mkIf ide.languages.prolog.enable {
          enable = true;
          babel = "prolog";
        };

        python-ts-mode.babel = lib.mkIf ide.languages.python.enable "python";
        ess-r-mode.babel = lib.mkIf ide.languages.r.enable "R";
        ruby-ts-mode.babel = lib.mkIf ide.languages.ruby.enable "ruby";
        scheme-mode.babel = lib.mkIf ide.languages.scheme.enable "scheme";
        sql-mode.babel = lib.mkIf ide.languages.sql.enable "sql";
        typescript-ts-mode.babel = lib.mkIf ide.languages.typescript.enable "typescript";
      };
   };
}
#+end_src

**** Vimscript
#+begin_src nix :tangle language-support/vimscript.nix
{ pkgs, config, lib, ... }:

let
  ide = config.programs.emacs.init.ide;
in
{
  options.programs.emacs.init.ide.languages.vimscript.enable = lib.mkEnableOption "Enables support for vimscript, because why not?";

  config.programs.emacs.init.usePackage.vimscript-ts-mode = lib.mkIf ide.languages.vimscript.enable {
    enable = true;
    mode = [''"\\.vim\\'"''];
    extraPackages = lib.mkIf (ide.eglot.enable || ide.lsp.enable || ide.lspce.enable || ide.lsp-bridge.enable) [pkgs.vim-language-server];
    eglot = lib.mkIf ide.eglot.enable ''("vim-language-server" "--stdio")'';
    lsp = ide.lsp.enable;
    lspce = ide.lspce.enable;
    config = lib.mkIf ide.lspce.enable ''(with-eval-after-load 'lspce (add-to-list 'lspce-server-programs '("vimscript" "vim-language-server" "--stdio")))'' ;
  };
}
#+end_src

**** Ledger
#+begin_src nix :tangle language-support/ledger.nix
{ pkgs, config, lib, ... }:

let
  ide = config.programs.emacs.init.ide;
in
{
  options.programs.emacs.init.ide.languages.ledger.enable = lib.mkEnableOption "Enables support for ledger.";
  config.programs.emacs.init.usePackage.ledger = lib.mkIf ide.languages.ledger.enable {
    enable = true;
    package = epkgs: epkgs.ledger-mode;
    extraPackages = [pkgs.ledger];
    mode = [''("\\.ledger\\'" . ledger-mode)''];
  };
}
#+end_src


**** Julia
https://github.com/tree-sitter/tree-sitter-julia
#+begin_src nix :tangle language-support/julia.nix
{ pkgs, config, lib, ... }:

let
  ide = config.programs.emacs.init.ide;
in
{
  options.programs.emacs.init.ide.languages.julia.enable = lib.mkEnableOption "Enables support for julia (stolen from doom). No support for lspce.";

  config.programs.emacs.init.usePackage = lib.mkIf ide.languages.julia.enable {
    julia-ts-mode = {
      enable = true;
      mode = [''"\\.jl\\'"''];
      lsp = ide.lsp.enable;
      eglot = ide.eglot.enable;
    };

    julia-repl = {
      enable = true;
      hook = ["(julia-ts-mode . julia-repl-mode)"];
    };

    eglot-jl = lib.mkIf ide.eglot.enable {
      enable = true;
      after = ["eglot"];
      hook = ["(julia-ts-mode . (lambda () (setq-local eglot-connect-timeout (max eglot-connect-timeout 60))))"];
    };

    lsp-julia = lib.mkIf ide.lsp.enable {
      enable = true;
      after = ["lsp-mode"];
      config = ''
        (add-to-list 'lsp-language-id-configuration '(julia-ts-mode . "julia"))
        (lsp-register-client
          (make-lsp-client :new-connection (lsp-stdio-connection 'lsp-julia--rls-command)
                           :major-modes '(julia-mode ess-julia-mode julia-ts-mode)
                           :server-id 'julia-ls
                           :multi-root t))
      '';
    };
  };
}
#+end_src

*** Syntax Checking
**** Default.nix
#+begin_src nix :tangle syntax-checkers/default.nix
{ lib, ... }:

{
  imports = [
    ./flymake.nix
    ./flycheck.nix
  ];

  options.programs.emacs.init.ide = {
    flymake.enable = lib.mkEnableOption "Enables flymake for any languages that benefit from it.";
    flycheck.enable = lib.mkEnableOption "Enables flycheck for any languages that benefit from it.";
  };
}
#+end_src

**** Flymake
#+begin_src nix :tangle syntax-checkers/flymake.nix
{ config, lib, ... }:

let
  ide = config.programs.emacs.init.ide;
in
{
  options.programs.emacs.init.ide.flymake.preset = lib.mkEnableOption "Enables flymake's preset configuraiton.";

  config = lib.mkIf ide.flymake.preset {
    programs.emacs.init.usePackage = {
      flymake = {
        enable = true;
        custom.flymake-indicator-position = "'right-fringe";
        hook = lib.mkIf ide.languages.emacs-lisp.enable [''(flymake-mode . (lambda () (when (eq major-mode 'emacs-lisp-mode)
                                                                                            (setq-local eldoc-documentation-functions '(elisp-eldoc-var-docstring
                                                                                                                                        elisp-eldoc-funcall
                                                                                                                                        t)))))''
       ];
      };

      flymake-swi-prolog = lib.mkIf (ide.languages.prolog.enable && ide.flymake.enable) {
        enable = true;
        after = ["prolog-mode"]; 
        hook = ["(prolog-mode . flymake-mode)"];
      };

      flymake-popon = lib.mkIf (ide.hoverDoc && !ide.flycheck.preset) {
        enable = true;
        custom.flymake-popon-method = "'posframe";
        hook = ["(flymake-mode . flymake-popon-mode)"];
      };

      flyover.hook = lib.mkIf ide.flycheck.preset ["(flymake-mode . flyover-mode)"];

      eglot.hook = lib.mkIf ide.eglot.preset [''(eglot-managed-mode . (lambda () (setq-local eldoc-documentation-functions '(eglot-signature-eldoc-function
                                                                                                                             eglot-hover-eldoc-function
                                                                                                                             t
                                                                                                                             eglot-x-hover-eldoc-function))))''];
    };
  };
}
#+end_src

**** Flycheck
#+begin_src nix :tangle syntax-checkers/flycheck.nix
{ config, lib, ... }:

let
  ide = config.programs.emacs.init.ide;
in
{
  options.programs.emacs.init.ide.flycheck.preset = lib.mkEnableOption "Enables flycheck's preset options (largely borrowed from doom)";

  config = lib.mkIf ide.flycheck.preset {
    programs.emacs = {
      extraPackages = epkgs: [epkgs.on];
      init.usePackage = {
        flycheck = {
          enable = true;
          hook = ["(on-first-buffer . global-flycheck-mode)"];
          extraConfig = '':preface (require 'on)'';
          custom = {
            flycheck-idle-change-delay = "1.0";
            flycheck-buffer-switch-check-intermediate-buffers = true;
            flycheck-display-errors-delay = "0.25";
          };
        };

        flycheck-posframe = lib.mkIf ide.hoverDoc {
          enable = true;
          hook = ["(flycheck-mode . flycheck-posframe-mode)"];
        };

        flycheck-eglot = lib.mkIf ide.eglot.preset {
          enable = true;
          after = ["flycheck" "eglot"];
          config = "(global-flycheck-eglot-mode)";
        };

        eglot.custom.eglot-stay-out-of = lib.mkIf ide.eglot.preset (lib.mkDefault "'(flymake)");
      };
    };
  };
}
#+end_src

*** Project Management
**** Default.nix
#+begin_src nix :tangle project-management/default.nix
{ ... }:

{
  imports = [
    ./project.nix
    ./projectile.nix
  ];
}
#+end_src

**** Project
#+begin_src nix :tangle project-management/project.nix
{ pkgs, config, lib, ... }:

{
  options.programs.emacs.init.ide.project = lib.mkEnableOption "Enables project.el for project management. Projection is used to provide quick build options";

  config.programs.emacs.init.usePackage = lib.mkIf config.programs.emacs.init.ide.project {
    project = {
      enable = true;
      custom.project-vc-extra-root-markers = '''("Cargo.toml" "?*.cabal" "build.gradle" "?*.csproj" "?*.fsproj" "?*.sln" "?*.nimble" "go.work" "go.mod" "*.go" "Taskfile.yml" "SConstruct" "meson.build" "default.nix" "flake.nix" "WORKSPACE" "configure.ac" "configure.in" "CMakeLists.txt" "composer.json" "rebar.config" "mix.exs" "Gruntfile.js" "gulpfile.js" "yarn.lock" "pnpm-lock.yaml" "package.json" "angular.json" "manage.py" "requirements.txt" "setup.py" "pyproject.toml" "tox.ini" "Pipfile" "poetry.lock" "pom.xml" "build.gradle.kts" "application.yml" "build.sbt" "build.sc" "project.clj" "build.boot" "deps.edn" ".bloop" "Gemfile" "shard.yml" "Cask" "Eask" "Eldev" "DESCRIPTION" "stack.yaml" "info.rkt" "pubspec.yaml" "elm.json" "Project.toml" """dune-project")'';
    };

    projection-multi = {
      enable = true;
      bindLocal.project-prefix-map."RET" = "projection-multi-compile";
      config = ''
        (require 'projection)
        (global-projection-hook-mode)
        (oset projection-project-type-maven build "mvn -B clean compile")
      '';
    };
  };
}
#+end_src

**** Projectile
#+begin_src nix :tangle project-management/projectile.nix
{ pkgs, config, lib, ... }:

{
  options.programs.emacs.init.ide.projectile = lib.mkEnableOption "Enables projectile support";

  config.programs.emacs.init.usePackage = lib.mkIf config.programs.emacs.init.ide.projectile {
    projectile = {
      enable = true;
      custom = {
        projectile-per-project-compilation-buffer = lib.mkDefault true;
        projectile-auto-discover = lib.mkDefault true;
      };
      extraPackages = [pkgs.fd];
      config = "(projectile-mode)";
      bind."C-c p" = "projectile-commander";
    };

    ripgrep = {
      enable = true;
      extraPackages = [pkgs.ripgrep];
    };
  };
}
#+end_src

** File Management
I'm running dired with a couple of small packages that improve on it
#+begin_src nix :noweb yes :tangle emacs/file-management.nix
  { inputs, ... }:

  {
    programs.emacs.init.usePackage = {
      dired = {
        enable = true;
        gfhook = ["('dired-mode-hook (list 'dired-omit-mode 'hl-line-mode (lambda () (setq-local
        visible-cursor nil))))"];
        general = {
          "C-x C-j" = "'dired-jump";
          "C-x d" = "'consult-dir";
        };
        generalOne."efs/leader-keys"."d" = '''(dired :which-key "dired")'';
        generalTwo."'normal".dired-mode-map."w" = "'wdired-change-to-wdired-mode";
        custom = {
          dired-recursive-deletes = "'always";
          dired-listing-switches = ''"-agho --group-directories-first"'';
          # We're doing our best to get rid of that 1st extraneous line
          dired-free-space = false;
        };
        config = ''(with-eval-after-load 'dired-x (gsetq dired-omit-extensions (delete ".class" dired-omit-extensions)))'';
      };

      openwith = {
        enable = true;
        defer = true;
        ghook = ["('dired-mode-hook 'openwith-mode)"];
        config = ''
          <<Emacs Openwith Config>>
        '';
      };

      dired-hide-dotfiles = {
        enable = true;
        defer = true;
        ghook = ["('dired-mode-hook 'dired-hide-dotfiles-mode)"];
        config = ''(general-def 'normal dired-mode-map "H" 'dired-hide-dotfiles-mode)'';
      };

      all-the-icons-dired = {
        enable = true;
        ghook = ["('dired-mode-hook 'all-the-icons-dired-mode)"];
      };

      dired-single = {
        enable = true;
        ghook = [''
          ('dired-mode-hook (lambda () (general-def 'normal dired-mode-map
               "B" 'evil-goto-line
               "n" 'dired-single-prev
               "i" 'dired-single-next)))
        ''];
      };

      dired-ranger = {
        enable = true;
        ghook = [''
          ('dired-mode-hook (lambda () (general-def 'normal dired-mode-map
               "d" 'dired-ranger-copy
               "O" 'dired-ranger-move
               "G" 'dired-ranger-paste)))
        ''];
      };

      diredfl = {
        enable = true;
        ghook = ["('dired-mode-hook 'diredfl-mode)"];
      };

      dired-posframe = {
        enable = true;
        generalTwo."'normal".dired-mode-map."M-t" = "'dired-posframe-mode";
      };
      
      image = {
        enable = true;
        gfhook = ["('image-mode-hook 'image-transform-fit-to-window)"];
        generalTwo."'normal".image-map = {
          "E" = "'image-next-file";
          "O" = "'image-previous-file";
        };
        custom.image-animate-loop = true;
      };

      dired-narrow = {
        enable = true;
        generalTwo."'normal".dired-mode-map."N" = "'dired-narrow-fuzzy";
      };
    };
  }
#+end_src

#+NAME: Emacs Openwith Config
#+begin_src emacs-lisp
  (gsetq openwith-associations
       (list
        (list (openwith-make-extension-regexp
               '("ff"))
              "lel"
              '(file))
        (list (openwith-make-extension-regexp
               '("odt" "doc" "docx" "odp" "pptx" "xlsx"))
              "libreoffice"
              '(file))
        (list (openwith-make-extension-regexp
               '("mpg" "mpeg" "mp3" "mp4"
                 "avi" "wmv" "wav" "mov" "flv"
                 "ogm" "ogg" "mkv" "webm" "opus"
                 "flac"))
              "mpv"
              '(file))))

  (defun dired-do-async-delete (&optional arg)
    "Delete all marked (or next ARG) files.
  `dired-recursive-deletes' controls whether deletion of
  non-empty directories is allowed."
    ;; This is more consistent with the file marking feature than
    ;; dired-do-flagged-delete.
    (interactive "P")
    (let (markers)
      (dired-internal-do-deletions
       (nreverse
        ;; this may move point if ARG is an integer
        (dired-map-over-marks (cons (dired-get-filename)
                                    (let ((m (point-marker)))
                                      (push m markers)
                                      m))
                              arg))
       arg t)
      (async-start (lambda ()
  		   (dolist (m markers) (set-marker m nil)))
  		 'ignore)))
#+end_src

** Emacs
*** Main
**** Inputs & Imports
#+begin_src nix :tangle emacs.nix :noweb yes
  { config, pkgs, inputs, ... }:

  {
    imports = [
      ./emacs/early-init.nix
      ./emacs/evil.nix
      ./emacs/file-management.nix
      ./emacs/help-system.nix
      ./emacs/completion-system.nix
      ./emacs/passwords.nix
      ./emacs/writing.nix
      ./emacs/window-manager.nix
    ];

    programs.emacs = {
      enable = true;
      package = pkgs.emacs30-gtk3;
      extraPackages = epkgs: with epkgs; [ 
        on
        repeaters
        hydra
        pretty-hydra
      ];
      init = {
        enable = true;
        packageQuickstart = false;
        recommendedGcSettings = true;
        usePackageVerbose = false;
        largeFileHandling = true;

        <<Emacs Prelude>>

        usePackage = {

          <<Emacs UI Improvements>>

          <<Emacs Cleanup>>

          <<Emacs Doom Escape>>

          <<Emacs Async>>

          <<Emacs Wgrep>>

          <<Emacs Notifications>>
          
        };

        <<Emacs Postlude>>
      };
    };
  }
#+end_src

**** Prelude
#+NAME: Emacs Prelude
#+begin_src nix :noweb yes
    prelude =''
      <<emacs-prelude>>
    '';
#+end_src

#+NAME: emacs-prelude
#+begin_src emacs-lisp
(defalias 'gsetq #'general-setq)

(use-package on
  :demand t)

(general-create-definer efs/leader-keys
  :keymaps 'override
  :states '(emacs insert normal hybrid motion visual operator)
  :prefix "SPC"
  :global-prefix "C-SPC")

(efs/leader-keys
  "f" '(find-file :which-key "find or create file")
  ;; Help
  "h" '(:ignore t :which-key "help")
  "h." '(display-local-help :which-key "display local help")
  "h4" '(info-other-window :which-key "info other window")
  "hA" '((lambda () (interactive) (async-shell-command "${pkgs.wiki}/bin/wiki")) :which-key "arch wiki")
  "hC" '(describe-coding-system :which-key "describe coding system")
  "hD" '(view-emacs-debugging :which-key "emacs debugging")
  "hE" '(view-external-packages :which-key "external packages")
  "hF" '(describe-face :which-key "face")
  "hb" '(embark-bindings :which-key "display all keybinds")
  "hI" '(describe-input-method :which-key "describe input method")
  "hK" '(Info-goto-emacs-key-command :which-key "info: key command")
  "hL" '(describe-language-environment :which-key "describe language environment")
  "hP" '(describe-package :which-key "describe package")
  "hR" '(info-display-manual :which-key "info: manual")
  "hS" '(info-lookup-symbol :which-key "info: symbol")
  "hT" '(view-emacs-todo :which-key "things you can do to help emacs")
  "ha" '(about-emacs :which-key "about emacs")
  "hc" '(describe-key-briefly :which-key "short describe key")
  "hd" '(apropos-documentation :which-key "apropos documentation")
  "he" '(view-echo-area-messages :which-key "view echoed messages")
  "hh" '(help-for-help :which-key "help for help")
  "hl" '(view-lossage :which-key "lossage")
  "hn" '(view-emacs-news :which-key "emacs news")
  "hp" '(finder-by-keyword :which-key "finder by keyword")
  "hq" '(help-quit :which-key "help quit")
  "hr" '(info-emacs-manual :which-key "info: emacs")
  "hs" '(describe-syntax :which-key "describe syntax")
  "ht" '(help-with-tutorial :which-key "emacs tutor")
  "hw" '(where-is :which-key "find binds of command")
  "h C-f" '(view-emacs-FAQ :which-key "emacs FAQ")
  "h C-p" '(view-emacs-problems :which-key "view emacs problems")
  "h C-s" '(search-forward-help-for-help :which-key "search in help for help")
  "h C-m" '(describe-keymap :which-key "keymap")
  "l" '((lambda () (interactive) (if (project-current) (project-compile) (compile (read-string "Compile command: " "make -k")))) :which-key "compile")
  "L" '((lambda () (interactive) (if (project-current) (project-recompile) (recompile))) :which-key "recompile")
  ;; Mount/unmount drive
  "u" '((lambda () (interactive) (start-process-shell-command "udisksmenu" nil "${pkgs.udisksmenu}/bin/udisksmenu")) :which-key "mount/unmount drive"))

(general-unbind "C-h")

(general-create-definer local-leader
  :prefix "M-SPC"
  :states '(emacs insert normal hybrid motion visual operator))

(use-package hydra
  :defer t)

(use-package pretty-hydra
  :demand t
  :custom
  (hydra-hint-display-type 'posframe)
  :config
  (gsetq hydra-posframe-show-params '(:internal-border-width 1
							     :internal-border-color "003f28"
							     :parent-frame nil
							     :poshandler posframe-poshandler-frame-bottom-center
							     :refposhandler posframe-refposhandler-xwininfo))
  :gfhook ('doom-escape-hook 'hydra-keyboard-quit))

(use-package repeaters
  :demand t
  :config
  (repeaters-define-maps
   '(("next-error" ;; borrowed from the hydra wiki
      next-error "`"
      next-error "n"
      previous-error "e"))))

(use-package repeat
  :config
  (repeat-mode))

(general-def "H-z" 'repeat)
#+end_src

**** Sensible Defaults
***** UI Improvements
Most of this was shamelessly lifted from Emacs from Scratch.
Display buffer rules were taken from noctuid's config.
https://emacs.stackexchange.com/questions/75528/how-to-define-display-buffer-alist-to-keep-every-buffer-in-the-frame-it-is-curr
#+NAME: Emacs UI Improvements
#+begin_src nix :noweb yes
  tooltip = {
    enable = true;
    config = ''
      (tooltip-mode -1)
      (set-fringe-mode -1)
    '';
  };

  simple = {
    enable = true;
    config = ''
      (gsetq save-interprogram-paste-before-kill t)
      (column-number-mode)
    '';
  };

  display-line-numbers = {
    enable = true;
    custom = {
      display-line-numbers-type = "'relative";
      display-line-numbers-width = "3";
    }; 
    config = "(global-display-line-numbers-mode)";
    #Disable line numbers for some modes
    ghook = ["('(org-mode-hook term-mode-hook dired-mode-hook eww-mode-hook eat-mode-hook markdown-mode-hook help-mode-hook helpful-mode-hook Info-mode-hook Man-mode-hook shell-mode-hook pdf-view-mode-hook elfeed-search-mode-hook elfeed-show-mode-hook eshell-mode-hook racket-repl-mode-hook sage-shell-mode-hook) (lambda () (display-line-numbers-mode 0)))"];
  } ;

  elec-pair = {
    enable = true;
    ghook = ["('on-first-buffer-hook 'electric-pair-mode)"];
    custom.electric-pair-pairs = ''
     '((?\" . ?\")
       (?\[ . ?\])
       (?\( . ?\))
       (?\{ . ?\}))
    '';
    config = ''
      <<Emacs Electric Pair Config>>
    '';
  };

  server = {
    enable = true;
    deferIncrementally = true;
    config = "(server-start)";
  };
#+end_src

#+NAME: Emacs Electric Pair Config
#+begin_src emacs-lisp
  ;; < & > are not delimiters. Change my mind.
  ;; Courtesy of DT. https://gitlab.com/dwt1/configuring-emacs/-/tree/main/07-the-final-touches?ref_type=heads
  (gsetq electric-pair-inhibit-predicate `(lambda (c)
  					   (if (or (char-equal c ?<) (char-equal c ?>))
  					       t
  					       (,electric-pair-inhibit-predicate c))))
#+end_src

***** Cleanup
Emacs has a propensity for leaving garbage lying around. This configuration that I stole from David Wilson should make that stop.

#+NAME: Emacs Cleanup
#+begin_src nix
  no-littering = {
    enable = true;
    demand = true;
    #no-littering doesn't set this by default so we must place
    #auto save files in the same path as it uses for sessions
    custom.auto-save-file-name-transforms = ''`((".*" ,(no-littering-expand-var-file-name "auto-save/") t))'';
  };
#+end_src

**** Doom Escape
Credits: Doom Escape is from doom. (Wow)
#+NAME: Emacs Doom Escape
#+begin_src nix :noweb yes
  doom-escape = {
    enable = true;
    package = epkgs: epkgs.doom-utils;
    gfhook = ["('doom-escape-hook (list (lambda () (setq efs/vertico-active nil)) 'transient-quit-one))"];
    general."C-g" = "'doom/escape";
    config = ''
      <<Doom Escape Config>>
    '';
  };
#+end_src

#+NAME: Doom Escape Config
#+begin_src emacs-lisp
  (with-eval-after-load 'eldoc
    (eldoc-add-command 'doom/escape))
#+end_src

**** Async
Async lets emacs create other instances of itself to run functions. It still has to be passed back to the main instance, but it does help with the single-threadedness.
#+NAME: Emacs Async
#+begin_src nix :noweb yes
  async = {
    enable = true;
    config = ''
      <<Emacs Async Config>>
    '';
  };
#+end_src

#+NAME: Emacs Async Config
#+begin_src emacs-lisp
  (autoload 'dired-async-mode "dired-async.el" nil t)
  (dired-async-mode)
#+end_src

**** Wgrep
Wgrep basically turns grep into sed.

=Bindings=
+ C-c C-e: Apply changes
+ C-c C-u: Changes are unmarked & ignored
+ C-c C-d: Mark current line for deletion
+ C-c C-r: Remove changes in region
+ C-c C-p: Toggle read-only
+ C-c C-k: Exit without changes
+ C-x C-q: Exit wgrep
#+NAME: Emacs Wgrep
#+begin_src nix
  wgrep = {
    enable = true;
    custom.wgrep-auto-save-buffer = true;
    generalTwo."'normal".grep-mode-map."w" = "'wgrep-change-to-wgrep-mode";
  };
#+end_src

**** Notifications
Stolen from EDNC's github page.

EDNC does the same thing as dunst. It will pop up any new notifications inside of a text buffer.
#+NAME: Emacs Notifications
#+begin_src nix :noweb yes
  ednc = {
    enable = true;
    gfhook = [
      "('ednc-notification-presentation-functions #'show-notification-in-echo-area)"
    ];
    deferIncrementally = true;
    config = ''
      <<Emacs EDNC Config>>
    '';
  };
#+end_src

#+NAME: Emacs EDNC Config
#+begin_src emacs-lisp
  (ednc-mode)
  (defun show-notification-in-echo-area (old new)
    (when new (message (ednc-format-notification new t))))
#+end_src

**** Postlude
#+NAME: Emacs Postlude
#+begin_src nix :noweb yes
  postlude = ''
    <<Emacs Postlude Config>>
  '';
#+end_src

#+NAME: Emacs Postlude Config
#+begin_src emacs-lisp
  ;; Stolen from Derek Taylor's config.
  (add-to-list 'default-frame-alist '(alpha-background . 90))
  ;; Display buffer rules
  (cl-pushnew (list (rx "*Async Shell Command*" (0+ any)) #'display-buffer-no-window) display-buffer-alist)
  (cl-pushnew (list (rx "*Shell Command Output*" (0+ any)) #'display-buffer-no-window) display-buffer-alist)
#+end_src

*** Early Init
All of the repeaters config was origally stolen from Karthinks. I don't think any of the code I stole is actually here anymore, though.
#+begin_src nix :noweb yes :tangle emacs/early-init.nix
  { ... }:

  {
    programs.emacs.init = {
      earlyInit = ''
        <<Emacs Early Init>>
      '';
    };
  }
#+end_src

#+NAME: Emacs Early Init
#+begin_src emacs-lisp
  (scroll-bar-mode -1) ; Disable visible scrollbar
  (tool-bar-mode -1) ; Disable the toolbar
  (menu-bar-mode -1)

  (setq auto-save-visited-file-name t
        warning-minimum-level :error
        use-package-enable-imenu-support t
        make-backup-files nil
        enable-recursive-minibuffers t
        inhibit-startup-message t
        inhibit-startup-screen t
        visible-bell t
        use-short-answers t
        switch-to-buffer-obey-display-actions t
        ;; Scratch is an org mode buffer
        initial-major-mode 'org-mode
        initial-scratch-message ""
        ;;Reduce garbage
        user-emacs-directory "~/.cache/emacs")

  (defun efs/display-startup-time ()
    (message "Emacs loaded in %s with %d garbage collections."
             (format "%.2f seconds"
                     (float-time
                      (time-subtract after-init-time before-init-time)))
             gcs-done))

  (add-hook 'emacs-startup-hook #'efs/display-startup-time)
#+end_src

*** Evil Mode
My keybinds have been rearranged to work with Colemak. Evil is used for the purposes of ergonomics, & all my bindings revolve around it.

Evil mode provides vim-like keybinds.
#+begin_src nix :noweb yes :tangle emacs/evil.nix
  { inputs, ... }:

  {
    programs.emacs.init.usePackage = {
      <<Emacs Evil Main>>
      
      <<Emacs Evil Extensions>>
      
      <<Emacs Evil Symex>>
      
      <<Emacs Evil God State>>
      
      <<Emacs Evil Compats>>

      <<Emacs Evil Undo>>
    };
  }
#+end_src

**** TODO Main Config
+ [ ] ergovim keys
  https://emacs.stackexchange.com/questions/59223/how-to-assign-a-command-to-g-key-when-using-evil
https://www.hxa.name/articles/content/ergovim-key-mappings_hxa7241_2010.html
+ [X] Dashboard
+ [X] Easymotions
+ [X] What do we do about consult-yank-pop?
+ [ ] Symex
  Very messy
It should be noted that C-g quits out of insert mode. That, like most of this config, was taken from David Wilson's dotfiles.

Differences from the spec:
+ numbers & symbols aren't rebound

We used general to bind commonly used functions to the spacebar. It is partially based on the bindings in doom emacs.
M-SPC is our local leader, & it's used for keys specific to a given major mode
#+NAME: Emacs Evil Main
#+begin_src nix :noweb yes
evil = {
  enable = true;
  demand = true;
  gfhook = ["('doom-escape-hook 'evil-normal-state)"];
  general."M-u" = "'universal-argument";
  generalOne.universal-argument-map = {
    "M-u" = "'universal-argument-more";
    "C-u" = "'nil";
  };
  custom = {
    # Various settings to make it more like vim
    evil-want-integration = true;
    evil-want-keybinding = false;
    evil-want-minibuffer = true;
    evil-want-C-u-scroll = true;
    evil-want-C-w-delete = true;
    evil-want-C-u-delete = true;
    evil-want-C-h-delete = true;
    evil-want-C-i-jump = true;
    evil-move-cursor-back = false;
    evil-move-beyond-eol = true; # Combined with move-cursor-back, it prevents the cursor from moving behind a "/" when selecting a directory in the minibuffer
    evil-cross-lines = true;
    sentence-end-double-space = false;
  };
  generalOne = {
    "'insert" = {
      "C-s" = "'insert-char";
      "C-k" = "'kill-line";
    };
    "'normal"."C-s" = "'evil-write";
  };
  config = ''
      <<emacs-evil-config>>
    '';
};
#+end_src

#+NAME: emacs-evil-config
#+begin_src emacs-lisp
;; Initiate evil mode
(evil-mode)
(evil-ex-define-cmd "q" '(lambda () (interactive) (prescient--save) (save-buffers-kill-emacs)))
(evil-ex-define-cmd "Undotree" 'vundo)
(evil-ex-define-cmd "k[ill]" 'kill-current-buffer)
(evil-ex-define-cmd "trash" '(lambda () (interactive) (start-process-shell-command "rm" nil "rm -rf ~/.local/Trash")))
(gsetq evil-want-Y-yank-to-eol t)
(evil-set-undo-system 'undo-redo)

(evil-set-initial-state 'messages-buffer-mode 'normal)
(evil-set-initial-state 'dashboard-mode 'normal)
(general-advice-add '(evil-scroll-down evil-scroll-up evil-scroll-page-up evil-scroll-page-down) :after #'(lambda (arg) (evil-window-middle)))

(evil-add-command-properties #'flymake-goto-next-error :jump t)
(evil-add-command-properties #'flymake-goto-prev-error :jump t)
(evil-add-command-properties #'evil-scroll-up :jump t)
(evil-add-command-properties #'evil-scroll-down :jump t)
(evil-add-command-properties #'consult-grep :jump t)

(evil-define-operator ergo-word-delete (beg end type register yank-handler)
  "Delete word."
  :motion evil-a-word
  (evil-delete beg end type register yank-handler))

(evil-define-operator ergo-word-change (beg end type register yank-handler)
  "Delete word."
  :motion evil-inner-word
  (evil-change beg end type register yank-handler))

(general-def 'normal
  "i" 'evil-forward-char
  "I" 'evil-window-top
  "C-i" 'evil-goto-line
  "n" 'evil-backward-char
  "N" 'evil-window-bottom
  "C-n" 'evil-goto-first-line
  "E" 'evil-scroll-down
  "o" 'evil-previous-visual-line
  "O" 'evil-scroll-up
  "x" 'evil-backward-WORD-begin
  "X" 'evil-backward-word-begin
  "C-x" 'evil-backward-WORD-end
  "j" 'evil-undo
  "J" 'evil-redo
  "a" 'evil-ex
  "r" 'evil-insert-line
  "R" 'evil-open-above
  "s" 'evil-append-line
  "S" 'evil-open-below
  "t" 'evil-insert
  "T" 'evil-append
  "C-t" 'evil-replace-state
  "u" 'evil-forward-WORD-begin
  "U" 'evil-forward-word-begin
  "C-u" 'evil-forward-WORD-end
  "-" 'evil-jump-backward
  "_" 'evil-jump-forward
  "m" 'evil-search-next
  "M" 'evil-search-previous
  "k" 'evil-delete-char
  "K" 'evil-substitute
  "l" 'evil-invert-char
  "L" 'evil-invert-case
  "c" 'evil-visual-char
  "C" 'evil-visual-line
  "C-c" 'evil-visual-block
  "v" 'evil-delete
  "V" 'evil-change
  "C-v" 'evil-delete-line
  "d" 'evil-yank
  "D" 'evil-yank-line
  "G" 'evil-paste-after
  ";" 'evil-end-of-visual-line
  ":" 'evil-end-of-line
  "C-;" 'evil-end-of-line
  "p" 'ergo-word-delete
  "P" 'ergo-word-change
  "C-p" 'ergo-word-change
  "$" 'evil-execute-macro
  "~" 'evil-record-macro
  "C-z" 'evil-goto-last-change-reverse
  "w" 'evil-repeat
  "W" 'evil-ex-repeat
  "C-w" 'evil-ex-repeat
  "l" 'evil-shift-right-line
  "L" 'evil-shift-left-line
  "C-l" 'evil-shift-left-line
  "y" 'evil-shift-right
  "Y" 'evil-shift-left
  "<escape>" 'doom/escape)
  

(general-def 'motion
  "i" 'evil-forward-char
  "I" 'evil-window-top
  "C-i" 'evil-goto-line
  "n" 'evil-backward-char
  "N" 'evil-window-bottom
  "C-n" 'evil-goto-first-line
  "e" 'evil-next-visual-line
  "C-e" 'evil-scroll-page-down
  "o" 'evil-previous-visual-line
  "C-o" 'evil-scroll-page-up
  "a" 'evil-ex
  "h" 'evil-set-marker
  "m" 'evil-search-next
  "M" 'evil-search-previous
  "-" 'evil-jump-backward
  "_" 'evil-jump-forward
  "/" 'isearch-forward-regexp
  "?" 'isearch-backward-regexp
  "f" 'evil-first-non-blank-of-visual-line
  "F" 'evil-beginning-of-visual-line
  "C-f" 'evil-first-non-blank
  "B" 'evil-goto-line)

(general-swap-key nil '(motion normal visual)
  "g" "b"
  "z" "q"
  "Z" "Q")

(general-def
  :keymaps 'override
  :states '(normal visual)
  "g" 'evil-paste-before
  "z" 'evil-jump-item
  "Z" 'evil-goto-last-change)

(general-def
  :keymaps 'override
  :states '(operator visual)
  "i" 'evil-forward-char
  "s" evil-inner-text-objects-map
  "t" evil-outer-text-objects-map)

(general-def 'visual
  "o" 'evil-previous-visual-line
  "e" 'evil-next-visual-line
  ;; "n" 'evil-backward-char
  ;; "i" 'evil-forward-char
  "U" 'evil-forward-word-begin
  "u" 'evil-forward-WORD-begin
  "X" 'evil-backward-word-begin
  "x" 'evil-backward-WORD-begin
  "v" 'evil-delete-char
  "V" 'evil-substitute
  "C-v" 'evil-substitute
  "t" evil-outer-text-objects-map
  "s" evil-inner-text-objects-map
  "l" 'evil-invert-case
  "y" 'evil-shift-right
  "Y" 'evil-shift-left
  "C-t" 'evil-replace
  "R" 'evil-insert-line
  "C-r" 'evil-append-line
  "d" 'evil-yank-line
  "D" 'evil-yank-line
  "C-d" 'evil-yank-line
  "G" 'evil-paste)

(general-def 'normal "bl" '(consult-goto-line :which-key "go to line")
  "b/" '(consult-keep-lines :which-key "delete non-matching lines"))
#+end_src

**** Extensions
Evil-snipe is used to make jumping more efficient.
Easymotion's prefix is M-SPC, however, most important keys are already bound somewhere easier.
Repeat map idea: https://hungyi.net/posts/hydra-for-evil-mc/
#+NAME: Emacs Evil Extensions
#+begin_src nix :noweb yes
  evil-collection = {
    enable = true;
    custom.evil-collection-unimpaired-want-repeat-mode-integration = true;
    config = ''
      <<Emacs Evil Collection Config>>
    '';
  };

  evil-surround = {
    enable = true;
    deferIncrementally = true;
    config = ''
      <<Emacs Evil Surround Config>>
    '';
  };

  evil-easymotion = {
    enable = true;
    generalOne = {
      "'operator" = {
       "/" = "'evil-avy-goto-char-2"; 
       "?" = "'evil-avy-goto-char-2"; 
      };
      "(normal visual operator)" = {
        "H-m" = "'evilem-motion-search-next";
        "H-U" = "'evilem-motion-forward-word-begin";
        "H-u" = "'evilem-motion-forward-WORD-begin";
        "H-X" = "'evilem-motion-backward-word-begin";
        "H-x" = "'evilem-motion-backward-WORD-begin";
        "H-M" = "'evilem-motion-search-previous";
        "H-e" = "'evilem-motion-next-visual-line";
        "H-o" = "'evilem-motion-previous-visual-line";
      };
    };
    custom = {
      avy-dispatch-alist = ''
        '((?m . avy-action-cursor)
  			  (?l . avy-action-ispell)
  			  (?o . avy-action-embark)
  			  (?h . avy-action-helpful)
  			  (?g . avy-action-yank)
  			  (?p . avy-action-teleport)
  			  (?q . avy-action-fold))
      '';
      avy-keys = "'(?c ?r ?s ?t ?b ?f ?n ?e ?i ?a)";
    };
    config = ''
      <<Emacs Evil Easymotion Config>>
    '';
  };

  evil-nerd-commenter = {
    enable = true;
    defer = true;
    generalOne."efs/leader-keys" = {
      "c" = '''(:ignore t :which-key "comment")'';
      "ci" = '''(evilnc-comment-or-uncomment-lines :which-key "comment line")'';
      "cl" = '''(evilnc-quick-comment-or-uncomment-paragraphs :which-key "comment paragraph")'';
      "cc" = '''(evilnc-copy-and-comment-lines :which-key "copy & comment lines")'';
      "cp" = '''(evilnc-comment-or-uncomment-paragraphs :which-key comment paragraph)'';
      "cr" = '''(comment-or-uncomment-region :which-key "comment region")'';
      "cv" = '''(evilnc-toggle-invert-comment-line-by-line :which-key "invert comments")'';
      "cy" = '''(evilnc-copy-and-comment-operator :which-key "copy & comment operator")'';
      "co" = '''(evilnc-comment-operator :which-key "copy operator")'';
    };
  };

  evil-mc = {
    enable = true;
    defer = true;
    command = ["evil-mc-pause-cursors" "evil-mc-make-cursor-here"];
    generalOne = {
      "'(normal visual)"."bz" = "'evil-mc-hydra/body";
      "efs/leader-keys"."C" = "'evil-mc-hydra/body";
    };
    config = ''
      <<Emacs Evil-MC Config>>
    '';
    extraConfig = ''
      :pretty-hydra
      ((:color pink :pre (evil-mc-pause-cursors))
       ("Search"
        (("m" #'evil-mc-make-and-goto-next-match "Search forward")
         ("M" #'evil-mc-make-and-goto-prev-match "Search backward")
         ("C-m" #'evil-mc-skip-and-goto-next-match "Skip forward")
         ("C-M" #'evil-mc-skip-and-goto-prev-match "Skip backward"))
        "Undo"
        (("q" #'evil-mc-undo-all-cursors)
         ("j" #'evil-mc-undo-last-added-cursor))
        "Pause/Resume"
        (("r" #'evil-mc-resume-cursors "Resume")
         ("p" #'evil-mc-pause-cursors "Pause")
         ("<return>" #'evil-mc-resume-cursors "Quit" :color blue))
        "Create Cursors"
        (("h" #'evil-mc-make-all-cursors "All")
         ("s" #'evil-mc-make-cursor-here "Here")
         ("E" #'evil-mc-make-cursor-move-next-line "Next Line")
         ("O" #'evil-mc-make-cursor-move-prev-line "Prev Line"))))
    '';
  };
#+end_src

#+NAME: Emacs Evil Collection Config
#+begin_src emacs-lisp
  (defun my-hjkl-rotation (_mode mode-keymaps &rest _rest)
    (evil-collection-translate-key 'normal mode-keymaps
      "e" "j"
      "o" "k"
      "i" "l"
      "n" "h"
      "x" "B"
      "X" "b"
      "u" "W"
      "U" "w"
      "j" "u"
      "a" ":"
      "m" "n"
      "M" "N"
      "h" "m"
      "b" "g"))
  (general-add-hook 'evil-collection-setup-hook #'my-hjkl-rotation)
  (evil-collection-init)
#+end_src

#+NAME: Emacs Evil Surround Config
#+begin_src emacs-lisp
  (general-def 'visual evil-surround-mode-map "R" 'evil-surround-region)
  (general-def 'operator evil-surround-mode-map
    "s" nil
    "r" 'evil-surround-edit
    "R" 'evil-Surround-edit)
  (global-evil-surround-mode)
#+end_src

#+NAME: Emacs Evil Easymotion Config
#+begin_src emacs-lisp
  ;; Stolen from karthink
  (defun avy-action-cursor (pt)
    (save-excursion
      (goto-char pt)
      (evil-mc-make-cursor-here))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-helpful (pt)
    (save-excursion
      (goto-char pt)
      (helpful-at-point))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-fold (pt)
    (save-excursion
      (goto-char pt)
      (evil-toggle-fold))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
#+end_src

#+NAME: Emacs Evil-MC Config
#+begin_src emacs-lisp
  (global-evil-mc-mode)

  (general-add-hook 'doom-escape-hook (lambda () (when (evil-mc-has-cursors-p)
  						 (evil-mc-undo-all-cursors)
  						 (evil-mc-resume-cursors) t)))

  ;; Don't mess with my macros.
  ;; https://github.com/gabesoft/evil-mc/issues/83
  (gsetq evil-mc-cursor-variables
         (mapcar
  	(lambda (s)
  	  (remove 'register-alist
  		  (remove 'evil-markers-alist
  			  (remove evil-was-yanked-without-register s))))
  	evil-mc-cursor-variables))
#+end_src

**** Symex
Gives us an entire state where we can rapidly make specific edits to code.
#+NAME: Emacs Evil Symex
#+begin_src nix :noweb yes
  symex = {
    enable = true;
    defer = true;
    generalTwo."'normal"."(racket-repl-mode-map makefile-mode-map lisp-interaction-mode-map lisp-mode-map emacs-lisp-mode-map)"."RET" = "'symex-mode-interface";
    init = ''
      <<Emacs Symex Init>>    
    '';
    config = ''
      <<Emacs Symex Config>>    
    '';
  } ;
#+end_src

#+NAME: Emacs Symex Init
#+begin_src emacs-lisp
  (with-eval-after-load 'evil-easymotion
    (evilem-make-motion-plain evilem-symex-forward 'symex-traverse-forward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-backward 'symex-traverse-backward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-next-visual-line 'symex-next-visual-line :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-previous-visual-line 'symex-previous-visual-line :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-go-forward 'symex-go-forward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-go-backward 'symex-go-backward :post-hook 'symex-select-nearest-in-line))
  (gsetq symex--evil-keyspec
         '(("n" . symex-go-backward)
           ("e" . symex-go-down)
           ("o" . symex-go-up)
           ("i" . symex-go-forward)
           ("be" . symex-next-visual-line)
           ("bE" . evilem-symex-next-visual-line)
           ("bO" . evilem-symex-previous-visual-line)
           ("bo" . symex-previous-visual-line)
           ("(" . symex-create-round)
           ("[" . symex-create-square)
           (")" . symex-wrap-round)
           ("]" . symex-wrap-square)
           ("C-'" . symex-cycle-quote)
           ("C-," . symex-cycle-unquote)
           ("`" . symex-add-quoting-level)
           ("C-`" . symex-remove-quoting-level)
           ("u" . symex-traverse-forward)
           ("x" . symex-traverse-backward)
           ("C-u" . evilem-symex-forward)
           ("C-x" . evilem-symex-backward)
           ("U" . symex-traverse-forward-skip)
           ("X" . symex-traverse-backward-skip)
           ("{" . symex-leap-backward)
           ("}" . symex-leap-forward)
           ("M-{" . symex-soar-backward)
           ("M-}" . symex-soar-forward)
           ("C-o" . symex-climb-branch)
           ("C-e" . symex-descend-branch)
           ("C-n" . evilem-symex-go-backward)
           ("C-i" . evilem-symex-go-forward)
           ("d" . symex-yank)
           ("D" . symex-yank-remaining)
           ("G" . symex-paste-after)
           ("g" . symex-paste-before)
           ("k" . symex-delete)
           ("v" . symex-delete-backwards)
           ("V" . symex-delete-remaining)
           ("K" . symex-change)
           ("C-v" . symex-change-remaining)
           ("C--" . symex-clear)
           ("s" . symex-replace)
           ;; ("S" . symex-change-delimiter)
           ("N" . symex-shift-backward)
           ("I" . symex-shift-forward)
           ("M-N" . symex-shift-backward-most)
           ("M-I" . symex-shift-forward-most)
           ("O" . paredit-raise-sexp)	; revisit kb
           ("C-S-e" . symex-emit-backward)
           ("C-(" . symex-capture-backward)
           ("C-S-n" . symex-capture-backward)
           ("C-{" . symex-emit-backward)
           ("C-S-i" . symex-capture-forward)
           ("C-}" . symex-emit-forward)
           ("C-S-o" . symex-emit-forward)
           ("C-)" . symex-capture-forward)
           ("z" . symex-swallow)
           ("Z" . symex-swallow-tail)
           ("p" . symex-evaluate)
           ("B" . symex-evaluate-remaining)
           ("C-M-j" . symex-evaluate-pretty)
           ("d" . symex-evaluate-definition)
           ("M-j" . symex-eval-recursive)
           ;; ("T". symex-evaluate-thunk)
           ;; ("t" . symex-switch-to-scratch-buffer)
           ("H" . symex-switch-to-messages-buffer)
           ("l" . symex-repl)
           ("L" . symex-run)
           ("|" . symex-split)
           ("&" . symex-join)
           ("-" . symex-splice)
           ("S" . symex-open-line-after)
           ("R" . symex-open-line-before)
           (">" . symex-insert-newline)
           ("<" . symex-join-lines-backwards)
           ("C->" . symex-append-newline)
           ("C-<" . symex-join-lines)
           ("C-S" . symex-append-newline)
           ("E" . symex-join-lines)
           ("M-E" . symex-collapse)
           ("M-<" . symex-collapse)
           ("M->" . symex-unfurl)
           ("C-M-<" . symex-collapse-remaining)
           ("C-M->" . symex-unfurl-remaining)
           ("0" . symex-goto-first)
           ("M-n" . symex-goto-first)
           ("$" . symex-goto-last)
           ("M-i" . symex-goto-last)
           ("M-e" . symex-goto-lowest)
           ("M-o" . symex-goto-highest)
           ("=" . symex-tidy)
           ("<tab>" . symex-tidy)
           ("C-=" . symex-tidy-remaining)
           ("C-<tab>" . symex-tidy-remaining)
           ("M-=" . symex-tidy-proper)
           ("M-<tab>" . symex-tidy-proper)
           ("s" . symex-append-after)
           ("T" . symex-insert-at-end)
           ("t" . symex-insert-at-beginning)
           ("r" . symex-insert-before)
           ("w" . symex-wrap)
           ("W" . symex-wrap-and-append)
           ("C-d" . symex--evil-scroll-down)
           (";" . symex-comment)
           ("M-;" . symex-comment-remaining)
           ("C-;" . symex-eval-print)	; weird pre-offset (in both)
           ("s-;" . symex-evaluate)
           ("H-h" . symex--toggle-highlight) ; treats visual as distinct mode
           ("C-?" . symex-describe)
           ("<return>" . symex-enter-lower)
           ("<escape>" . symex-escape-higher)))
#+end_src

#+NAME: Emacs Symex Config
#+begin_src emacs-lisp
  (gsetq symex-modal-backend 'evil)
  (symex-initialize)
  (repeaters-define-maps
   '(("symex-visual-line"
      symex-next-visual-line "e"
      symex-previous-visual-line "o")))

#+end_src

**** God State
God state lets you use emacs bindings faster, & without hanging on modifier keys.
By default, any key pressed while in god state is treated as if it was pressed with control.

=bindings:=
+ SPC- removes control
+ g- switches from control to meta
+ G- switches from just control to control & meta
+ ,- enter god state
+ ESC- exit god state
#+NAME: Emacs Evil God State
#+begin_src nix
  evil-god-state = {
    enable = true;
    defer = true;
    command = ["evil-god-state"];
    gfhook = ["('doom-escape-hook 'evil-god-state-bail)"];
    generalOne = {
      "'normal"."," = "'evil-execute-in-god-state";
      "'emacs"."<escape>" = "'evil-god-state";
      evil-god-state-map = {
        "<escape>" = "'evil-god-state-bail";
        "<return>" = "'evil-emacs-state";
      };
    };
  };
#+end_src

**** Compats
#+NAME: Emacs Evil Compats
#+begin_src nix :noweb yes
  evil-org = {
    custom.evil-org-movement-bindings = ''
      '((up . "o")
        (down . "e")
        (left . "n")
        (right . "i"))
    '';
    config = ''
      <<Emacs Evil Org Config>>
    '';
  };

  evil-org-agenda = {
    generalTwo."'motion".evil-org-agenda-mode-map = {
      "e" = "'org-agenda-next-line";
      "o" = "'org-agenda-previous-line";
      "bn" = "'org-agenda-next-item";
      "be" = "'org-agenda-previous-item";
      "bI" = "'evil-window-bottom";
      "C-e" = "'org-agenda-next-item";
      "C-o" = "'org-agenda-previous-item";
      "E" = "'org-agenda-priority-down";
      "O" = "'org-agenda-priority-up";
      "I" = "'org-agenda-do-date-later";
      "M-e" = "'org-agenda-drag-line-forward";
      "M-o" = "'org-agenda-drag-line-backward";
      "C-S-i" = "'org-agenda-todo-nextset"; # Original binding "C-S-<right>"
      "l" = "'org-agenda-diary-entry";
    };
    generalOne."efs/leader-keys"."oa" = '''(org-agenda :which-key "agenda")'';
  };

  evil-markdown.custom.evil-markdown-movement-bindings = ''
      '((up . "o")
        (down . "e")
        (left . "n")
        (right . "i"))
  '';

  ewal-evil-cursors = {
    enable = true;
    demand = true;
    config = ''(ewal-evil-cursors-get-colors :apply t)'';
  };
#+end_src

#+NAME: Emacs Evil Org Config
#+begin_src emacs-lisp
  (evil-define-key 'operator 'evil-org-mode
    "i" 'evil-forward-char)
  (evil-define-key 'normal 'evil-org-mode
    "o" 'evil-previous-visual-line
    "O" 'evil-scroll-up
    "R" 'evil-org-open-above
    "S" 'evil-org-open-below
    "x" 'evil-backward-WORD-begin
    "d" 'evil-yank
    "M-e" 'evilem-motion-next-visual-line
    "M-o" 'evilem-motion-previous-visual-line)
  (evil-define-key 'visual 'evil-org-mode
    "i" 'evil-forward-char
    "s" evil-inner-text-objects-map)
#+end_src

**** Undo
Undo-Fu lets us have linear undos. It's our undo system in evil
#+NAME: Emacs Evil Undo
#+begin_src nix
  undo-fu = {
    enable = true;
    custom.undo-fu-session-compression = "'zst";
    afterCall = ["on-first-buffer-hook"];
    config = ''(gsetq evil-undo-system 'undo-fu)'';
  };
#+end_src

*** Completion System
My completions system is based around vertico, because that's what all the cool kids use nowadays.
#+begin_src nix :noweb yes :tangle emacs/completion-system.nix
  { inputs, pkgs, ... }:

  {
    <<Emacs Templates File>>

    programs.emacs.init.usePackage = {
      <<Emacs Vertico>>
      
      <<Emacs Corfu>>

      <<Emacs Prescient>>

      <<Emacs Orderless>>

      <<Emacs Marginalia>>

      <<Emacs Consult Main Package>>

      <<Emacs Consult Extensions>>

      <<Emacs Embark>>

      <<Emacs App Launcher>>

      <<Emacs Search>>

      <<Emacs Snippets>>

      <<Emacs Ezf>>
    };
  }
#+end_src

**** Vertico
Vertico is basically dmenu for emacs. It lists out all the options in a command menu.
#+NAME: Emacs Vertico
#+begin_src nix :noweb yes
  vertico = {
    enable = true;
    defer = true;
    ghook = ["('on-first-input-hook 'vertico-mode)"];
    # Enable cycling for 'vertico-next & 'vertico-previous'.
    custom.vertico-cycle = true;
    # This is for exwm's minibuffer issue
    generalTwo."'normal".vertico-map = {
      "RET" = "'vertico-exit";
      "C-o" = "'vertico-scroll-down";
      "C-e" = "'vertico-scroll-up";
      "e" = "'vertico-next";
      "o" = "'vertico-previous";
      "I" = "'vertico-last";
      "N" = "'vertico-first";
      "B" = "'vertico-last";
      "bg" = "'vertico-first";
    };
  };

  vertico-quick = {
    enable = true;
    defer = true;
    generalTwo."'normal".vertico-map = {
      "H-o" = "'vertico-quick-jump";
      "H-e" = "'vertico-quick-jump";
    };
  };
#+end_src

**** Corfu
I took a lot of this from Gavin Freeborn's config
#+NAME: Emacs Corfu
#+begin_src nix :noweb yes
  corfu = {
    enable = true;
    ghook = [
      "('minibuffer-setup-hook 'corfu-enable-in-minibuffer)"
      "('on-first-buffer-hook 'global-corfu-mode)"
    ];
    custom = {
      corfu-cycle = true;
      corfu-autodelay = "0";
      corfu-auto-prefix = "2";
      corfu-auto = true;
      corfu-on-exact-match = "'show";
    };
    general."M-/" = "'completion-at-point";
    generalOne.corfu-map = {
      "RET" = "nil";
      "TAB" = "nil";
      "S-<return>" = "'corfu-insert";
      "[tab]" = "nil";
    };
    generalTwo."'(insert emacs)".corfu-map = {
      "S-SPC" = "'corfu-insert-separator";
      "C-e" = "'corfu-next";
      "C-p" = "nil";
      "C-o" = "'corfu-previous";
    };
    config = ''
      <<Emacs Corfu Config>>
    '';
  };

  nerd-icons-corfu = {
    enable = true;
    config = ''(add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)'';
    after = ["corfu"];
  };

  corfu-quick = {
    enable = true;
    generalTwo."'(insert emacs)".corfu-map = {
      "M-o" = "'corfu-quick-insert";
      "M-e" = "'corfu-quick-insert";
    };
  };

  corfu-popupinfo = {
    enable = true;
    ghook = ["('corfu-mode-hook 'corfu-popupinfo-mode)"];
  };

  cape = {
    enable = true;
    after = ["corfu"];
    config = ''
      <<Emacs Cape Config>>
    '';
  };
#+end_src

#+NAME: Emacs Corfu Config
#+begin_src emacs-lisp
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer."
    (when (local-variable-p 'completion-at-point-functions)
      (setq-local corfu-auto t) ;; Enable/disable auto completion
      (corfu-mode 1)))
#+end_src

#+NAME: Emacs Cape Config
#+begin_src emacs-lisp
  (dolist (src (list 'cape-dabbrev 'cape-file))
          (add-to-list 'completion-at-point-functions src))
#+end_src

**** Prescient
Prescient is a big-braned history package that orders completion options by recency & frequency.
#+NAME: Emacs Prescient
#+begin_src nix
  prescient = {
    enable = true;
    defer = true;
    config = ''(prescient-persist-mode)'';
    custom.prescient-history-length = "100";
    afterCall = ["on-first-input-hook"];
  };

  vertico-prescient = {
    enable = true;
    defer = true;
    ghook = ["('minibuffer-mode-hook 'vertico-prescient-mode)"];
    custom = {
      vertico-prescient-enable-filtering = false;
      vertico-prescient-completion-styles = "'(orderless prescient basic)";
      vertico-prescient-enable-sorting = true;
    };
  };

  corfu-prescient = {
    enable = true;
    defer = true;
    ghook = ["('corfu-mode-hook 'corfu-prescient-mode)"];
    custom.corfu-prescient-completion-styles = "'(basic prescient)";
  };
#+end_src

**** Orderless
Orderless basically turns the completion system into a fuzzy finder. It's here to help me sift through my notes.
This config is stolen directly from David Wilson
#+NAME: Emacs Orderless
#+begin_src nix
  orderless = {
    enable = true;
    defer = true;
    custom = {
      completion-styles = "'(orderless prescient basic)";
      completion-category-defaults = false;
      completion-category-overrides = "'((file (styles . (partial-completion))))";
    };
    afterCall = ["on-first-input-hook"];
  };
#+end_src

**** Marginalia
Marginalia provides extra information on the options in a vertico completion, that way you know what you're getting ahead of time.
#+NAME: Emacs Marginalia
#+begin_src nix
  marginalia = {
    enable = true;
    defer = true;
    config = ''(marginalia-mode)'';
    afterCall = ["on-first-input-hook"];
  };
#+end_src

**** Consult
***** Main Package
Replaces a bunch of commands with new commands.
Evil integration is from noctuid & minad
#+NAME: Emacs Consult Main Package
#+begin_src nix :noweb yes
  consult = {
    enable = true;
    defer = true;
    extraPackages = with pkgs; [
      fd
      ripgrep
    ];
    ghook = ["('minibuffer-setup-hook 'consult-initial-narrow)"];
    command = ["consult-goto-line" "consult-keep-lines" "noct-consult-ripgrep-or-line"];
    general = {
      "C-x C-f" = "'consult-find";
      # https://taonaw.com/2025/05/15/two-eamcs-tweaks-i-forgot.html
      "C-c C-r" = "'consult-recent-file";
      "C-x b" = "'nil";
      "M-y" = "'nil";
      # C-c bindings (mode-specific-map)
      "C-c m" = "'consult-mode-command";
      "C-c k" = "'consult-kmacro";
      # C-x bindings (ctl-x-map)
      "C-x M-:" = "'consult-complex-command"; # orig. repeat-complex-command
      "C-x 5 b" = "'consult-buffer-other-frame"; # orig. switch-to-buffer-other-frame
      # Custom M-# bindings for fast register access
      "M-#" = "'consult-register-load";
      "M-'" = "'consult-register-store";       # orig. abbrev-prefix-mark (unrelated)
      "C-M-#" = "'consult-register";
      # M-g bindings (goto-map)
      "M-g e" = "'consult-compile-error";
      "M-g f" = "'consult-flymake"; # Alternative: consult-flycheck
      "M-g m" = "'consult-mark";
      "M-g k" = "'consult-global-mark";
      "M-g i" = "'consult-imenu-multi";
      # M-s bindings (search-map)
      "M-s D" = "'consult-locate";
      "M-s G" = "'consult-git-grep";
      "M-s g" = "'consult-ripgrep";
      "M-s m" = "'consult-multi-occur";
      "M-s u" = "'consult-focus-lines";
      # Isearch integration
      "M-s e" = "'consult-isearch-history"; # orig. isearch-edit-string
      "M-s L" = "'consult-line-multi"; # needed by consult-line to detect isearch
    };
    custom = {
      consult-buffer-sources = "'(consult--source-buffer)";
      xref-show-xrefs-function = "#'consult-xref";
    };
    generalOne = {
      "'normal" = {
        "?" = "'consult-line-multi";
        "H-m" = "'evil-collection-consult-mark";
        "M-g" = "'consult-yank-pop"; # orig. evil-paste-pop
        "M-E" = "'consult-isearch-history "; # orig. isearch-edit-string
      };  
      "efs/leader-keys" = {
         "b" = '''(consult-bookmark :which-key "bookmarks")'';
         "j" = '''(evil-collection-consult-jump-list :which-key "jump")'';
         "i" = '''consult-imenu'';
         "h C-a" = '''(consult-apropos :which-key "apropos")'';
         "h i" = '''(consult-info :which-key "info")'';
         "h M" = '''(consult-man :which-key "man")'';
      };
    };
    config = ''
      <<Emacs Consult Config>>
    '';
  } ;
#+end_src

#+NAME: Emacs Consult Config
#+begin_src emacs-lisp
  (defun efs/save-search-history (pattern)
  	"Gets history from pattern, & saves it where evil mode can find it"
  	(add-to-history 'evil-search-forward-history pattern)
  	(add-to-history 'search-ring pattern)
  	(add-to-history 'regexp-search-ring pattern)
  	(setq evil-ex-search-pattern (list pattern t t))
  	(setq evil-ex-search-direction 'forward)
  	(when evil-ex-search-persistent-highlight
            (evil-ex-search-activate-highlight evil-ex-search-pattern)))

  (defun noct-consult-line-evil-history (&rest _)
    "Add latest `consult-line' search pattern to the evil search history ring.
  This only works with orderless and for the first component of the search."
    (when (and (bound-and-true-p evil-mode)
               (eq evil-search-module 'isearch))
      (efs/save-search-history (cadr (orderless-compile
  				    (car consult--line-history))))))

  (general-add-advice #'consult-line :after #'noct-consult-line-evil-history)

  (defvar consult--bufler-workspace+
    `(:name "Workspace"
            :narrow ?w
            :category buffer
            :face consult-buffer
            :history  buffer-name-history
            :state    ,#'consult--buffer-state
            :enabled  ,(lambda () (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find)))
            :items
            ,(lambda ()
               (let ((bufler-vc-state nil))
                 (mapcar #'buffer-name
                         (mapcar #'cdr
                                 (bufler-buffer-alist-at
                                  (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find))
                                  :filter-fns bufler-filter-buffer-fns))))))
    "Bufler workspace buffers source for `consult-buffer'.")

  (push #'consult--bufler-workspace+ consult-buffer-sources)

  ;; Stolen from the wiki
  (defun consult-initial-narrow ()
    (when (and (eq this-command #'consult-buffer)
               (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find)))
      (setq unread-command-events (append unread-command-events (list ?w 32)))))

  (defcustom noct-consult-ripgrep-or-line-limit 1000000
    "Buffer size threshold for `noct-consult-ripgrep-or-line'.
  When the number of characters in a buffer exceeds this threshold,
  `consult-ripgrep' will be used instead of `consult-line'."
    :type 'integer)

  (defun noct-consult-ripgrep-or-line (&optional initial)
    "Call `consult-line' for small buffers or `consult-ripgrep' for large files."
    (interactive)
    (if (or (not buffer-file-name)
            (buffer-narrowed-p)
            (ignore-errors
              (file-remote-p buffer-file-name))
            (jka-compr-get-compression-info buffer-file-name)
            (<= (buffer-size)
                (/ noct-consult-ripgrep-or-line-limit
                   (if (eq major-mode 'org-mode) 4 1))))
        (consult-line initial)
      ((lambda ()
         (when (file-writable-p buffer-file-name)
  	 (save-buffer))
         (let ((consult-project-function (lambda (x) nil)))
  	 (consult-ripgrep (list (shell-quote-argument buffer-file-name)) (concat " " initial))
  	 (efs/save-search-history (string-trim-left (car consult--grep-history) "# ")))))))
#+end_src

***** Extensions
#+NAME: Emacs Consult Extensions
#+begin_src nix
  consult-dir = {
    enable = true;
    defer = true;
    generalOne.vertico-map = {
      "C-x d" = "'consult-dir";
      "C-x j" = "'consult-dir-jump-file";
    };
  };
#+end_src

**** Embark
Embark lets you manipulate the content of vertico buffers.

Credits:
Which-key indicator from the embark wiki
avy actions from karthink
#+NAME: Emacs Embark
#+begin_src nix :noweb yes
  embark = {
    enable = true;
    defer = true;
    command = ["embark-act"];
    general."M-a" = "'embark-dwim";
    custom = {
      # Replace key help with a completing-read interface
      prefix-help-command = "#'embark-prefix-help-command";
      embark-indicators = ''
        '(embark-which-key-indicator
          embark-highlight-indicator
          embark-isearch-highlight-indicator)
      '';
    };
    generalTwo."'normal" = {
      embark-collect-mode-map."q" = "'evil-record-macro";
      minibuffer-local-map."a" = "'embark-act";
    };
    generalOne = {
      embark-file-map."2" = "(my/embark-split-action find-file elwm-split-window)";
      embark-buffer-map."2" = "(my/embark-split-action switch-to-buffer elwm-split-window)";
      embark-bookmark-map."2" = "(my/embark-split-action bookmark-jump elwm-split-window)";
    };
    config = ''
      <<Emacs Embark Config>>
    '';
    init = ''
      <<Emacs Embark Init>>
    '';
  } ;

  embark-consult = {
    enable = true;
    after = ["embark" "consult"];
    ghook = ["('embark-collect-mode-hook 'consult-preview-at-point-mode)"];
  };
#+end_src

#+NAME: Emacs Embark Config
#+begin_src emacs-lisp
  (cl-defun embark--beginning-of-target (&key bounds &allow-other-keys)
    "Go to beginning of the target BOUNDS."
    (goto-char (car bounds)))

  (cl-defun embark--end-of-target (&key bounds &allow-other-keys)
    "Go to end of the target BOUNDS."
    (goto-char (cdr bounds)))
#+end_src

#+NAME: Emacs Embark Init
#+begin_src emacs-lisp
  (defun embark-which-key-indicator ()
    "An embark indicator that displays keymaps using which-key.
      The which-key help message will show the type and value of the
      current target followed by an ellipsis if there are further
      targets."
    (lambda (&optional keymap targets prefix)
      (if (null keymap)
          (which-key--hide-popup-ignore-command)
        (which-key--show-keymap
         (if (eq (plist-get (car targets) :type) 'embark-become)
             "Become"
           (format "Act on %s '%s'%s"
                   (plist-get (car targets) :type)
                   (embark--truncate-target (plist-get (car targets) :target))
                   (if (cdr targets) "…" "")))
         (if prefix
             (pcase (lookup-key keymap prefix 'accept-default)
               ((and (pred keymapp) km) km)
               (_ (key-binding prefix 'accept-default)))
           keymap)
         nil nil t (lambda (binding)
                     (not (string-suffix-p "-argument" (cdr binding))))))))

  (defun embark-hide-which-key-indicator (fn &rest args)
    "Hide the which-key indicator immediately when using the completing-read prompter."
    (which-key--hide-popup-ignore-command)
    (let ((embark-indicators
           (remq #'embark-which-key-indicator embark-indicators)))
      (apply fn args)))

  (advice-add #'embark-completing-read-prompter
              :around #'embark-hide-which-key-indicator)

  (eval-when-compile
    (defmacro my/embark-split-action (fn split-type)
      `(defun ,(intern (concat "my/embark-"
                               (symbol-name fn)
                               "-"
                               (car (last  (split-string
                                            (symbol-name split-type) "-"))))) ()
         (interactive)
         (funcall #',split-type)
         (call-interactively #',fn))))

  ;; Hide the modeline of embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
#+end_src

**** App Launcher
#+NAME: Emacs App Launcher
#+begin_src nix
  app-launcher = {
    enable = true;
    defer = true;
    command = ["app-launcher-run-app"];
  };
#+end_src

**** Search
#+NAME: Emacs Search
#+begin_src nix :noweb yes
  ace-isearch = {
    enable = true;
    demand = true;
    gfhook = ["('pdf-view-mode-hook (lambda () (ace-isearch-mode -1)))"];
    generalOne.isearch-mode-map."C-a" = "'avy-isearch";
    config = ''
      <<Emacs Search Config>>
    '';
    custom = {
      ace-isearch-on-evil-mode = true;
      ace-isearch-input-length = "5";
      ace-isearch-jump-based-on-one-char = false;
      ace-isearch-function-from-isearch = "'ace-isearch-consult-ripgrep-or-line-from-isearch";
    };
  };
#+end_src

#+NAME: Emacs Search Config
#+begin_src emacs-lisp
  (global-ace-isearch-mode)
  (defun ace-isearch-consult-ripgrep-or-line-from-isearch ()
    "Invoke `noct-consult-ripgrep-or-line' from ace-isearch."
    (interactive)
    (let (($query (if isearch-regexp
  		    isearch-string
  		  (regexp-quote isearch-string))))
      (isearch-update-ring isearch-string isearch-regexp)
      (let (search-nonincremental-instead)
        (ignore-errors (isearch-done t t)))
      (noct-consult-ripgrep-or-line $query)))
#+end_src

**** Snippets
#+NAME: Emacs Snippets
#+begin_src nix :noweb yes
  tempel = {
    enable = true;
    command = ["tempel-complete"];
    custom.tempel-path = ''"~/.config/emacs/templates.eld"'';
    init = ''
      <<Emacs Templ Init>>
    '';
  };

  tempel-collection = {
    enable = true;
    after = ["tempel"];
  };
#+end_src

#+NAME: Emacs Templ Init
#+begin_src emacs-lisp
  (defun tempel-setup-capf ()
    " Add the Tempel Capf to `completion-at-point-functions'.
    `tempel-expand' only triggers on exact matches. Alternatively use
    `tempel-complete' if you want to see all matches, but then you
    should also configure `tempel-trigger-prefix', such that Tempel
    does not trigger too often when you don't expect it. NOTE: We add
    `tempel-expand' *before* the main programming mode Capf, such
    that it will be tried first."
    (setq-local completion-at-point-functions
                (cons #'tempel-expand
                      completion-at-point-functions)))
#+end_src

#+NAME: Emacs Templates File
#+begin_src nix
  home.file.".config/emacs/templates.eld".text = ''
    nix-mode
    (upackage p "= {" n "  enable = true;" q "  }")

    js-ts-mode
    (clg "console.log(" p ");")
    (doc "/**" n> " * " q n " */")
    (anfn "(" p ") => {" n> q n "};")
    (qs "document.querySelector(\"" q "\");")
    (if "if (" p ") {" n> q n "}")

    c-ts-mode
    (doc "/**" n> " * " q n " */")
    (if "if (" p ") {" n> q n "}")
    (for "for (int i = " p "; i < " p "; i++) {" n> q n "}")
    (while "while (" p ") {" n> q n "}")
    (stdio "#include <stdio.h>")
    (stdlib "#include <stdlib.h>")
    (string "#include <string.h>")
    (unistd "#include <unistd.h>")
    (mpi "#include <mpi.h>")
    (math "#include <math.h>")
    (define "#define " p)
    (function p " " p " (" p ") {" n> q n "}" ) 
    (main "int main (int argc, char **argv) {" n> q n "}" ) 

    org-mode
    (au "#+author: " q)
    (ti "#+title: " q)
    (ci "* Works Cited" n "#+cite_export: csl ~/.config/csl/ieee.csl" n "#+print_bibliography:" q)
    (pdf "#+auto-export-pandoc: to-latex-pdf")
    (odt "#+auto-export-pandoc: to-odt")

    java-ts-mode
    (doc "/**" n> " * " q n " */")
    (if "if (" p ") {" n> q n "}")
    (class "public class " (p (file-name-base (or (buffer-file-name) (buffer-name)))) " {" n> r> n "}")
    (method p " " p " " p "(" p ") {" n> q n "}")
    (while "while (" p ") {" n> q n "}")
    (for "for (int i = " p "; i < " p "; i++) {" n> q n "}")

    bash-ts-mode
    (bang "#!/bin/sh" n q)
    (safebang "#!/bin/sh" n "set -euo pipefail" n q)

    ledger-mode
    (payroll p "Rose-Hulman Payroll" n> "Income:TeachingAssistant" > "-" p n> "*Assets:Checking")
    (checking "Assets:Checking")

    racket-mode
    (let "(let [(" p ")]" n q ")")
    (letrec "(letrec [(" p ")]" n q ")")
    (letstar "(let* [(" p ")]" n q ")")
    (namelet "(let " p " [(" p ")]" n q ")")
    (defun "(define " p " (lambda (" p ")" n q "))")
  '';
#+end_src

**** Ezf
An alternative to fzf.
#+NAME: Emacs Ezf
#+begin_src nix
  ezf = {
    enable = true;
    deferIncrementally = true;
  };
#+end_src

*** Help System
An improved help system that I lifted from emacs from scratch.
Helpful gives more information, & which-key tells what keybinds you have available
#+begin_src nix :tangle emacs/help-system.nix
  { ... }:

  {
    programs.emacs.init.usePackage = {
      which-key = {
        enable = true;
        defer = true;
        config = ''(which-key-enable-god-mode-support)'';
        ghook = ["('on-first-input-hook 'which-key-mode)"];
        custom = {
          which-key-idle-delay = "1";
          # which-key-popup-type = "'minibuffer";
        };
      };

      helpful = {
        enable = true;
        defer = true;
        generalOne = {
          "efs/leader-keys" = {
            "hf" = "'helpful-function";
            "hs" = "'helpful-symbol";
            "hv" = "'helpful-variable";
            "hx" = "'helpful-command";
            "hk" = "'helpful-key";
            "hm" = "'helpful-macro";
          };
          embark-become-help-map = {
            "f" = "'helpful-function";
            "s" = "'helpful-symbol";
            "v" = "'helpful-variable";
          };
          embark-symbol-map."h" = "'helpful-symbol";
        };
      };
    };
  }
#+end_src

*** Password Management
#+begin_src nix :noweb yes :tangle emacs/passwords.nix
  { pkgs, ... }:

  {
    home.packages = with pkgs; [ pass ];

    programs.emacs.init.usePackage = {
      <<Emacs Pass>>
      
      <<Emacs Pinentry>>
    };
  }
#+end_src

**** Pass
This is an emacs wrapper for pass.
Password-store-otp has more functions, if they are of intrest.
Everything is bound to SPC p
#+NAME: Emacs Pass
#+begin_src nix
  password-store = {
    enable = true;
    defer = true;
    generalOne."efs/leader-keys" = {
      "p" = '''(:ignore t :which-key "pass")'';
      "py" = '''(password-store-copy :which-key "yank")'';
      "pi" = '''(password-store-insert :which-key "insert")'';
      "pg" = '''(password-store-generate :which-key "generate")'';
    };
    extraConfig = ":autoload pass-entries password-store-list";
  };

  password-store-otp = {
    enable = true;
    defer = true;
    generalOne."efs/leader-keys"."po" = '''(password-store-otp-token-copy :which-key "copy otp")'';
  };
#+end_src

**** Pinentry
This is a pinentry program (alternative to pinentry-dmenu)
When you're prompted for your gpg password, the place for entry will be your modeline.
#+NAME: Emacs Pinentry
#+begin_src nix :noweb yes
  pinentry = {
    enable = true;
    custom.epa-pinentry-mode = "'loopback";
    deferIncrementally = true;
    config = ''
      <<Emacs Pinentry Config>>
    '';
  };
#+end_src

#+NAME: Emacs Pinentry Config
#+begin_src emacs-lisp
  (pinentry-start)
  (shell-command "gpgconf --launch-agent")
  (shell-command "gpg-connect agent updatestartuptty /bye >/dev/null")
#+end_src

*** Writing
#+begin_src nix :noweb yes :tangle emacs/writing.nix
  { inputs, pkgs, ... }:

  {
    home.packages = with pkgs; [
      libreoffice-fresh
      hunspell
      hunspellDicts.en-us-large
    ];

    programs.emacs.init = {
      ide.languages = {
        markdown.enable = true;
        latex = {
          enable = true;
          magicLatexBuffer = true;
          cdlatex = true;
        };
      };
      usePackage = {
        <<Emacs Org Main>>

        <<Emacs Org Extensions>>
        
        <<Emacs Org Denote>>
        
        <<Emacs Org Novelist>>
        
        <<Emacs Latex>>
        
        <<Emacs Markdown>>
        
        <<Emacs Writeroom>>

        <<Emacs Spellcheck>>
        
        <<Emacs Citations>>

        <<Emacs Epub Reader>>
      };
    };
  }
#+end_src

**** Org
***** Main Config
The org agenda syntax:
DEADLINE:<year-month-date>
How to add a latex package
: #+LATEX_HEADER: \usepackage{times}

#+NAME: Emacs Org Main
#+begin_src nix :noweb yes
  org = {
    gfhook = ["('org-mode-hook '(ispell-minor-mode my/org-capf))"];
    custom = {
      org-export-with-toc = false;
      org-export-with-section-numbers = false;
      # org-agenda-files = '''("~/doc/tasks.org")'';
      org-directory = ''"~/doc"'';
      org-emphasis-alist = '''(("*" bold)
                                 ("/" italic)
                                 ("=" org-verbatim verbatim)
                                 ("~" org-code verbatim)
                                 ("+" (:strike-through t))
                                 ("!" (:overline t) verbatim))'';
    };
    generalOne."efs/leader-keys" = {
      "o" = '''(:ignore t :which-key "org")'';
      "op" = '''org-capture'';
    };
    generalTwo.local-leader.org-mode-map = {
      "e" = '''(org-export-dispatch :which-key "export")'';
      "o" = '''(consult-org-heading :which-key "outline")'';
      "a" = '''(avy-org-goto-heading-timer :which-key "avy")'';
      "i" = '''(org-toggle-inline-images :which-key "show images")'';
      "b" = '''(org-edit-special :which-key "edit block")'';
    };

    config = ''
      <<Emacs Org Config>>
    '';
  };
#+end_src

#+NAME: Emacs Org Config
#+begin_src emacs-lisp
  (defun my/org-capf ()
    (setq-local completion-at-point-functions
                (list (cape-capf-super
                       #'tempel-complete
                       #'cape-file)
  		    #'pcomplete-completions-at-point
  		    #'cape-dabbrev
  		    #'cape-dict)))
#+end_src

***** Extensions
#+NAME: Emacs Org Extensions
#+begin_src nix :noweb yes
  org-auto-tangle = {
    enable = true;
    ghook = ["('org-mode-hook 'org-auto-tangle-mode)"];
  };

   org-auto-export-pandoc = {
     enable = true;
     extraPackages = with pkgs; [pandoc];
     ghook = ["('after-save-hook (lambda () (when (equal major-mode 'org-mode) (org-auto-export-pandoc))))"];
   };

#+end_src

***** Denote
#+NAME: Emacs Org Denote
#+begin_src nix :noweb yes
  denote = {
    enable = true;
    defer = true;
    gfhook = ["('dired-mode-hook 'denote-dired-mode-in-directories)"];
    custom = {
      denote-directory = ''(expand-file-name "~/doc/denote")'';
      denote-known-keywords = '''("quotes" "chem" "emacs" "java" "physics" "calculus" "minecraft" "de" "proofs" "csse230" "os" "databases" "scifi" "softwarerequirements" "anthropology" "theoryofcomputation" "parallelcomp" "cybersecurity" "probstats" "scheme" "dreams" "softwaredevelopment" "ethics" "plp")'';
      denote-file-type = false;
      denote-dired-directories = "(list denote-directory)";
      
    };
    generalOne."efs/leader-keys" = {
      "oc" = '''(denote :which-key "create note")'';
      "or" = '''(denote-rename-file :whick-key "denote rename")'';
      "oi" = '''(denote-link :which-key "link to note")'';
    };
  };

  consult-notes = {
    enable = true;
    defer = true;
    config = ''
      <<Emacs Consult Notes Config>>
    '';
    generalOne."efs/leader-keys" = {
      "of" = '''(consult-notes :which-key "find note")'';
      "os" = '''(consult-notes-search-in-all-notes :which-key "search notes")'';
    };
  };
#+end_src

#+NAME: Emacs Consult Notes Config
#+begin_src emacs-lisp
  (with-eval-after-load 'embark
    (defvar-keymap consult-notes-map
      :doc "Keymap for Embark notes actions."
      :parent embark-file-map)
    (add-to-list 'embark-keymap-alist `(,consult-notes-category . consult-notes-map))
    ;; make embark-export use dired for notes
    (setf (alist-get consult-notes-category embark-exporters-alist) #'embark-export-dired))

  (when (locate-library "denote")
    (consult-notes-denote-mode))

#+end_src

***** Novelist
#+NAME: Emacs Org Novelist
#+begin_src nix
  org-novelist = {
    enable = true;
    command = ["org-novelist-mode" "org-novelist-new-story"];
    generalTwo.local-leader.org-novelist-mode-map = {
      "c" = '''(:ignore t :which-key "character")'';
      "cn" = '''(org-novelist-new-character :which-key "new")'';
      "cr" = '''(org-novelist-rename-character :which-key "rename")'';
      "cd" = '''(org-novelist-destroy-character :which-key "destroy")'';
      "h" = '''(:ignore t :which-key "chapter")'';
      "hn" = '''(org-novelist-new-chapter :which-key "new")'';
      "hr" = '''(org-novelist-rename-chapter :which-key "rename")'';
      "hd" = '''(org-novelist-destroy-chapter :which-key "destroy")'';
      "p" = '''(:ignore t :which-key "place")'';
      "pn" = '''(org-novelist-new-place :which-key "new")'';
      "pr" = '''(org-novelist-rename-place :which-key "rename")'';
      "pd" = '''(org-novelist-destroy-place :which-key "destroy")'';
      "r" = '''(:ignore t :which-key "prop")'';
      "rn" = '''(org-novelist-new-prop :which-key "new")'';
      "rr" = '''(org-novelist-rename-prop :which-key "rename")'';
      "rd" = '''(org-novelist-destroy-prop :which-key "destroy")'';
      "e" = '''(org-novelist-export-story :which-key "export")'';
    };
  };
#+end_src

**** Latex
Auctex turns emacs into a LaTeX IDE.

This configuration was taken from the emacs wiki. [[https://www.emacswiki.org/emacs/RefTeX][Reftex]] 
[[https://libredd.it/r/emacs/comments/4zvln1/editing_tex_documents/
][Also this reddit post]]
Reftex seems to do references
Magic latex buffer makes your source file look more like the pdf.
No idea what the rest of this is for.

| Key | CDLatex effect                    |
| `n  | greek letter \nu                    |
| TAB | magic. Ususally involves jumping. |
| equ | becomes an equation after tab     |
| beg | becomes an environment after tab  |

#+NAME: Emacs Latex
#+begin_src nix :noweb yes
  tex.generalTwo.local-leader.LaTeX-mode-map = {
    "p" = '''(preview-at-point :which-key "preview")'';
    "a" = '''(eglot-code-actions :which-key "code actions")'';
    "n" = '''(flymake-goto-next-error :which-key "next error")'';
    "e" = '''(flymake-goto-prev-error :which-key "previous error")'';
    "f" = '''(eglot-format :which-key "format")'';
    "u" = '''(preview-clearout-at-point :which-key "unpreview")'';
  };

  pdf-tools = {
    enable = true;
    defer = true;
    generalOne.pdf-view-mode-map."C-s" = "'search-forward";
    custom = {
      # Makes PDFtools the default
      TeX-view-program-selection = '''((output-pdf "PDF Tools"))'';
      TeX-view-program-list = '''(("PDF Tools" TeX-pdf-tools-sync-view))'';
      TeX-source-correlate-start-server = false;
    };
    config = ''
      <<Emacs Pdf Tools Config>>
    '';
    gfhook = [
      "('TeX-after-compilation-finished-functions #'TeX-revert-document-beffer)"
      "('pdf-view-mode-hook 'pdf-view-midnight-minor-mode)"];
    init = ''(setq-default pdf-view-display-size 'fit-width)'';
    extraConfig = '':magic ("%PDF" . pdf-view-mode)'';
  };

  cdlatex.generalTwo."'insert" = {
    cdlatex-mode-map."TAB" = "'cdlatex-tab";
    org-cdlatex-mode-map."TAB" = "'cdlatex-tab";
  };
#+end_src

#+NAME: Emacs Pdf Tools Config
#+begin_src emacs-lisp
  (pdf-tools-install)
  (with-eval-after-load 'evil-collection-pdf
    (general-def 'normal pdf-view-mode-map
      "C-e" 'pdf-view-scroll-up-or-next-page
      "E" 'pdf-view-scroll-up-or-next-page
      "C-o" 'pdf-view-scroll-down-or-previous-page
      "O" 'pdf-view-scroll-down-or-previous-page))
#+end_src

**** Markdown
#+NAME: Emacs Markdown
#+begin_src nix :noweb yes
  markdown = {
    generalOne.markdown-mode-map."C-c C-e" = "'markdown-do";
    gfhook = ["('markdown-mode-hook 'efs/markdown-font-setup)"];
    custom = {
      markdown-command = ''"multimarkdown"'';
      markdown-hide-markup = true;
    };
    generalTwo = {
      "'normal".markdown-mode-map = {
        "[h" = "'markdown-previous-visible-heading";
        "]h" = "'markdown-next-visible-heading";
      };  
      local-leader.markdown-mode-map = {
        "o" = '''(consult-outline :which-key "go to heading")'';
        "a" = '''(eglot-code-actions :which-key "code actions")'';
        "n" = '''(flymake-goto-next-error :which-key "next error")'';
        "e" = '''(flymake-goto-prev-error :which-key "previous error")'';
      };
    };
    init = ''
      <<Emacs Markdown Init>>
    '';
  };
#+end_src

#+NAME: Emacs Markdown Init
#+begin_src emacs-lisp
  (defun efs/markdown-font-setup ()
    (variable-pitch-mode)
    (dolist (face '((markdown-header-face-1 . 1.4)
                    (markdown-header-face-2 . 1.2)
                    (markdown-header-face-3 . 1.1)
                    (markdown-header-face-4 . 1.05)
                    (markdown-header-face-5 . 1.05)
                    (markdown-header-face-6 . 1.05)))
      (set-face-attribute (car face) nil :font "SF Pro" :weight 'regular :height (cdr face))))
#+end_src

**** Writeroom
I couldn't get olivetti to work.
#+NAME: Emacs Writeroom
#+begin_src nix
  writeroom-mode = {
    enable = true;
    ghook = ["('(Man-mode-hook org-agenda-mode-hook org-mode-hook Info-mode-hook markdown-mode-hook) 'writeroom-mode)"];
    gfhook = ["('writeroom-mode-hook 'visual-line-mode)"];
    custom = {
      writeroom-mode-line = true;
      writeroom-maximize-window = false;
      writeroom-global-effects = false;
    };
    generalOne."efs/leader-keys"."w" = '''(writeroom-mode :which-key "writeroom")'';
  };
#+end_src

**** Spellcheck
#+NAME: Emacs Spellcheck
#+begin_src nix
  flyspell = {
    enable = true;
    custom.ispell-personal-dictionary = "~/.config/emacs/ispell.txt";
    ghook = [
      "('text-mode-hook 'flyspell-mode)"
      "('prog-mode-hook 'flyspell-prog-mode)"
    ];
  };
#+end_src

**** Citations
#+NAME: Emacs Citations
#+begin_src nix :noweb yes
  citar = {
    enable = true;
    config = ''(citar-denote-mode)'';
    ghook = ["('(LaTeX-mode-hook org-mode-hook) 'citar-capf-setup)"];
    custom = {
      org-cite-insert-processor = "'citar";
      org-cite-follow-processor = "'citar";
      org-cite-activate-processor = "'citar";
      citar-bibliography = '''("~/doc/uni.bib")'';
      org-cite-global-bibliography = '''("~/doc/uni.bib")'';
    };
  };

  citar-embark = {
    enable = true;
    after = ["citar" "embark"];
    config = ''(citar-embark-mode)'';
    custom.citar-at-point-function = "'embark-act";
  };

  citar-denote = {
    enable = true;
    command = ["citar-denote-mode"];
    generalOne."efs/leader-keys" = {
      "on" = '''(citar-create-note :which-key "new citar note")'';
      "oo" = '''(citar-denote-open-note :which-key "open citar note")'';
      "ol" = "'citar-denote-link-reference";
      "ow" = "'citar-denote-find-citation";
    };
    config = ''
      <<Emacs Writing Citar Denote Config>>
    '';
    afterCall = ["citar"];
  };
#+end_src

#+NAME: Emacs Writing Citar Denote Config
#+begin_src emacs-lisp
  (defun citar-denote--create-note (citekey &optional _entry)
    "Create a bibliographic note for CITEKEY with properties ENTRY.

  The note file type is determined by `citar-denote-file-type'.

  The title format is set by `citar-denote-title-format'.

  When `citar-denote-subdir' is non-nil, prompt for a subdirectory.

  When `citar-denote-template' is a symbol, use the specified
  template, if otherwise non-nil, prompt for a Denote template.

  When `citar-denote-signature' is non-nil, prompt for a signature or
  use citation key."
    (denote
     (read-string "Title: " (citar-denote--generate-title citekey))
     (citar-denote--keywords-prompt citekey)
     citar-denote-file-type
     (when citar-denote-subdir
       (if (stringp citar-denote-subdir)
           (expand-file-name
            (concat denote-directory citar-denote-subdir))
         (denote-subdirectory-prompt)))
     nil
     (when citar-denote-template
       (or (alist-get citar-denote-template denote-templates)
           (denote-template-prompt)))
     (cond ((eq citar-denote-signature 'ask)
            (denote-signature-prompt nil "Signature: "))
           ((eq citar-denote-signature 'citekey)
            citekey)
           (nil nil)))
    (citar-denote--add-reference citekey)
    ;; Open available atachment in other window
    (when (one-window-p)
      (split-window-right))
    (other-window 1)
    (citar-open-files citekey))
#+end_src

**** Epub Reader
Nov allows you to read an epub file in a very similar way to an org file.
You can't get page numbers, though, which becomes unfortunate for doing citations.
#+NAME: Emacs Epub Reader
#+begin_src nix
  nov = {
    enable = true;
    defer = true;
    extraPackages = with pkgs; [unzip];
    mode = [''("\\.epub\\'" . nov-mode)''];
  };
#+end_src

** Window Management
Almost everything here was copied from David Wilson. Thank you, David, for practically writing my config for me.

#+begin_src nix :noweb yes :tangle emacs/window-manager.nix
  { inputs, pkgs, pkgs-stable, config, ... }:

  {
    programs = {
      <<i3status>>

      emacs.init.usePackage = {
        <<Emacs Window Management Tab Bar>>
        
        <<Emacs Window Management Bufler>>

        <<Emacs Window Management ELWM>>

        <<Emacs Window Management Golden Ratio>>
        
        <<Emacs Window Management EXWM>>
        
        <<Emacs Window Management Popper & Proced>>
      };
    };
  }
#+end_src

*** Tab Bar
I borrowed pretty heavily from here: https://github.com/jamescherti/vim-tab-bar.el
#+NAME: Emacs Window Management Tab Bar
#+begin_src nix
tab-bar = {
  enable = true;
  config = ''
    (general-add-advice 'tab-new :after #'dashboard-open)
    (defun efs/tab-bar-select ()
       (interactive)
       (setq tab-bar-tab-hints t)
       (tab-bar-select-tab (string-to-number (read-string "Tab Number: ")))
       (setq tab-bar-tab-hints nil))
  '';
  ghook = ["('exwm-init-hook 'tab-bar-mode)"];
  general."s-u" = "'tab-bar-hydra/body";
  custom = {
    tab-bar-format = "'(tab-bar-format-tabs-groups tab-bar-separator doom-nano-tabline tab-bar-format-align-right tab-bar-format-global)";
    tab-bar-close-button-show = false;
    tab-bar-select-restore-windows = false;
    tab-bar-auto-width-max = "'((150) 20)";
  };
  extraConfig = ''
    :pretty-hydra
    ((:color amaranth)
     ("Navigation"
      (("e" #'evil-tab-next "next")
       ("o" #'tab-bar-switch-to-prev-tab "prev")
       ("v" #'tab-recent "recent")
       ("b" #'tab-bar-lost-commands-switch-to-first-tab "first")
       ("B" #'tab-bar-lost-commands-switch-to-last-tab "last")
       ("/" #'efs/tab-bar-select "search"))
      "Creation/Deletion"
      (("s" #'tab-new "new")
       ("k" #'tab-close "close")
       ("r" #'tab-rename "rename")
       ("u" #'tab-undo "undo"))
      "Groups"
      (("g" #'tab-group "add to group")
       ("K" #'tab-close-group "close group"))
      "Organization"
      (("E" #'tab-bar-lost-commands-move-tab-forward "forward")
       ("O" #'tab-bar-lost-commands-move-tab-backward "backward"))
      "Exit"
      (("<return>" nil "" :color blue)
       ("<escape>" nil "" :color blue))))
  '';
};

tab-bar-lost-commands = {
  enable = true;
  command = [
    "tab-bar-lost-commands-move-tab-forward"
    "tab-bar-lost-commands-move-tab-backward" 
    "tab-bar-lost-commands-switch-to-first-tab" 
    "tab-bar-lost-commands-switch-to-last-tab" 
  ];
};
#+end_src

*** Bufler
Bufler is the other half of tab bar. It lets us automatically narrow buffers down to a given workspace
#+NAME: Emacs Window Management Bufler
#+begin_src nix :noweb yes
bufler = {
  enable = true;
  ghook = ["('tab-bar-mode-hook 'bufler-mode)"];
  general = {
    "s-b" = "'bufler-hydra/body";
    "s-f" = "'bufler-workspace-focus-buffer";
    "s-F" = "'bufler-workspace-set";
  };
  generalTwo."'normal".evil-collection-unimpaired-mode-map = {
    "]b" = "'bufler-cycle-buffers-forward";
    "[b" = "'bufler-cycle-buffers-backward";
  };
  custom.bufler-groups = ''
    <<Emacs Bufler Defgroups>>
  '' ;
  init = ''
    <<Emacs Bufler Init>>
  '';
  config = ''
    <<Emacs Bufler Config>>
  '';
  extraConfig = ''
    :pretty-hydra
    ((:color amaranth)
      ("Move"
       (("o" bufler-cycle-buffers-backward "prev")
        ("e" bufler-cycle-buffers-forward "next"))
       "Tricks"
       (("/" consult-buffer "search" :color blue :exit t)
        ("i" ibuffer "list (ibuffer)" :color blue :exit t)
        ("k" kill-current-buffer "delete"))
       "Quit"
       (("<escape>" nil "quit" :color blue :exit t)
        ("<return>" nil "quit" :color blue :exit t))))
  '';
};

bufler-workspace-tabs = {
  enable = true;
  ghook = ["('bufler-mode-hook 'bufler-workspace-workspaces-as-tabs-mode)"];
  gfhook = ["('bufler-workspace-workspaces-as-tabs-mode-hook '(global-tab-line-mode burly-tabs-mode))"];
};
#+end_src

#+NAME: Emacs Bufler Defgroups
#+begin_src emacs-lisp
(bufler-defgroups
  ;; Subgroup collecting all named workspaces.
  (group (auto-workspace))
  ;; Subgroup collecting buffers in a project.
  (group (auto-project))
  ;; Subgroup collecting tramp buffers
  (group (auto-tramp))
  ;; Grouping browser windows
  (group
   (group-or "Browsers"
             (name-match "Qutebrowser" (rx bos "Qutebrowser"))
             (name-match "Tor Browser" (rx bos "Tor Browser"))
             (mode-match "eww-mode" (rx bos "eww-"))))
  (group
   (group-or "Chat"
             (name-match "Thunderbird" (rx bos "Thunderbird"))
             (name-match "teams-for-linux" (rx bos "teams-for-linux"))
             (mode-match "ement" (rx bos "ement-"))
             (name-match "vesktop" (rx bos "vesktop"))))
  (group
   (group-or "Media"
             (name-match "mpv" (rx bos "Mpv"))
             (mode-match "elfeed-search-mode" (rx bos "elfeed-"))
             (mode-match "elfeed-show-mode" (rx bos "elfeed-"))
	     (mode-match "yeetube-mode" (rx bos "yeetube-"))))
  (group
   (group-or "Agenda"
             (name-match "tasks.org" (rx bos "tasks.org"))
             (mode-match "org-agenda-mode" (rx bos "org-agenda-"))))
  (group
   (group-or "Ledger"
	     (mode-match "ledger-mode" (rx bos "ledger-"))
	     (mode-match "ledger-report-mode" (rx bos "ledger-"))))
  (group
   (group-or "Notes"
             (dir "~/doc/denote/")))
  (group
   (group-or "AV"
             (name-match "lmms" (rx bos "lmms"))
             (name-match "Gimp-2.10" (rx bos "Gimp-2.10"))
             (name-match "kdenlive" (rx bos "kdenlive"))))
  (group
   (group-or "Games"
             (dir "~/.local/PrismLauncher/")
             (name-match "Minecraft" (rx bos "Minecraft"))
             (name-match "PrismLauncher" (rx bos "PrismLauncher"))))
  (group
   ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
   (group-or "Help/Info"
             (mode-match "*Help*" (rx bos (or "help-" "helpful-")))
             (mode-match "*Info*" (rx bos "info-"))
	     (mode-match "Man-mode" (rx bos "Man-"))))
  (group
   ;; Subgroup collecting all special buffers (i.e. ones that are not
   ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
   ;; through to other groups, so they end up grouped with their project buffers).
   (group-and "*Special*"
              (name-match "**Special**"
                          (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace" "Pinentry") "*"))
              (lambda (buffer)
                (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                     buffer)
                            (funcall (mode-match "Dired" (rx bos "dired"))
                                     buffer)
                            (funcall (auto-file) buffer))
                  "*Special*"))))
  (auto-directory))
#+end_src

#+NAME: Emacs Bufler Init
#+begin_src emacs-lisp
  ;; These functions were adapted from perspective-exwm
  (defun bufler-cycle-buffers (proc)
    "Switches to the next or previous buffer in the workspace, if one exists, or the next buffer anywhere, if one doesn't exist."
    (let* ((workspace (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find))))
      (if workspace
          (let* ((current (current-buffer))
                 (buffer-list (mapcar #'cdr
                                      (bufler-buffer-alist-at workspace :filter-fns bufler-filter-buffer-fns)))
                 (current-pos (or (cl-position current buffer-list) -1))
                 (len (length buffer-list))
                 (next-pos (% (+ current-pos len
                                 (if (eq proc 'evil-next-buffer) (- len 1) -1))
                              len))
                 (next-buffer (nth next-pos buffer-list)))
            (switch-to-buffer next-buffer))
        (funcall proc))))
  (defun bufler-cycle-buffers-forward ()
    "Cycles the buffers in the workspace forward."
    (interactive)
    (bufler-cycle-buffers 'evil-next-buffer))
  (defun bufler-cycle-buffers-backward ()
    "Cycles the buffers in the workspace backward."
    (interactive)
    (bufler-cycle-buffers 'evil-prev-buffer))

#+end_src

#+NAME: Emacs Bufler Config
#+begin_src emacs-lisp
  (defun bufler-bar ()
    (interactive)
    (bufler-sidebar)
    (with-selected-window (get-buffer-window "*Bufler*")
      (gsetq window-size-fixed 'width)
      (window-resize (selected-window) (- 35 (window-total-width)) t t)))
  (evil-ex-define-cmd "ls" 'bufler-bar)

  (evil-collection-define-key 'normal 'bufler-list-mode-map
    (kbd "RET") 'bufler-list-buffer-switch
    (kbd "M-RET") 'bufler-list-buffer-peek
    "D" 'bufler-list-buffer-kill)

#+end_src

*** ELWM
#+NAME: Emacs Window Management ELWM
#+begin_src nix :noweb yes
  elwm = {
    enable = true;
    defer = true;
    command = ["elwm-next" "elwm-prev" "elwm-rotate-window" "elwm-derotate-window" "elwm-split-window"];
    config = ''
      <<Emacs Elwm Config>>
    '';
    init = ''
      <<Emacs Elwm Init>>
    '';
  };
#+end_src

#+NAME: Emacs Elwm Config
#+begin_src emacs-lisp
(defun elwm-split-window ()
  "Split window according to the current layout.
  
  Window in the master area can't be split, instead the last window
  in the stack will be split.
  
  If selected window is window on the stack, the new window will be
  created next to it, according to the current layout."
  (interactive)
  (let ((buf (current-buffer)))
    (unless (or (eq elwm-current-layout 'monocle) (eq elwm-current-layout 'follow))
	(if (eq (count-windows) 1)
	    (if (eq elwm-current-layout 'tile-vertical-left)
		(evil-window-vsplit)
	      (evil-window-split))
	  (cond
	   ((eq elwm-current-layout 'tile-vertical-left)
	    (if (elwm--in-master-area-p)
		;; split the last window on the stack instead
		(set-window-buffer
		 (select-window (split-window (car (last (elwm--sorted-window-list))) nil nil))
		 buf)
	      (evil-window-split)))
	   ((eq elwm-current-layout 'tile-horizontal-top)
	    (if (elwm--in-master-area-p)
		;; split the last window on the stack instead
		(set-window-buffer
		 (select-window (split-window (car (last (elwm--sorted-window-list))) nil t))
		 buf)
	      (evil-window-vsplit))))))))
#+end_src

#+NAME: Emacs Elwm Init
#+begin_src emacs-lisp
  (defun elwm-next ()
    "Go to the next visible window, or if there is 1 window, the next buffer in the workspace"
    (interactive)
    (if (eq (count-windows) 1)
        (bufler-cycle-buffers-forward)
      (elwm-activate-window)))
  (defun elwm-deactivate-window () (interactive) (elwm-activate-window (prefix-numeric-value -1)))
  (defun elwm-prev ()
    "Go to the previous visible window, or if there is 1 window, the previous buffer in the workspace"
    (interactive)
    (if (eq (count-windows) 1)
        (bufler-cycle-buffers-backward)
      (elwm-deactivate-window)))
  (defun elwm-derotate-window () (interactive) (elwm-rotate-window (prefix-numeric-value -1)))

#+end_src

*** Golden Ratio
#+NAME: Emacs Window Management Golden Ratio
#+begin_src nix
  golden-ratio = {
    enable = true;
    defer = true;
    ghook = ["('on-first-input-hook 'golden-ratio-mode)"];
  };
#+end_src

*** EXWM
Installs exwm, deals with randr, executes autostart, & sets up binds.
| Binding | Command                |
| s-i     | Window managment hydra |
| s-s     | slock                  |
| s-'     | toggle popup           |
| s-"     | cycle popup            |
| s-C-'   | add/remove popup tag   |
| s-b     | switch buffer          |
| s-d     | launch program         |
| s-t     | task manager           |

+ exwm-mff: When you move to a different window, the mouse teleports to the center.
=exwm-edit Keybindings=
+ C-c C-' or C-c ': edit
+ C-c C-' or C-c C-c: finish editing
+ C-c C-k: cancel edit
#+NAME: Emacs Window Management EXWM
#+begin_src nix :noweb yes
  exwm = {
    enable = true;
    gfhook = [
      # When window "class" updates, use it to set the buffer name
      "('exwm-update-class-hook 'efs/exwm-update-class)"
      # When EXWM starts up, do some extra configuration
      "('exwm-init-hook 'efs/exwm-init-hook)"
      "('exwm-mode-hook 'evil-motion-state)"
      # When window title updates, use it to set the buffer name
      "('exwm-update-title-hook 'efs/exwm-update-title)"
    ];
    # Ctrl+q will enable the next key to be sent directly
    generalOne.exwm-mode-map."C-q" = "'exwm-input-send-next-key";
    generalTwo.local-leader.exwm-mode-map = {
      "n" = '''(lambda () (interactive) (start-process-shell-command "warpd" nil "warpd --normal"))'';
      "x" = '''(lambda () (interactive) (start-process-shell-command "warpd" nil "warpd --hint"))'';
      "g" = '''(lambda () (interactive) (start-process-shell-command "warpd" nil "warpd --grid"))'';
    };
    custom = {
      exwm-manage-force-tiling = true;
      # Emacs everywhere
      exwm-input-simulation-keys = '''(([?\C-h] . [backspace]))'';
      exwm-workspace-number = "1";
      # Automatically move EXWM buffer to current workspace when selected
      exwm-layout-show-all-buffers = true;
      # Display all EXWM buffers in every workspace buffer list
      exwm-workspace-show-all-buffers = true;
      # This will need to be updated to the name of a display!  You can find
      # the names of your displays by looking at arandr or the output of xrandr
      exwm-randr-workspace-monitor-plist = '''(1 "eDP-1-1") (2 "HDMI-0")'';
      # Automatically send the mouse cursor to the selected workspace's display
      exwm-workspace-warp-cursor = true;
      # Window focus should follow the mouse pointer
      mouse-autoselect-window = false;
      focus-follows-mouse = false;
      # These keys should always pass through to Emacs
      exwm-input-prefix-keys = '''(?\M-`
                                   ?\C-^
                                   ?\M-&
                                   ?\s-\M-'
                                   ?\s-b
                                   ?\M-u
                                   ?\M-:
                                   ?\s-o
                                   ?\s-c
                                   ?\s-v
                                   ?\s-n
                                   ?\s-i
                                   ?\s-e
                                   ?\s-f
                                   ?\s-F
                                   ?\s-u
                                   ?\s-'	;; popper-toggle-latest
                                   ?\s-\" ;; popper-toggle-type
                                   ?\C-\ 
                                   XF86AudioRaiseVolume
                                   XF86AudioLowerVolume
                                   XF86AudioMute
                                   ?\M-\ )'';
      # Set up global key bindings.  These always work, no matter the input state!
      # Keep in mind that changing this list after EXWM initializes has no effect.
      exwm-input-global-keys = ''`(;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
                                     ([?\s-r] . exwm-reset)
                                     ([?\s-a] . evil-ex)
      
                                      ;; Launch applications (basically dmenu)
                                      ([?\s-d] . app-launcher-run-app)
                                      ([?\s-t] . proced)
      
                                      ;;Movement
                                      ([?\s-e] . elwm-next)
                                      ([?\s-o] . elwm-prev)
      
                                      ;; Arrangement
                                      ([?\s-E] . elwm-rotate-window)
                                      ([?\s-O] . elwm-derotate-window)
                                      ([?\s-c] . elwm-split-window)
                                      ([?\s-n] . evil-window-move-far-left)
                                      ([?\s-i] . evil-window-move-far-right)
                                      ([?\s-j] . winner-undo)
                                      ([?\s-J] . winner-redo)
                                      ([?\s-r] . exwm-reset)
                                      ([?\s-m] . toggle-single-window)
                                      ([?\s-x] . toggle-follow-mode)
                                      ([?\s-k] . evil-window-delete)
                                      ([?\s-K] . evil-delete-buffer-and-window)
      
                                      ;; Shell bindings
                                      ([?\s-s] . (lambda () (interactive) (shell-command "slock")))
                                      ([?\s-y] . (lambda () (interactive) (start-process-shell-command "maim" nil  "${pkgs-stable.maim}/bin/maim ~/pic/screenshot.png"))))'';
      
    };
    afterCall = ["on-init-ui-hook"];
    init = ''
      <<Emacs Exwm Init>>
    '';
    config = ''
      <<Emacs Exwm Config>>
    '';
    after = ["repeaters"];
  };

  exwm-mff = {
    enable = true;
    defer = true;
    ghook = ["('exwm-init-hook 'exwm-mff-mode)"];
  };

  exwm-outer-gaps = {
    enable = true;
    config = ''(exwm-outer-gaps-mode)'';
    after = ["exwm"];
  };
#+end_src

#+NAME: Emacs Exwm Init
#+begin_src emacs-lisp
(defun efs/exwm-init-hook ()
  ;; Make workspace 0 be the one where we land at startup
  (exwm-workspace-switch-create 0)
  
  ;; Show status in the mode line
  (start-process-shell-command "xbanish" nil "${pkgs.xbanish}/bin/xbanish"))
(defun efs/exwm-update-class ()
  (exwm-workspace-rename-buffer exwm-class-name))

(defun efs/exwm-update-title ()
  (pcase exwm-class-name
    ("qutebrowser" (exwm-workspace-rename-buffer (format "Qutebrowser: %s" exwm-title)))
    ("mpv" (exwm-workspace-rename-buffer (format "Mpv: %s" exwm-title)))))

;; From dmacs
(defvar single-window--last-configuration nil "Last window configuration before calling `delete-other-windows'.")
;; From dmacs
(defun toggle-single-window ()
  "Un-maximize current window.
  If multiple windows are active, save window configuration and
  delete other windows.  If only one window is active and a window
  configuration was previously save, restore that configuration."
  (interactive)
  (if (= (count-windows) 1)
      (when single-window--last-configuration
	(setq elwm-current-layout 'tile-vertical-left)
        (set-window-configuration single-window--last-configuration)
	(when treesitter-context-mode (treesitter-context-focus-mode -1)))
    (setq single-window--last-configuration (current-window-configuration))
    (setq elwm-current-layout 'monocle)
    (delete-other-windows)
    (when (and treesitter-context-mode)
      (treesitter-context-focus-mode 1))))

(defun evil-delete-buffer-and-window ()
  "kill the current buffer & its window"
  (interactive)
  (kill-current-buffer)
  (evil-window-delete))

(defun toggle-follow-mode ()
  "If called while multiple windows are present, deactivates follow mode & kills all other windows.
   If called on only 1 window, activates follow mode & splits the window."
  (interactive)
  (if (= (count-windows) 1)
      (progn (follow-mode 1)
	     (split-window-right)
	     (setq elwm-current-layout 'follow))
    (progn (follow-mode -1)
	   (delete-other-windows)
	   (setq elwm-current-layout 'tile-vertical-left))))
#+end_src

#+NAME: Emacs Exwm Config
#+begin_src emacs-lisp
  ;; Set the screen resolution (update this to be the correct resolution for your screen!)
  (winner-mode)
  (require 'exwm-randr)
  (exwm-randr-mode)

  (repeaters-define-maps
   '(("delete-windows"
      evil-delete-buffer-and-window "K"
      evil-window-delete "k")))
  (repeaters-define-maps
   '(("input-keys"
      exwm-input-send-next-key "q")))
  (exwm-input-set-key (kbd "s-<return>") 'efs/make-eshell)
  (exwm-wm-mode)
#+end_src

*** Popper & Proced
#+NAME: Emacs Window Management Popper & Proced
#+begin_src nix :noweb yes
  popper = {
    enable = true;
    ghook = ["('on-first-buffer-hook 'popper-mode)"];
    general = {
      "s-'" = "'popper-toggle";
      "s-\\\"" = "'popper-cycle";
      "C-s-'" = "'popper-toggle-type";
    };
    custom = {
      popper-window-height = "30";
      popper-group-function = "'popper-group-by-project";
      popper-reference-buffers = '''(help-mode
                                       helpful-mode
                                       compilation-mode
                                       inferior-python-mode
                                       occur-mode
                                       grep-mode
                                       "^\\*.*eshell\\*"
                                       "^\\*eat\\*"
                                       "^\\*Sage\\*"
                                       "^\\*prolog\\*"
                                       flymake-diagnostics-buffer-mode
                                       rustic-cargo-test-mode
                                       rustic-cargo-run-mode
    			                             geiser-repl-mode
                                       dape-repl-mode
    			                             racket-repl-mode
                                       inferior-ess-r-mode
                                       cider-repl-mode)'';
    };
  };

  proced = {
    enable = true;
    command = ["proced"];
    config = ''
      <<Emacs Proced Config>>
    '';
  };
#+end_src

#+NAME: Emacs Proced Config
#+begin_src emacs-lisp
  (general-def 'normal proced-mode-map
    "j" 'proced-unmark
    "k" 'proced-send-signal)
#+end_src

*** i3status
#+NAME: i3status
#+begin_src nix
  i3status-rust = {
    enable = true;
    bars."default" = {
      blocks = [
  		  {
  			  block = "time";
  			  format =  "$icon $timestamp.datetime(f:'%a %d/%m %R')";
  			  interval = 60;
  		  }
        # {
        #   block = "music";
        # }
        {
  			  block = "battery";
  			  format =  "$icon $percentage";
  			  interval = 60;
  		  }
  	  ];
      icons = "awesome6";
      settings.theme.overrides = {
        idle_bg = "#" + config.lib.stylix.colors.base00;
        idle_fg = "#" + config.lib.stylix.colors.base05;
        info_bg = "#" + config.lib.stylix.colors.base00;
        info_fg = "#" + config.lib.stylix.colors.base05;
        good_bg = "#" + config.lib.stylix.colors.base00;
        good_fg = "#" + config.lib.stylix.colors.base05;
        warning_bg = "#" + config.lib.stylix.colors.base00;
        warning_fg = "#" + config.lib.stylix.colors.base05;
        critical_bg = "#" + config.lib.stylix.colors.base00;
        critical_fg = "#" + config.lib.stylix.colors.base05;
        # alternating_tint_bg = "#" + config.lib.stylix.colors.base00;
        separator_bg = "#" + config.lib.stylix.colors.base00;
        separator_fg = "#" + config.lib.stylix.colors.base05;
        separator = "  ";
      };
    };
  };

  emacs.init.usePackage.i3bar = {
    enable = true;
    ghook = ["('tab-bar-mode-hook 'i3bar-mode)"];
    
    custom = {
      i3bar-command = ''"${(import ../scripts/i3status-rust.nix {inherit pkgs;})}/bin/i3status-rust"'';
    };
  };
#+end_src

** GPT.el
#+begin_src nix :noweb yes :tangle gptel.nix
  { config, pkgs, inputs, ... }:

  {
    programs.emacs.init.usePackage = {
      gptel = {
        enable = true;
        defer = true;
        command = ["start-ollama"];
        custom.gptel-default-mode = "'org-mode";
        generalOne."efs/leader-keys" = {
          "g" = '''(:ignore t :which-key "gptel")'';
          "gs" = '''(start-ollama :which-key "start")'';
          "gp" = '''(gptel :which-key "prompt")'';
        };
        generalTwo."local-leader".gptel-mode-map = {
          "d" = '''(gptel-send :which-key "send")'';
          "m" = '''(gptel-menu :which-key "menu")'';
        };
        config = ''
          <<Emacs Gpt4all Config>>
        '';
      };

      gptel-quick = {
        enable = true;
        defer = true;
        generalOne = {
          embark-general-map."?" = '''(gptel-quick :which-key "summarize")''; 
          "efs/leader-keys"."gq" = '''(gptel-quick :which-key "summarize")'';
        };
      };
    };
  }
#+end_src

#+NAME: Emacs Gpt4all Config
#+begin_src emacs-lisp
  (gsetq gptel-backend (gptel-make-ollama "Ollama"
  		       :stream t
  		       :protocol "http"
  		       :host "localhost:11434"
  		       :models '(llama3.2:latest))
         gptel-max-tokens 10000000
         gptel-prompt-prefix-alist '((default . "You are a large language model and a helpful assistant. Respond concisely.")
  				   (programming . "You are a large language model and a careful programmer. Provide code and only code as output without any additional text, prompt or note.")
  				   (writing . "You are a large language model and a writing assistant. Respond concisely.")
  				   (chat . "You are a large language model and a conversation partner. Respond concisely.")))

  (defun start-ollama ()
    (interactive)
    (start-process-shell-command "start-ollama" nil "${(import ./scripts/start-ollama.nix { inherit pkgs config; })}/bin/start-ollama"))
#+end_src

** Multimedia
This is where all the audio/video stuff goes
#+begin_src nix :tangle multimedia.nix :noweb yes
  { pkgs, pkgs-stable, config, inputs, ... }:

  {
    home.packages = with pkgs; [
      yt-dlp
      (config.lib.nixGL.wrap obs-studio)
      (config.lib.nixGL.wrap kdePackages.kdenlive)
      lmms
      audacity
      mpc-cli
      doomer
      masstube
      cast
    ];

    <<Mpd>>

    <<Mpv>>

    programs.emacs.init.usePackage = {
      <<Emacs Pulseaudio Control>>
    };
  }
#+end_src

*** MPD
#+NAME: Mpd
#+begin_src nix :noweb yes
  services.mpd = {
    enable = true;
    musicDirectory = "${config.home.homeDirectory}/mus/mpd";
    extraConfig = ''
      audio_output {
        type "pipewire"
        name "My Pipewire Output"
        mixer_type "hardware"
        mixer_device "default"
        mixer_control "PCM"
      }
    '';
  };

  programs.emacs.init.usePackage.mpc-wrapper = {
    enable = true;
    generalOne."efs/leader-keys" = {
      "m" = '''(:ignore t :which-key "mpd")'';
      "mp" = '''(mpc-play :which-key "replay file")'';
      "mm" = '''(music-menu :which-key "menu")'';
      "ms" = '''(mpc-stop :which-key "stop")'';
    };
    deferIncrementally = true;
    config = ''
      <<Emacs Mpc Wrapper Config>>
    '';
  };
#+end_src

#+NAME: Emacs Mpc Wrapper Config
#+begin_src emacs-lisp
  (defun mpc-add (file)
    "Add FILE to the queue. FILE is a string."
    (shell-command (concat "mpc add " "\"" file "\"")))
  (defun music-menu ()
    "Play music from a menu."
    (interactive)
    (mpc-clear)
    (mpc-add (completing-read "Choose a song: " (mpc-ls)))
    (mpc-play))

#+end_src

*** MPV
The mpv package lets us start an mpv process & puppeteer it with emacs. I'm definitely not using it to its full potential.
=efs/mpv-browse-url= originates from https://karthinks.com/software/lazy-elfeed/
#+NAME: Mpv
#+begin_src nix :noweb yes
  programs.emacs.init.usePackage.mpv = {
    enable = true;
    command = ["efs/mpv-browse-url" "efs/mpv-eww-url"];
    config = ''
    <<Emacs Mpv Config>>
  '';
  };

  programs.mpv = {
    enable = true;
    package = (config.lib.nixGL.wrap pkgs.mpv);
    config = {
      fs = "no";
      hwdec = "auto";
      x11-bypass-compositor = "no";
      volume-max = "250";
    };
  };
#+end_src

#+NAME: Emacs Mpv Config
#+begin_src emacs-lisp
  (defun efs/mpv-browse-url (url &optional single)
    (mpv-play-url url))

  (defun efs/mpv-eww-url ()
    (interactive)
    (mpv-play-url (eww-current-url)))
#+end_src

*** Pulseaudio Control
#+NAME: Emacs Pulseaudio Control
#+begin_src nix
  pulseaudio-control = {
    enable = true;
    custom.pulseaudio-control-volume-step = ''"5%"'';
    general = {
      "<XF86AudioRaiseVolume>" = "'pulseaudio-control-increase-sink-volume";
      "<XF86AudioLowerVolume>" = "'pulseaudio-control-decrease-sink-volume";
      "<XF86AudioMute>" = "'pulseaudio-control-toggle-current-sink-mute";
      "s-v" = "'pulseaudio-control-default-sink-mode";
    };
  };
#+end_src

** Sagemath
Sagemath is my goto for dealing with complex math. It makes for a wonderful maple replacement.
#+begin_src nix :tangle sage.nix :noweb yes
  { pkgs, ... }:
  {
    home.packages = with pkgs; [ sage ];

    <<Sage Emacs>>

    home.file.".config/sage/ipython-5.0.0/profile_default/startup/00nix.py".text = ''
      <<sage-config>>
    '';
  }
#+end_src

*** Useful functions
I wrote these to help me with a class I was taking. I don't really use them anymore
#+NAME: sage-config
#+begin_src python-ts
  # Combo functions
  def permutation(n, r):
    return factorial(n)/factorial(n - r)

  def combo(n, r):
    return permutation(n, r)/factorial(r)

  # Probstats functions
  def pbinary(n, p, x):
    """Returns the probability of a binary distribution"""
    return combo(n, x)*(p**x)*((1-p)**(n-x))

  def ebinary(n, p):
    """Returns the expectation (mean) of a binary distribution"""
    return n*p

  def ppoisson(x, lam):
    """Returns the probability of the poisson distribution"""
    return (exp(-lam)*lam**x)/factorial(x)
  def poisprocess(lam, s, t, n):
    """Returns the probability of the poisson process
          lam: lambda (the rate)
          s: the start time
          t: the end time
          n: the number of occurrances"""
    return (((lam*(t - s))**n)*exp(-lam*(t - s)))/factorial(n)

  def expecpoisprocess(lam, s, t):
    """Returns the expectancy of a poisson process
         lam: lambda (the rate)
          s: the start time
          t: the end time"""
    return lam*(t-s)

  def pnormal(x, mu, sigma):
    """Returns the probability of a normal random variable
       x: the other variable
       mu: the expectancy
       sigma: the variance"""
    return exp(-((x-mu)**2)/(2*sigma))/sqrt(2*pi*sigma)
#+end_src

*** Emacs
Putting =:session= in an org block is necessary for evaluation
,cgo clears your sage buffer.
,cc evaluates the sage commands in an org file.
#+NAME: Sage Emacs
#+begin_src nix
  programs.emacs.init.usePackage = {
    sage-shell-mode = {
      enable = true;
      defer = true;
      custom."sage-shell-edit:display-function" = ''"display-buffer"'';
      config = ''(sage-shell:define-alias)'';
      generalOne."efs/leader-keys"."S" = '''(run-sage :which-key "sage")'';
      generalTwo."local-leader"."sage-shell-mode-map"."h" = "'sage-shell:help";
    };

    ob-sagemath = {
      enable = true;
      afterCall = ["sage-shell-mode" "ob"];
    };
  };
#+end_src

** Internet
#+begin_src nix :tangle internet.nix :noweb yes
  { inputs, config, pkgs, pkgs-stable, lib, ... }:

  {
    home.packages = with pkgs; [
      pkgs-stable.python39Packages.adblock
    ];

    programs.emacs.init.usePackage = {
      <<Emacs Internet Browse URL>>

      <<Emacs Internet EWW>>

      <<Emacs Internet Yeetube>>

      # <<Emacs Internet Ement>>

      <<Emacs Internet Webjump>>

      <<Emacs Internet Elfeed>>
    };

    <<Internet Qutebrowser>>
  }
#+end_src

*** Browse URL
This lets us decide how emacs will handle certain urls
+ Under most circumstances, a youtube link will be opened by mpv (notable exception being if we're searching)
You need regexes to do this, & you can build them easily using =rx=
#+NAME: Emacs Internet Browse URL
#+begin_src nix
  browse-url = {
    enable = true;
    config = "(defun qutebrowser-browse-url (url &rest args) (qutebrowser-open-url url 'tab))";
    custom = {
      browse-url-handlers = ''
        '(("https:\\/\\/www\\.youtu\\.*be." . efs/mpv-browse-url)
          ("https:\\/\\/yewtu\\.*be." . efs/mpv-browse-url)
          ("https:\\/\\/inv\\.*nadeko\\.*net\\/watch." . efs/mpv-browse-url)
          ("search\\.nixos\\.org[^z-a]*" . qutebrowser-browse-url)
          ("melpa\.org\.*" . qutebrowser-browse-url)
          ("." . (lambda (url &rest args) (eww url (prefix-numeric-value 4)))))
      '';
      browse-url-secondary-browser-function = "'browse-url-default-browser";
    };
  };

#+end_src

*** EWW
It's a simple text based web browser. I use it for short web searches & for finding youtube videos
#+NAME: Emacs Internet EWW
#+begin_src nix :noweb yes
  eww = {
    enable = true;
    custom = {
      eww-search-prefix = ''"https://search.inetol.net/?q="'';
      eww-header-line-format = false;
      eww-desktop-remove-duplicates = true;
      eww-download-directory = ''(expand-file-name "~/dwn")'';
      eww-history-limit = "10";
      # External Browser
      eww-use-external-browser-for-content-type = ''"\\`\\(video/\\|audio\\)"''; # On GNU/Linux check your mimeapps.list
      eww-browse-url-new-windowis-tab = false;
      eww-form-checkbox-selected-symbol = ''"[X]"'';
      eww-form-checkbox-symbol = ''"[ ]"'';
      eww-auto-rename-buffer = "'title";
    };
    generalTwo."'normal".eww-mode-map = {
      "N" = "#'eww-back-url";
      "I" = "#'eww-forward-url";
      "P" = "#'eww-copy-page-url";
      "R" = "'eww-readable";
    };
    init = ''
      <<Emacs Internet Eww Config>>
    '';
  };
#+end_src

#+NAME: Emacs Internet Eww Config
#+begin_src emacs-lisp
  (with-eval-after-load 'evil-collection-eww
    (general-add-advice 'evil-collection-eww-setup
  		      :after
  		      '(lambda ()
  			 (general-def 'normal eww-mode-map
  			   "d" 'evil-yank
  			   "p" 'efs/mpv-eww-url))))
#+end_src

*** Yeetube
#+NAME: Emacs Internet Yeetube
#+begin_src nix
yeetube = {
  enable = true;
  custom.yeetube-play-function = "'mpv-play-url";
  generalOne."efs/leader-keys"."y" = '''(yeetube-search :which-key "search")'';
  generalTwo."'normal"."yeetube-mode-map" = {
    "RET" = "'yeetube-play";
    "r" = "'yeetube-channel-videos";
    "s" = "'yeetube-channel-search";
    "d" = "'yeetube-download-video";
  };
};
#+end_src

*** Ement
Ement username: @holscherhead:matrix.org
Use S-SPC to load old messages
#+NAME: Emacs Internet Ement
#+begin_src nix :noweb yes
  ement = {
    enable = true;
    defer = true;
    generalOne = {
      "efs/leader-keys"."e" = '''(ement-connect :which-key "element")''; 
      local-leader."s" = '''(ement-sidebar :which-key "sidebar")'';
    };
    init = ''
      <<Emacs Internet Ement Init>>
    '';
  };
#+end_src

#+NAME: Emacs Internet Ement Init
#+begin_src emacs-lisp
  (defun ement-sidebar ()
    (interactive)
    (ement-room-list-side-window)
    (with-selected-window (get-buffer-window "*Ement Room List*")
      (gsetq window-size-fixed 'width)
      (window-resize (selected-window) (- 45 (window-total-width)) t t)))
#+end_src

*** Webjump
#+NAME: Emacs Internet Webjump
#+begin_src nix :noweb yes
  webjump = {
    enable = true;
    generalOne."efs/leader-keys"."s" = "'webjump";
    custom.webjump-sites = ''
      '(("DuckDuckGo" . [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
        ("Invidious" . [simple-query "inv.nadeko.net" "inv.nadeko.net/search?q=" ""])
        ("Aur" . [simple-query "aur.archlinux.org" "aur.archlinux.org/packages/?K=" ""])
        ("Nixpkgs" . [simple-query "search.nixos.org" "search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=" ""])
        ("Curseforge" . webjump-to-curseforge))
    '';
    config = ''
      <<Emacs Internet Webjump Config>>
    '';
  };
#+end_src

https://search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=vesktop
#+NAME: Emacs Internet Webjump Config
#+begin_src emacs-lisp
  (defun webjump-to-curseforge (name)
    (let* ((prefix "legacy.curseforge.com/minecraft/")
           (category (completing-read "Choose a category" '("mc-mods" "modpacks" "shaders" "data-pack" "texture-packs")))
  	 (url (concat prefix category))
  	 (term (webjump-read-string (concat name " Search for"))))
      (concat url "/search?search=" (webjump-url-encode term))))
#+end_src

*** Elfeed
#+NAME: Emacs Internet Elfeed
#+begin_src nix
  elfeed = {
    enable = true;
    defer = true;
    custom.elfeed-feeds = '''("https://lukesmith.xyz/index.xml"
                              "https://youtube.com/feeds/videos.xml?channel_id=UCSJPFQdZwrOutnmSFYtbstA"
                              "https://planet.emacslife.com/atom.xml"
                              "https://youtube.com/feeds/videos.xml?channel_id=UC_GQ4mac4oN3wl1UdbFuTEA"
                              "https://youtube.com/feeds/videos.xml?channel_id=UC6UBbvEA8uh6Ulc6ax1Zs0g"
                              "https://youtube.com/feeds/videos.xml?channel_id=UCNzZD3otfZVlIdvYYRRqNSw"
                              "https://youtube.com/feeds/videos.xml?channel_id=UCnnkTXnyn0uZzmArZO99Klg"
                              "https://youtube.com/feeds/videos.xml?channel_id=UCq-VIBjS6Ia1r1IR_j-7NUw"
                              "https://youtube.com/feeds/videos.xml?channel_id=UC0E_vIe1e1lVeojYOgVg_5Q"
                              "https://youtube.com/feeds/videos.xml?channel_id=UCUQs6rEz6lRGHn6DWqss0hA"
                              "https://notrelated.xyz/rss")
      '';
    generalOne."efs/leader-keys"."r" = '''((lambda () (interactive) (elfeed) (elfeed-update)) :which-key "rss")'';
  };

#+end_src

*** Qutebrowser
https://greasyfork.org/en/scripts/374833-yt2invidio
#+NAME: Internet Qutebrowser
#+begin_src nix :noweb yes
  programs.qutebrowser = {
    enable = true;
    enableDefaultBindings = true;
    package = (config.lib.nixGL.wrap pkgs-stable.qutebrowser);

    <<Internet Qutebrowser Keybinds>>

    <<Internet Qutebrowser Greasemonkey>>

    <<Internet Qutebrowser Aliases>>

    <<Internet Qutebrowser Search>>
    
    settings = {
      <<Internet Qutebrowser Privacy>>

      <<Internet Qutebrowser Dir>>

      <<Internet Qutebrowser Transparency>>

      <<Internet Qutebrowser File Selection>>

      <<Internet Qutebrowser Tabs>>

      <<Internet Qutebrowser Links>>

    };

    <<Internet Qutebrowser Extraconfig>>
  };

  <<Internet Qutebrowser Emacs Integration>>
#+end_src

**** Keybinds
https://redlib.northboot.xyz/r/qutebrowser/comments/eh10i7/config_share_qute_with_emacs_keybindings/
#+NAME:Internet Qutebrowser Keybinds
#+begin_src nix
  keyBindings = {
    normal = {
      "m" = "search-next";
      "M" = "search-prev";
      "e" = "fake-key <Down>";
      "o" = "fake-key <Up>";
      "O" = "scroll-page 0 -0.5";
      "E" = "scroll-page 0 0.5";
      "<ctrl-o>" = "scroll-page 0 -1";
      "<ctrl-e>" = "scroll-page 0 1";
      "t" = "mode-enter insert";
      "I" = "forward";
      "i" = "fake-key <Right>";
      "n" = "fake-key <Left>";
      "N" = "back";
      "k" = "hint links spawn mpv {hint-url}";
      "h" = "spawn --userscript emacsclient-wrapper '(qutebrowser-launcher)'";
      "H" = "spawn --userscript emacsclient-wrapper '(qutebrowser-launcher-tab)'";
      ";l" = "spawn --userscript qute-pass";
      ";u" = "spawn --userscript qute-pass --username-only";
      ";p" = "spawn --userscript qute-pass --password-only";
      ";o" = "spawn --userscript qute-pass --otp-only";
      ";P" = "spawn --userscript emacsclient-wrapper '(qutebrowser-pass \"{url}\")'";
      "a" = "cmd-set-text :";
      "<ctrl-f>" = "hint links spawn mpv {hint-url}";
    };
  };
#+end_src

**** Greasemonkey Scripts
#+NAME: Internet Qutebrowser Greasemonkey
#+begin_src nix :noweb yes
  greasemonkey = [
    (pkgs.fetchurl {
  		url = "https://raw.githubusercontent.com/afreakk/greasemonkeyscripts/1d1be041a65c251692ee082eda64d2637edf6444/youtube_sponsorblock.js";
  		sha256 = "sha256-e3QgDPa3AOpPyzwvVjPQyEsSUC9goisjBUDMxLwg8ZE=";
  	})
    (pkgs.fetchurl {
  		url = "https://raw.githubusercontent.com/afreakk/greasemonkeyscripts/refs/heads/master/youtube_adblock.js";
  		sha256 = "sha256-AyD9VoLJbKPfqmDEwFIEBMl//EIV/FYnZ1+ona+VU9c=";
  	})
  ];
#+end_src

**** Aliases
#+NAME: Internet Qutebrowser Aliases
#+begin_src nix
  aliases = {
          "q" = "quit";
          "w" = "session-save";
          "wq" = "quit --save";
        };
#+end_src

**** Autoconfig & Search Engines
#+NAME: Internet Qutebrowser Search
#+begin_src nix
  loadAutoconfig = false;
  searchEngines = {
    "DEFAULT" = "https://search.inetol.net/search?q={}";
  };
#+end_src

**** Some privacy Settings
#+NAME: Internet Qutebrowser Privacy
#+begin_src nix
  content = {
    blocking = {
      enabled = true;
      method = "both";
      adblock.lists = [
        "https://easylist.to/easylist/easylist.txt"
        "https://easylist.to/easylist/easyprivacy.txt"
        "https://easylist.to/easylist/fanboy-social.txt"
        "https://secure.fanboy.co.nz/fanboy-annoyance.txt"
        "https://easylist-downloads.adblockplus.org/abp-filters-anti-cv.txt"
        #"https://gitlab.com/curben/urlhaus-filter/-/raw/master/urlhaus-filter.txt"
        "https://pgl.yoyo.org/adservers/serverlist.php?showintro=0;hostformat=hosts"
        "https://raw.githubusercontent.com/DandelionSprout/adfilt/master/NorwegianExperimentalList%20alternate%20versions/NordicFiltersABP-Inclusion.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/legacy.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters-2020.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters-2021.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/badware.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/privacy.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/badlists.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/annoyances.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/resource-abuse.txt"
        "https://www.i-dont-care-about-cookies.eu/abp/"
        "https://secure.fanboy.co.nz/fanboy-cookiemonster.txt"
        "https://github.com/uBlockOrigin/uAssets/raw/master/filters/unbreak.txt"
        "https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/quick-fixes.txt"
      ];
    };
    autoplay = false;
    cookies.store = false;
    geolocation = false;
    private_browsing = true;
  };
  completion = {
    cmd_history_max_items = 0;
    web_history.max_items = 0;
  };
#+end_src

**** Download Dir & Startpage
#+NAME: Internet Qutebrowser Dir
#+begin_src nix
  downloads.location.directory = "~/dwn";
  url = {
    default_page = "https://search.inetol.net";
    start_pages = "https://search.inetol.net";
  };
#+end_src

**** Transparency
This is a very ugly way of doing things
#+NAME: Internet Qutebrowser Transparency
#+begin_src nix
  window.transparent = true;
  colors = {
    completion = {
      category = {
        bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
        border = {
          bottom = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
          top = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
        };
      };
      even.bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
      odd.bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
    };
    statusbar = {
      command = {
        bg = lib.mkForce ("#50" + config.lib.stylix.colors.base00);
        private.bg = lib.mkForce ("#50" + config.lib.stylix.colors.base00);
      };
    };
  };
#+end_src

**** File Selection
#+NAME: Internet Qutebrowser File Selection
#+begin_src nix
  fileselect = {
    handler = "external";
    single_file.command = [
      "emacsclient"
      "{}"
    ];
    folder.command = [
      "emacsclient"
      "{}"
    ];
    multiple_files.command = [
      "emacsclient"
      "{}"
    ];
  };
#+end_src

**** WM Related
#+NAME: Internet Qutebrowser Tabs
#+begin_src nix
  tabs = {
    tabs_are_windows = true;
    show = "never";
  };

  window.title_format = "{current_title}";
  new_instance_open_target = "tab-silent";
  statusbar.show = "never";
#+end_src

**** Link Hints
#+NAME: Internet Qutebrowser Links
#+begin_src nix
  hints.chars = "crstbfneia";
#+end_src

**** Extra Config
#+NAME: Qutebrowser Config
#+begin_src python-ts
  config.set('content.cookies.accept', 'no-3rdparty', 'chrome-devtools://*')
  config.set('content.cookies.accept', 'no-3rdparty', 'devtools://*')

  config.set('content.images', True, 'chrome-devtools://*')
  config.set('content.images', True, 'devtools://*')

  config.set('content.javascript.enabled', True, 'chrome-devtools://*')
  config.set('content.javascript.enabled', True, 'devtools://*')
  config.set('content.javascript.enabled', True, 'chrome://*/*')
  config.set('content.javascript.enabled', True, 'qute://*/*')

  config.set('content.notifications.enabled', False, 'https://www.reddit.com')
  config.set('content.notifications.enabled', False, 'https://www.youtube.com')

  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}) AppleWebKit/{webkit_version} (KHTML, like Gecko) {upstream_browser_key}/{upstream_browser_version} Safari/{webkit_version}', 'https://web.whatsapp.com/')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://accounts.google.com/*')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info} rv:110.0) Gecko/20100101 Firefox/119.0', 'https://*.slack.com/*')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://docs.google.com/*')
  config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://drive.google.com/*')

  c.editor.command = ['emacsclient', '{file}']

  c.fonts.default_family = '"Source Code Pro"'
  c.fonts.default_size = '8pt'
  c.fonts.completion.entry = '8pt "Source Code Pro"'
  c.fonts.debug_console = '8pt "Source Code Pro"'
  c.fonts.prompts = 'default_size sans-serif'
#+end_src

#+NAME: Internet Qutebrowser Extraconfig
#+begin_src nix :noweb yes
      extraConfig = ''
        <<Qutebrowser Config>>
      '';
#+end_src

**** Emacs Integration
#+NAME: Internet Qutebrowser Emacs Integration
#+begin_src nix :noweb yes
  programs.emacs.init.usePackage = {
    qutebrowser = {
      enable = true;
      ghook = [
        "('exwm-init-hook 'global-qutebrowser-exwm-mode)"
      ];
      gfhook = [
        "('server-visit-hook 'qute/dired-hook)"
        "('qutebrowser-exwm-mode-hook 'evil-normal-state)"
      ];
      config = ''
      <<Emacs Internet Qutebrowser Config>>
    '';
    };
    qutebrowser-evil = {
      enable = true;
      package = epkgs: epkgs.qutebrowser;
      ghook = [
        "('global-qutebrowser-exwm-mode-hook 'qutebrowser-evil-state-mode)"
      ];
    };
  };
#+end_src

#+NAME: Emacs Internet Qutebrowser Config
#+begin_src emacs-lisp
  (define-minor-mode qute-dired-mode
    "Used for dired buffers qutebrowser is using as a file picker"
    :keymap '())

  (general-def qute-dired-mode-map
          "C-c C-c" #'qute/choose-file)

  (general-def 'normal qute-dired-mode-map
    "i" 'dired-find-file
    "n" 'dired-up-directory)

  (defun qute/choose-file ()
    (interactive)
    (let ((files (dired-get-marked-files)))
      (with-temp-file qute-filename
        (insert (s-join "\n" files)))
      (remove-hook 'dired-mode-hook 'qute-dired-mode)
      (dolist (buffer dired-buffers) (when qute-dired-mode (kill-buffer (cdr buffer))))))

  (defun qute/dired-hook (&optional _)
    (when (s-starts-with? "/tmp/qutebrowser-fileselect" buffer-file-name)
      (setq qute-filename buffer-file-name)
      (kill-buffer)
      (add-hook 'dired-mode-hook 'qute-dired-mode)
      (setq qute-dired-buffers (list (dired "~/")))))
#+end_src

** Keyboard
I use kmonad to manage my keybinds.
Canary is my layout of choice.
#+begin_src nix :tangle keyboard.nix
  { ... }:

  {
    home.file = {
      ".config/kmonad/kmonad.kbd".text = ''
        ;; ** For Linux **
        (defcfg
        input  (device-file "/dev/input/by-path/platform-i8042-serio-0-event-kbd") ;; Change this line for your device
        output (uinput-sink "KMonad output")

        fallthrough true)

        (defsrc
          esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
          grv     1    2    3    4    5    6    7    8    9    0    -    =    bspc      ins     home    pgup
          tab     q    w    e    r    t    y    u    i    o    p    [    ]    \         del     end     pgdn
          caps    a    s    d    f    g    h    j    k    l    ;    '    ret
          lsft    z    x    c    v    b    n    m    ,    .    /    rsft                         up
          lctl    lmet lalt           spc            ralt    rctl                       left    down    right)

        (defalias
          def  (tap-macro nlck (layer-switch canary)) ;; Bind 'def' to canary Layer
          caps  (tap-macro nlck (layer-switch canary-shift)) ;; Bind 'def' to canary Layer
          cesc (tap-hold 200 esc (layer-toggle extend))
          sesc (tap-hold 200 S-esc (layer-toggle extend))
          num (sticky-key 500 (layer-toggle num))
          qwerty (tap-macro nlck (layer-switch qwerty)) ;; Bind 'def' to canary Layer
          smet (sticky-key 500 lmet)
          salt (sticky-key 500 lalt)
          sshft (sticky-key 500 lshft)
          spc (tap-hold 200 spc caps)
          SPC (tap-hold 200 S-spc caps)
          c (tap-hold 200 c lmet)
          r (tap-hold 200 r lalt)
          s (tap-hold 200 s lctl)
          t (tap-hold 200 t (layer-toggle canary-shift))
          a (tap-hold 200 a lmet)
          i (tap-hold 200 i lalt)
          e (tap-hold 200 e lctl)
          n (tap-hold 200 n (layer-toggle canary-shift))
          C (tap-hold 200 C lmet)
          R (tap-hold 200 R lalt)
          S (tap-hold 200 S lctl)
          A (tap-hold 200 A lmet)
          I (tap-hold 200 I lalt)
          E (tap-hold 200 E lctl)
          wlft C-left
          wrht C-right
          bhst A-left
          fhst A-right)
        (deflayer canary
          esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
          $       &    [    {    }    \(   =    *    \)   +    ]    !    `    bspc      ins     home    pgup
          tab     w    l    y    p    k    z    x    o    u    ;    -    @    \         del     end     pgdn
          @cesc   @c   @r   @s   @t   b    f    @n   @e   @i   @a   '    ret
          shft   j    v    d    g    q    m    h    /    ,    .    @sshft                      up
          caps   @smet @num           @spc             caps     rctl                    left    down    right)

        (deflayer canary-shift
          S-esc   S-f1 S-f2 S-f3 S-f4 S-f5 S-f6 S-f7 S-f8 S-f9 S-f10 S-f11 S-f12        S-prnt  S-slck  S-pause
          ~       %    7    5    3    1    9    0    2    4    6    8    #  S-bspc      S-ins   S-home  S-pgup
          S-tab   W    L    Y    P    K    Z    X    O    U    :    \_   ^    S-\        S-del   S-end   S-pgdn
          @sesc   @C   @R   @S   T    B    F    N   @E   @I   @A    "    S-ret
          @sshft   J    V    D    G    Q    M    H    ?    <    >    @sshft                     S-up
          caps   @smet @def           @SPC             caps    rctl                   S-left S-down S-right)

        (deflayer qwerty
          esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
          grv     1    2    3    4    5    6    7    8    9    0    -    =    bspc      ins     home    pgup
          tab     q    w    e    r    t    y    u    i    o    p    [    ]    \         del     end     pgdn
          caps    a    s    d    f    g    h    j    k    l    ;    '    ret
          lsft    z    x    c    v    b    n    m    ,    .    /    rsft                         up
          lctl    lmet lalt           spc            @def     rctl                     left    down    right)

        (deflayer extend
          _       _    _    _    _    _    _    _    _    _    _    _    _              _    _    _
          _     f11    f7   f5   f3   f1   f9  f10   f2   f4   f6   f8  f12   _         _    _    _
          _   @bhst @fhst  C-z  C-x   C-c  C-z @wlft up  @wrht  _    _    _    _         _    _    _
          _   @smet @salt lctl @sshft del bspc left down right _    _    _
          _         _    _  @caps    _    _    _    h    _    _    _    _                      _
          _       _    _               ret              @qwerty        _                     _    _    _)
      
        (deflayer num
          _       _    _    _    _    _    _    _    _    _    _    _    _              _    _    _
          _     f11    f7   f5   f3   f1   f9  f10   f2   f4   f6   f8  f12   _         _    _    _
          _       \_    =    +    -    [    ]    7    8    9   &    ^    _    _         _    _    _
          _   @smet @salt lctl @sshft  {    }    4    5    6   0    *    _
          _        @    !    $     \(  ~  \)    1    2    3    #    _                      _
          _       _    _               ret              _        _                     _    _    _)
      '';
        
      ".Xmodmap".text = ''
        clear lock
        clear mod3
        clear mod4
        keycode 66 = Hyper_R
        keycode 105 = Caps_Lock
        add mod3 = Hyper_L Hyper_R
        add mod4 = Super_L Super_R
      '';
    };
  }
#+end_src

