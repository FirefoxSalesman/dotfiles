#+title: Holscher's Home Manager Config
#+startup: overview
#+auto_tangle: t
* Flake
#+begin_src nix-ts :noweb yes :tangle flake.nix
{
  description = "Nixos config flake";

  inputs = {
    <<Flake Inputs>>
  };

  outputs = { self, home-manager, nixgl, nixpkgs, nixpkgs-stable, stylix, emacs-init, ... }@inputs:
    let
      <<Flake Repo Definitions>>
    in
      {
        gpuWrappers = nixgl.defaultPackage;
        # gpuWrappers = nixgl.nixGLNvidia;
        homeConfigurations."holschcc" = home-manager.lib.homeManagerConfiguration {
          <<Flake Home Manager Definition>>
        } ;
      };
}
#+end_src

** Inputs
#+NAME: Flake Inputs
#+begin_src nix-ts
nixpkgs.url = "github:nixos/nixpkgs/nixos-unstable";
nixpkgs-stable.url = "github:nixos/nixpkgs/nixos-24.11";
emacs-overlay.url  = "github:nix-community/emacs-overlay";

stylix.url = "github:danth/stylix";

apple-fonts.url = "github:Lyndeno/apple-fonts.nix";

emacs-init.url = "github:firefoxsalesman/NixEmacs";

home-manager = {
  url = "github:nix-community/home-manager";
  inputs.nixpkgs.follows = "nixpkgs";
};

nixgl = {
  url = "github:nix-community/nixGL"; 
  inputs.nixpkgs.follows = "nixpkgs";
};

kmonad = {
  url = "github:kmonad/kmonad?submodules=1&dir=nix";
  inputs.nixpkgs.follows = "nixpkgs";
};

# packages
gptel-quick = {
  url = "github:karthink/gptel-quick";
  flake = false;
};

ragmacs = {
  url = "github:positron-solutions/ragmacs";
  flake = false;
};

macher = {
  url = "github:kmontag/macher";
  flake = false;
};

repeaters = {
  url = "github:mmarshall540/repeaters";
  flake = false;
};

app-launcher = {
  url = "github:SebastienWae/app-launcher";
  flake = false;
};

emacs-embark = {
  url = "github:oantolin/embark";
  flake = false;
};

dired-single = {
  url = "github:firefoxsalesman/dired-single";
  flake = false;
};

ezf = {
  url = "github:firefoxsalesman/ezf";
  flake = false;
};

doom-nano-modeline = {
  url = "github:ronisbr/doom-nano-modeline";
  flake = false;
};

org-novelist = {
  url = "github:sympodius/org-novelist";
  flake = false;
};

mpc-wrapper = {
  url = "github:FirefoxSalesman/mpc-wrapper";
  flake = false;
};

exwm-outer-gaps = {
  url = "github:firefoxsalesman/exwm-outer-gaps";
  flake = false;
};

exwm-qutebrowser = {
  url = "github:lrustand/qutebrowser.el/18f98f0";
  flake = false;
};

#+end_src

** Outputs
*** Repo Definitions
#+NAME: Flake Repo Definitions
#+begin_src nix-ts
system = "x86_64-linux";

pkgs = import nixpkgs {
  inherit system;
  config.allowUnfree = true;
  overlays = [
    (final: prev: import ./overlay.nix final prev pkgs inputs)
    inputs.emacs-init.overlay
    inputs.emacs-overlay.overlay
  ];
};
pkgs-stable = import nixpkgs-stable {
  inherit system;
  config.allowUnfree = true;
};
#+end_src

*** Home Manager Definition
#+NAME: Flake Home Manager Definition
#+begin_src nix-ts
inherit pkgs;
extraSpecialArgs = {
  inherit self;
  inherit inputs;
  inherit system;
  inherit (inputs)  apple-fonts doom-utils repeaters ezf dired-single launcher doom-nano-modeline gptel-quick org-novelist mpc-wrapper exwm-qutebrowser exwm-outer-gaps;
  inherit pkgs-stable;
};
modules = [
  ./home.nix
  stylix.homeModules.stylix
  emacs-init.homeModules.emacs-init
  emacs-init.homeModules.emacs-presets
];
#+end_src

* Overlay
#+begin_src nix-ts :tangle overlay.nix
final: prev: pkgs: inputs: {
  # shell scripts
  ezf = (import ./scripts/ezf.nix { inherit pkgs; });
  cast = (import ./scripts/cast.nix { inherit pkgs; });
  doomer = (import ./scripts/doomer.nix { inherit pkgs; });
  ffmpeg-bulk = (import ./scripts/ffmpeg-bulk.nix { inherit pkgs; });
  masstube = (import ./scripts/masstube.nix { inherit pkgs; });
  pkg = (import ./scripts/pkg.nix { inherit pkgs; });
  udisksmenu = (import ./scripts/udisksmenu.nix { inherit pkgs; });
  wiki = (import ./scripts/wiki.nix { inherit pkgs; });

  # overrides
  vesktop = (prev.vesktop.override {withSystemVencord = true;});
  mpv = (prev.mpv.override {
    scripts = with prev.mpvScripts; [
      thumbnail
      sponsorblock
    ];
  });

  #emacs packages
  emacsPackagesFor = emacs: (
    (prev.emacsPackagesFor emacs).overrideScope (
      nfinal: nprev: {
        qutebrowser = (prev.emacsPackages.callPackage ./packages/emacs/qutebrowser.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild dash consult exwm password-store evil;
        });
        doom-nano-modeline = (prev.emacsPackages.callPackage ./packages/emacs/doom-nano-modeline.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild doom-themes;
        });
        dired-single = (prev.emacsPackages.callPackage ./packages/emacs/dired-single.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild;
        });
        repeaters = (prev.emacsPackages.callPackage ./packages/emacs/repeaters.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild;
        });
        app-launcher = (prev.emacsPackages.callPackage ./packages/emacs/app-launcher.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild;
        });
        ezf = (prev.emacsPackages.callPackage ./packages/emacs/ezf.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild;
        });
        org-novelist = (prev.emacsPackages.callPackage ./packages/emacs/org-novelist.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild org;
        });
        exwm-outer-gaps = (prev.emacsPackages.callPackage ./packages/emacs/exwm-outer-gaps.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild exwm xelb;
        });
        gptel-quick = (prev.emacsPackages.callPackage ./packages/emacs/gptel-quick.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild gptel;
        });
	macher = (prev.emacsPackages.callPackage ./packages/emacs/macher.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild gptel;
        });
	ragmacs = (prev.emacsPackages.callPackage ./packages/emacs/ragmacs.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild gptel orderless;
        });
	mpc-wrapper = (prev.emacsPackages.callPackage ./packages/emacs/mpc-wrapper.nix {
          inherit inputs;
          inherit (prev.emacsPackages) trivialBuild;
        });
        embark = prev.emacsPackages.callPackage (
          {
            org,
            consult,
            avy,
            compat,
            elpaBuild,
            fetchurl,
            lib,
          }:
          elpaBuild {
            pname = "embark";
            ename = "embark";
            version = "1.1";
            src = fetchurl {
              url = "https://elpa.gnu.org/packages/embark-1.1.tar";
              sha256 = "074ggh7dkr5jdkwcndl6znhkq48jmc62rp7mc6vjidr6yxf8d1rn";
            };
            packageRequires = [
              org
              consult
              avy
              compat
            ];
            meta = {
              homepage = "https://elpa.gnu.org/packages/embark.html";
              license = lib.licenses.free;
            };
          }
        ) { };
      }));
}
#+end_src

* Packages
** Emacs
*** Doom Nano Modeline
#+begin_src nix-ts :tangle packages/emacs/doom-nano-modeline.nix
{ inputs, trivialBuild, doom-themes } :

trivialBuild rec {
  pname = "doom-nano-modeline";
  version = "current";
  src = inputs.doom-nano-modeline;

  propagatedUserEnvPkgs = [
    doom-themes
  ];

  buildInputs = propagatedUserEnvPkgs;
}
#+end_src

*** Dired Single
#+begin_src nix-ts :tangle packages/emacs/dired-single.nix
{ trivialBuild, inputs } :

trivialBuild rec {
  pname = "dired-single";
  version = "current";
  src = inputs.dired-single;
}
#+end_src
*** Repeaters
#+begin_src nix-ts :tangle packages/emacs/repeaters.nix
{ trivialBuild, inputs } :

trivialBuild rec {
  pname = "repeaters";
  version = "current";
  src = inputs.repeaters;
}
#+end_src

*** App Launcher
#+begin_src nix-ts :tangle packages/emacs/app-launcher.nix
{ trivialBuild, inputs } :

trivialBuild rec {
  pname = "app-launcher";
  version = "current";
  src = inputs.app-launcher;
}
#+end_src

*** Ezf
#+begin_src nix-ts :tangle packages/emacs/ezf.nix
{ trivialBuild, inputs } :

trivialBuild rec {
  pname = "ezf";
  version = "current";
  src = inputs.ezf;
}
#+end_src

*** Org Novelist
#+begin_src nix-ts :tangle packages/emacs/org-novelist.nix
{ inputs, trivialBuild, org }:

trivialBuild rec {
  pname = "org-novelist";
  version = "current";
  src = inputs.org-novelist;

  propogatedUserEnvPkgs = [
    org
  ];

  buildInputs = propogatedUserEnvPkgs;
}
#+end_src

*** EXWM Outer Gaps
#+begin_src nix-ts :tangle packages/emacs/exwm-outer-gaps.nix
{ inputs, trivialBuild, xelb, exwm } :

trivialBuild rec {
  pname = "exwm-outer-gaps";
  version = "current";
  src = inputs.exwm-outer-gaps;

  propagatedUserEnvPkgs = [
    xelb
    exwm
  ];

  buildInputs = propagatedUserEnvPkgs;
}
#+end_src

*** GPT.el quick
#+begin_src nix-ts :tangle packages/emacs/gptel-quick.nix
{ inputs, trivialBuild, gptel } :

trivialBuild rec {
  pname = "gptel-quick";
  version = "current";
  src = inputs.gptel-quick;

  propagatedUserEnvPkgs = [
    gptel
  ];

  buildInputs = propagatedUserEnvPkgs;
}
#+end_src

*** Macher
#+begin_src nix-ts :tangle packages/emacs/macher.nix
{ inputs, trivialBuild, gptel } :

trivialBuild rec {
  pname = "macher";
  version = "current";
  src = inputs.macher;

  propagatedUserEnvPkgs = [
    gptel
  ];

  buildInputs = propagatedUserEnvPkgs;
}
#+end_src

*** Ragmacs
#+begin_src nix-ts :tangle packages/emacs/ragmacs.nix
{ inputs, trivialBuild, gptel, orderless } :

trivialBuild rec {
  pname = "ragmacs";
  version = "current";
  src = inputs.ragmacs;

  propagatedUserEnvPkgs = [
    orderless
    gptel
  ];

  buildInputs = propagatedUserEnvPkgs;
}
#+end_src

*** MPC Wrapper
#+begin_src nix-ts :tangle packages/emacs/mpc-wrapper.nix
{ trivialBuild, inputs } :

trivialBuild rec {
  pname = "mpc-wrapper";
  version = "current";
  src = inputs.mpc-wrapper;
}
#+end_src

*** Qutebrowser
#+begin_src nix-ts :tangle packages/emacs/qutebrowser.nix
{ trivialBuild, inputs, consult, exwm, password-store, dash, evil, doom-modeline } :

trivialBuild rec {
  pname = "qutebrowser";
  version = "current";
  src = inputs.exwm-qutebrowser;

  propagatedUserEnvPkgs = [
    consult
    exwm
    password-store
    dash
    evil
    doom-modeline
  ];

  buildInputs = propagatedUserEnvPkgs;
}
#+end_src

* Notes to my future self
+ To get eduroam working, you need ppp & pptclient
+ Don't let xorg use the nvidia card. It breaks everything

* Scripts
** Cast
For moving massive quantities of Jordan Peterson's podcast into my mp3 player
#+begin_src nix-ts :tangle scripts/cast.nix
{ pkgs }:

  pkgs.writeShellScriptBin "cast" ''
    #Exit on fail
    set -e

    #Set Input & Output Filetypes
    in=$(${pkgs.coreutils}/bin/printf 'm4a\nopus\nmp4\nmkv\nwebm' | ${pkgs.ezf}/bin/ezf)
    out=$(${pkgs.coreutils}/bin/printf 'mp3\nflac\nwav\nogg' | ${pkgs.ezf}/bin/ezf)

    #Choose device to transfer to
    device=$(${pkgs.coreutils}/bin/ls /run/media/$USER | ${pkgs.ezf}/bin/ezf)

    #Convert files
    ${pkgs.ffmpeg-bulk}/bin/ffmpeg-bulk *.$in -t $out
    ${pkgs.coreutils}/bin/rm *.$in

    #Remove metadata so the glowies don't see it.
    ${pkgs.python312Packages.mat2}/bin/mat2 *.$out

    #Transfer
    ${pkgs.coreutils}/bin/mv ~/*.cleaned.$out /run/media/$USER/$device/Podcasts
    ${pkgs.coreutils}/bin/rm ~/*.$out
  ''
#+end_src

** Doomer
#+begin_src nix-ts :tangle scripts/doomer.nix
{ pkgs }:

  pkgs.writeShellScriptBin "doomer" ''
    ${pkgs.sox}/bin/sox "$1" "$1.flac" pitch -500 treble -20 pad 0 3 reverb 80 tempo .8 highpass 1000 lowpass 700 compand 0.3,0.8 0
  ''
#+end_src

** Ezf
Borrowed from here: https://github.com/mickeynp/ezf
#+begin_src nix-ts :tangle scripts/ezf.nix
{ pkgs }:

  pkgs.writeShellScriptBin "ezf" ''
    set -o nounset -o errexit -o pipefail

  field=0-
  # the elisp function to use for completing read
  candidate_fn=ezf-default
  while getopts c:f: OPT; do
      case $OPT in
          c)
              candidate_fn=$OPTARG
              ;;
          f)
              field=$OPTARG
              ;;
          ,*)
              ${pkgs.coreutils}/bin/echo "usage: ezf [-f field] [-c candidate-fn]"
              exit 2
      esac
  done
  shift $(( OPTIND - 1 ))
  OPTIND=1

  ezftmp="$(mktemp)"
  trap 'rm -f -- "$ezftmp"' EXIT
  > "$ezftmp" cat -
  # xargs is there to strip the "" from the beginning and end of the
  # output from Emacs.  Ensure "field" is always passed as a string by
  # quoting it.
  selection=$(emacsclient -e "(progn (require 'ezf) (ezf \"$ezftmp\" \"$field\" #'$candidate_fn))" | xargs)
  if [[ "$selection" == "nil" ]]; then
      exit 1
  else
     ${pkgs.coreutils}/bin/echo "$selection"
  fi

  ''
#+end_src

** Ffmpeg-bulk
I stole this from this git repo https://github.com/sylsau/ffmpeg-bulk
#+begin_src nix-ts :tangle scripts/ffmpeg-bulk.nix
{ pkgs }:

pkgs.writeShellScriptBin "ffmpeg-bulk" ''
#!/bin/bash - 
#===============================================================================
#
#		  USAGE: ./this.sh --help
# 
#	DESCRIPTION: Create a ffmpeg conversion script from a list of input files.
# 
#		OPTIONS: ---
#  REQUIREMENTS: sed, gawk, ffmpeg, tee
#		   BUGS: ---
#		  NOTES: ---
#		 AUTHOR: Sylvain Saubier (ResponSyS), mail@sylsau.com
#		CREATED: 01/05/16 14:09
#===============================================================================

[[ $DEBUG ]] && set -o nounset
set -o pipefail -o errexit -o errtrace
trap 'echo -e "''${FMT_BOLD}ERROR''${FMT_OFF}: at $FUNCNAME:$LINENO"' ERR

readonly FMT_BOLD='\e[1m'
readonly FMT_UNDERL='\e[4m'
readonly FMT_OFF='\e[0m'

readonly PROGRAM_NAME="''${0##*/}"
readonly SCRIPT_NAME="''${0##*/}"
RES="$( stat -c %y $0 | cut -d" " -f1 )"
readonly VERSION=''${RES//-/}

readonly ERR_NO_CMD=60

FFMPEG="''${FFMPEG:-ffmpeg}"
OPT_EXT=
OPT_ARGS_IN=
OPT_ARGS_OUT=
OPT_FORCE=
OPT_LOGLEVEL="-loglevel error"
INPUT=( )


# $1 = command to test (string)
fn_need_cmd() {
        if ! command -v "$1" > /dev/null 2>&1
                then fn_err "need '$1' (command not found)" $ERR_NO_CMD
        fi
}
# $1 = message (string)
m_say() {
        echo -e "$PROGRAM_NAME: $1"
}
# $1 = error message (string), $2 = return code (int)
fn_err() {
        m_say "''${FMT_BOLD}ERROR''${FMT_OFF}: $1" >&2
        exit $2
}

fn_help() {
        cat << EOF
$PROGRAM_NAME v$VERSION
        Convert multiple media files at once with ffmpeg.
        In pure and secure bash.
REQUIREMENTS
        ffmpeg
USAGE
        $PROGRAM_NAME FILES... (--to|-t) EXTENSION [--args-in|-ai INPUT_ARGS] [--args-out|-ao OUTPUT_ARGS] [--force|-f] [--log-level LOG_LEVEL]
OPTIONS AND ARGUMENTS
        EXTENSION 		format of output files
        INPUT_ARGS 		ffmpeg arguments for the input file
        OUTPUT_ARGS		ffmpeg arguments for the output file
        --force			overwrite files 
        LOG_LEVEL		change ffmpeg '-loglevel'
                                (default: 'error', ffmpeg default: 'info')
EXAMPLE
        Convert all flac and wav files in the current directory to opus with the specified options:
                $ $PROGRAM_NAME *.flac -t opus --args-out "-b:a 320k" *.wav
SEE ALSO
        ffmpeg(1)
AUTHOR
        Written by Sylvain Saubier
REPORTING BUGS
        Mail at: <feedback@sylsau.com>
EOF
}

fn_show_params() {
        m_say "\n input=''${INPUT[*]}\n -t=$OPT_EXT\n -ai=$OPT_ARGS_IN\n -ao=$OPT_ARGS_OUT\n -f=$OPT_FORCE\n -q=$OPT_LOGLEVEL" >&2
}


fn_need_cmd "$FFMPEG"

# Check args
if [[ -z "$@" ]]; then
        fn_help
        exit
else
        while [[ $# -gt 0 ]]; do
                case "$1" in
                        "--help"|"-h")
                                fn_help
                                exit
                                ;;
                        "--to"|"-t")
                                OPT_EXT=$2
                                shift
                                ;;
                        "--args-in"|"-ai")
                                OPT_ARGS_IN=$2
                                shift
                                ;;
                        "--args-out"|"-ao")
                                OPT_ARGS_OUT=$2
                                shift
                                ;;
                        "--force"|"-f")
                                OPT_FORCE="-y"
                                ;;
                        "--log-level")
                                OPT_LOGLEVEL="-loglevel $2"
                                shift
                                ;;
                        ,*)
                                [[ -e "$1" ]] || fn_err "file '$1' does not exist" 127
                                INPUT+=( "$1" )
                                ;;
                esac	# --- end of case ---
                shift 	# delete $1
        done
fi

[[ $DEBUG ]] && fn_show_params

[[ $OPT_EXT ]] || fn_err "please specify the output extension with -t EXT" 2

# Rajoute un point à l'extension si absent
if [[ ''${OPT_EXT:0:1} != '.' ]]; then
        OPT_EXT=.$OPT_EXT
fi

m_say "converting...\n---"
for F in "''${INPUT[@]}"; do # Just show the commands
        ${pkgs.coreutils}/bin/echo $FFMPEG $OPT_ARGS_IN -i "$F" $OPT_ARGS_OUT $OPT_FORCE $OPT_LOGLEVEL "''${F%.*}$OPT_EXT"
done ;  ${pkgs.coreutils}/bin/echo "---" ; [[ $DEBUG ]] && exit
for F in "''${INPUT[@]}"; do # Actually execute
        m_say "converting \"$F\"..."
             $FFMPEG $OPT_ARGS_IN -i "$F" $OPT_ARGS_OUT $OPT_FORCE $OPT_LOGLEVEL "''${F%.*}$OPT_EXT"
done

exit
''
#+end_src

** Masstube
#+begin_src nix-ts :tangle scripts/masstube.nix
{ pkgs }:

pkgs.writeShellScriptBin "masstube" ''
  emacsclient ~/.download.txt
  # ${pkgs.yt-dlp}/bin/yt-dlp $1 --verbose -ci --batch-file=~/.download.txt --proxy socks://localhost:9050
  ${pkgs.yt-dlp}/bin/yt-dlp $1 --verbose -ci --batch-file=~/.download.txt 
  ${pkgs.coreutils}/bin/rm ~/.download.txt
''
#+end_src

** Start-ollama
#+begin_src nix-ts :tangle scripts/start-ollama.nix
{ config, pkgs }:

pkgs.writeShellScriptBin "start-ollama" ''
  if [[ "$(pidof ollama)" -gt 0 ]]; then
      echo "ollama already running"
  else
      ollama serve
  fi
''
#+end_src

** Pkg
A package manager manager

Dev templates: https://github.com/the-nix-way/dev-templates
#+begin_src nix-ts :tangle scripts/pkg.nix
{ pkgs }:

pkgs.writeShellScriptBin "pkg" ''
  optimize() {
    nix-collect-garbage -d
    nix-store --optimise
    doas pacman -Sc --noconfirm
  }

  update() {
    nix flake update --flake ~/.config/home-manager/
    home-manager switch --flake ~/.config/home-manager/#holschcc
    doas nix flake update --flake /etc/system-manager/
    doas nix run 'github:numtide/system-manager' -- switch --flake '/etc/system-manager/'
    yay -Syu
  }

  help() {
    ${pkgs.coreutils}/bin/echo "help: display this message"
    ${pkgs.coreutils}/bin/echo "install [packages]: install packages with yay"
    ${pkgs.coreutils}/bin/echo "optimize: clean up package cache"
    ${pkgs.coreutils}/bin/echo "update: update all packages"
    ${pkgs.coreutils}/bin/echo "add: install a package"
    ${pkgs.coreutils}/bin/echo "rm: uninstall a package"
    ${pkgs.coreutils}/bin/echo "flake: perform a nix flake operation"
    ${pkgs.coreutils}/bin/echo "template: set up a devshell template"
    ${pkgs.coreutils}/bin/echo "tmp: temporarily install a package"
  }

  getTemplates() {
    ${pkgs.coreutils}/bin/printf "bun\nc-cpp\nclojure\ncsharp\ncue\ndhall\nelixir\nelm\nempty\ngleam\ngo\nhashi\nhaskell\nhaxe\njava\njupyter\nkotlin\nlatex\nnickel\nnim\nnix\nnode\nocaml\nopa\nphp\nplatformio\nprotobuf\npulumi\npurescript\npython\nr\nruby\nrust\nrust-toolchain\nscala\nshell\nswi-prolog\nswift\nvlang\nzig" | ${pkgs.ezf}/bin/ezf
  }

  template() {
    nix flake init --template "https://flakehub.com/f/the-nix-way/dev-templates/*#$(getTemplates)" 
    ${pkgs.direnv}/bin/direnv allow
  }

  case "$1" in
    optimize ) optimize ;;
    update ) update ;;
    add ) yay -S ''${@:2} ;;
    rm ) yay -Rs ''${@:2} ;;
    flake ) nix flake ''${@:2} ;;
    tmp ) nix-shell -p ''${@:2};;
    template ) template;;
    help ) help ;;
  esac
''
#+end_src
** i3status-rust
#+begin_src nix-ts :tangle scripts/i3status-rust.nix
{ pkgs }:

pkgs.writeShellScriptBin "i3status-rust" ''
${pkgs.i3status-rust}/bin/i3status-rs config-default.toml
''
#+end_src

** Udisksmenu
#+begin_src nix-ts :tangle scripts/udisksmenu.nix
{ pkgs }:

pkgs.writeShellScriptBin "udisksmenu" ''
action=$(${pkgs.coreutils}/bin/printf 'mount\nunmount' | ${pkgs.ezf}/bin/ezf)
disk=$(${pkgs.coreutils}/bin/ls /dev | ${pkgs.ripgrep}/bin/rg sd[a-z] | ${pkgs.ezf}/bin/ezf)

${pkgs.udisks}/bin/udisksctl $action -b /dev/$disk
''
#+end_src

** Wiki
Requires arch-wiki-docs to be installed

Stole it from Derek Taylor
#+begin_src nix-ts :tangle scripts/wiki.nix
{ pkgs }:

pkgs.writeShellScriptBin "wiki" ''
dir="/usr/share/doc/arch-wiki/html/en/"
doc="$(${pkgs.findutils}/bin/find $dir -iname "*.html" | \
       ${pkgs.coreutils}/bin/cut -d '/' -f8- | \
${pkgs.ezf}/bin/ezf)"

if [ "''${dir}$doc" ]; then
    emacsclient -e "(eww-open-file \"''${dir}$doc\")"
else
    ${pkgs.coreutils}/bin/echo "Program terminated." && exit 0
fi
''
#+end_src

* Home Manager
** Main Config
*** Inputs & Imports
#+begin_src nix-ts :noweb yes :tangle home.nix
{ lib, config, inputs, ... }:

{
  # This is some text
  # Home Manager needs a bit of information about you and the paths it should
  # manage.
  home.username = "holschcc";
  home.homeDirectory = "/home/holschcc";

  # This value determines the Home Manager release that your configuration is
  # compatible with. This helps avoid breakage when a new Home Manager release
  # introduces backwards incompatible changes.
  #
  # You should not change this value, even if you update Home Manager. If you do
  # want to update the value, then make sure to first check the Home Manager
  # release notes.
  home.stateVersion = "23.05"; # Please read the comment before changing.

  # Let Home Manager install and manage itself.
  programs.home-manager.enable = true;

  imports =
    [ # Include the results of the hardware scan.
      ./internet.nix
      ./multimedia.nix
      ./aesthetics.nix
      ./extra-packages.nix
      ./development.nix
      ./gui.nix
      ./emacs.nix
      ./shells.nix
      ./gptel.nix
      ./sage.nix
      ./keyboard.nix
    ];

  nix.nixPath = [ "nixpkgs=${inputs.nixpkgs}" ];

  <<glx>>

  <<GPG>>

  <<alsoftrc>>

  <<Environment Variables>>

  <<User Dirs>>
}
#+end_src

*** glx
#+NAME: glx
#+begin_src nix-ts
nixGL.packages = inputs.nixgl.packages;

targets.genericLinux.enable = true;

home.activation = {
  clearNixglCache = lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      [ -v DRY_RUN ] || rm -f ${config.xdg.cacheHome}/nixgl/result*
    '';
};
#+end_src

*** gpg
#+NAME: GPG
#+begin_src nix-ts
home.file.".local/share/gnupg/gpg-agent.conf".text = ''
   pinentry-program /usr/bin/pinentry-emacs
   allow-loopback-pinentry
   allow-emacs-pinentry
   default-cache-ttl 600
   max-cache-ttl 7200
   enable-ssh-support
'';
home.file.".local/share/gnupg/gpg.conf".text = ''
   use-agent
'';
#+end_src

*** alsoftrc
#+NAME: alsoftrc
#+begin_src nix-ts
home.file.".alsoftrc".text = ''
  [general]
  drivers=pulse
  hrtf=true
'';
#+end_src

*** Environment variables
#+NAME: Environment Variables
#+begin_src nix-ts
home.sessionVariables = {
  XDG_DATA_HOME="$HOME/.local";
  XDG_STATE_HOME="$HOME/.local/state";
  XDG_CACHE_HOME="$HOME/.cache";
  XDG_CONFIG_HOME="$HOME/.config";
  XDG_DATA_DIRS= lib.mkForce "$HOME/.nix-profile/share:$XDG_DATA_DIRS";
  # EDITOR = "emacsclient";
  BROWSER="qutebrowser";
  _JAVA_OPTIONS="-Djava.util.prefs.userRoot=$XDG_CONFIG_HOME/java";
  GTK2_RC_FILES="/home/holschcc/.gtkrc-2.0";
  SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)";
  _JAVA_AWT_WM_NONREPARENTING = "1";
  PATH="/run/system-manager/sw/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/holschcc/bin:/home/holschcc/.nix-profile/bin";
};
#+end_src

*** User Dirs
#+NAME: User Dirs
#+begin_src nix-ts
xdg.userDirs = {
    enable = true;
    createDirectories = true;
    desktop = null;
    publicShare = null;
    templates = null;
    documents = "${config.home.homeDirectory}/doc";
    download = "${config.home.homeDirectory}/dwn";
    music = "${config.home.homeDirectory}/mus";
    pictures = "${config.home.homeDirectory}/pic";
    videos = "${config.home.homeDirectory}/vid";
};
#+end_src

** shells
*** boilerplate
#+begin_src nix-ts :noweb yes :tangle shells.nix
{ pkgs, ... }:
{
  imports = [
    ./dash.nix
  ];

  <<Shell Aliases>>

  programs = {
    <<Fish Shell>>

    <<Bash Shell>>

    <<Starship>>

    direnv.enableBashIntegration = true;

    <<Dash Shell>>

    emacs.init.usePackage = {
      <<Eshell>>
    };
  };
}
#+end_src

*** aliases
#+NAME: Shell Aliases
#+begin_src nix-ts
home.shellAliases = {
  ffrecord = "ffmpeg -f sndio -i snd/0.mon -f x11grab -r 30 -s 1920x1080 -i :0 -c:v libx164 -preset ultrafast -acodec copy ~/test.mkv";
  ffaud = "ffmpeg -f alsa -channels 1 -sample_rate 44100 -i default:CARD=Mic output.flac";
  sx = "startx";
  otp = "pass otp";
  run = "cd /run/";
  l = "ls";
  ".." = "cd ..";
  tortube = "yt-dlp --proxy socks://localhost:9050";
  wget = "torsocks wget --hsts-file=$XDG_DATA_HOME/wget-hsts";
  ga = "git add";
  gc = "torsocks git clone";
  gp = "git pull";
  gP = "git push";
};
#+end_src

*** fish
This shell is mostly around for eshell to get completions from, but it can be used interactively, if need be
#+NAME: Fish Shell
#+begin_src nix-ts
fish = {
  enable = true;
  package = pkgs.fish;
  interactiveShellInit = ''${pkgs.pfetch}/bin/pfetch'';
};
#+end_src

*** bash
It's mostly here for eshell to get completions from, but it's a usable shell
#+NAME: Bash Shell
#+begin_src nix-ts
bash = {
  enable = true;
  initExtra = ''${pkgs.pfetch}/bin/pfetch'';
  shellAliases.z = "cd ./$(ls -d */ .*/ | ${pkgs.ezf}/bin/ezf)";
};
#+end_src

*** starship
a prompt for bash & fish
#+NAME: Starship
#+begin_src nix-ts
starship = {
  enable = true;
  enableFishIntegration = true;
  enableBashIntegration = true;
};
#+end_src

*** Eshell
Eshell is a command shell written in elisp, & duplicates many of the GNU coreutils in elisp. It can also call aliases & elisp functions.

=Key Bindings=
+ =[[= / =]]= Go backwards & forwards in the buffer's prompts.

Eat lets us get away with using eshell all the time. It can be used to get into a normal shell, but I doubt I'll be doing that too much.
#+NAME: Eshell
#+begin_src nix-ts :noweb yes
eshell = {
  enable = true;
  babel = "eshell";
  after = ["evil-collection"];
  ghookf = [
    "('eshell-first-time-mode 'efs/configure-eshell)"
    #Save command history when commands are entered
    "('eshell-precommand 'eshell-save-some-history)"
    #pfetch
    ''('eshell-banner-load (lambda ()
                                       (gsetq eshell-banner-message
                                          (shell-command-to-string "${pkgs.pfetch}/bin/pfetch"))))''
  ];
  general."s-<enter>" = "'efs/make-eshell";
  generalOne.eshell-mode-map = {
    "M-o" = "'eshell-previous-matching-input-from-input";
    "M-e" = "'eshell-next-matching-input-from-input";
  };
  generalTwo.local-leader.eshell-mode-map = {
    "e" = '''(eshell-insert-envvar :which-key "insert environment variable")'';
    "b" = '''(eshell-insert-buffer-name :which-key "insert buffer name")'';
  };
  init = ''
    <<Emacs Eshell Init>>
  '';
  config = ''
    <<Emacs Eshell Config>>
  '';
};

eshell-syntax-highlighting = {
  enable = true;
  defer = true;
  ghookf = ["('eshell-mode 'eshell-syntax-highlighting-global-mode)"];
};

fish-completion = {
  enable = true;
  defer = true;
  ghookf = ["('eshell-mode 'fish-completion-mode)"];
  gfhookf = ["('fish-completion-mode (local! completion-at-point-functions '(tempel-complete pcomplete-completions-at-point)))"];
};

eshell-git-prompt = {
  enable = true;
  afterCall = ["eshell-mode"];
  config = ''(eshell-git-prompt-use-theme 'powerline)'';
};

eat = {
  enable = true;
  defer = true;
  afterCall = ["eshell-mode"];
  config = ''
    <<Emacs Eat Config>>
  '';
};

evil-collection-eshell = {
  enable = true;
  defer = true;
  generalTwoConfig.":n".eshell-mode-map = {
    "v" = "'evil-collection-eshell-evil-delete";
    "V" = "'evil-collection-eshell-evil-change";
    "C-v" = "'evil-collection-eshell-evil-delete-line";
  };
  config = ''
    <<Emacs Evil Eshell Config>>
  '';
};
#+end_src

#+NAME: Emacs Eshell Init
#+begin_src emacs-lisp
(defun efs/make-eshell ()
  (interactive)
  (eshell 'N))
#+end_src

#+NAME: Emacs Eshell Config
#+begin_src emacs-lisp
(defun efs/configure-eshell ()
  ;; Truncate buffer for perforance
  (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

  ;; Bind some useful keys for evil-mode
  (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
  (evil-normalize-keymaps)
  (setenv "TERM" "xterm")
  (gsetq eshell-command-aliases-list '(("gc" "torsocks git clone")
  				       ("nixbuild" "home-manager switch --flake ~/.config/home-manager/#holschcc")
  				       ("l" "ls $*")
  				       ("halt" "doas shutdown -P now")
				       ("reboot" "doas reboot")
  				       ("systembuild" "doas nix run 'github:numtide/system-manager' -- switch --flake '/etc/system-manager/'"))
  	 eshell-history-size 0
         eshell-buffer-maximum-lines 100
         eshell-hist-ignoredups t
         eshell-scroll-to-bottom-on-input t))

(with-eval-after-load 'esh-opt
  (gsetq eshell-destroy-buffer-when-process-dies t))
#+end_src

#+NAME: Emacs Evil Eshell Config
#+begin_src emacs-lisp
(general-add-advice 'evil-collection-eshell-setup-keys :after
		    (lambda () (general-def 'normal eshell-mode-map
				 "d" 'evil-yank
				 "D" 'evil-yank-line
				 "c" 'evil-visual-state
				 "C" 'evil-visual-line)))
#+end_src

#+NAME: Emacs Eat Config
#+begin_src emacs-lisp
(eat-eshell-mode)
(evil-ex-define-cmd "term" 'eat)
(defun eat-term-get-suitable-term-name (&optional display)
  "Return the most suitable value for `TERM' for DISPLAY.

    If the number of colors supported by display (as returned by
    `display-color-cells') is more than 256, return \"eat-truecolor\", if
    it is more than 8 but less than or equal to 256, return
    \"eat-256color\", if is more than 1 but less than or equal to 8,
    return \"eat-color\", otherwise return \"eat-mono\"."
  (let ((colors (display-color-cells display)))
    (cond ((> colors 256) "xterm")
          ((> colors 8) "xterm")
          ((> colors 1) "xterm")
          (t "xterm"))))

#+end_src

*** dash
Probably won't use this one interactively much, but it's my login shell, & my /bin/sh, so it may as well be nice
#+NAME: Dash Shell
#+begin_src nix-ts
dash = {
  enable = true;
  initExtra = ''
    ${pkgs.pfetch}/bin/pfetch
    . ~/.cache/wal/colors.sh
  '';
  shellAliases.z = "cd ./$(ls -d */ .*/ | ${pkgs.ezf}/bin/ezf)";
  profileExtra = ''
    export LEIN_HOME="$XDG_DATA_HOME/lein";
    export NPM_CONFIG_USERCONFIG="$XDG_CONFIG_HOME/npm/npmrc";
    export XCOMPOSECACHE="$XDG_CACHE_HOME/x11/xcompose";
    export GOPATH="$XDG_DATA_HOME/go";
    export DOT_SAGE="$XDG_CONFIG_HOME/sage";
    # export XAUTHORITY="$XDG_RUNTIME_DIR/Xauthority";
    export CARGO_HOME="$XDG_DATA_HOME/cargo";
    export GNUPGHOME="$XDG_DATA_HOME/share/gnupg";
    export PASSWORD_STORE_DIR="$XDG_DATA_HOME/share/pass";
    export CUDA_CACHE_PATH="$XDG_CACHE_HOME/nv";
    export ERRFILE="$XDG_CACHE_HOME/X11/xsession-errors"
    export XINITRC="$XDG_CONFIG_HOME"/X11/xinitrc
    export HISTFILE="''${XDG_STATE_HOME}"/bash/history
    GRADLE_USER_HOME="$XDG_DATA_HOME"/gradle
    
    [ "$(tty)" = "/dev/tty1" ] && ! pidof -s Xorg >/dev/null 2>&1 && exec startx
  '';
};
#+end_src

**** Configuration template
This one borrows heavily from the bash module

Special note: The profile settings here take precedence over bash's, because I'm too dumb to make them coexist

***** Premble
#+begin_src nix-ts :noweb yes :tangle dash.nix
{ config, lib, pkgs, ... }:

with lib;

let

  cfg = config.programs.dash;

  writeBashScript = name: text:
    pkgs.writeTextFile {
      inherit name text;
      checkPhase = ''
        ${pkgs.stdenv.shellDryRun} "$target"
      '';
    };

in {
  meta.maintainers = [ maintainers.rycee ];
  <<Dash Option Definitions>>
  
  <<Dash File Generation>>
}
#+end_src

***** Option Definitions
#+NAME: Dash Option Definitions
#+begin_src nix-ts
options = {
  programs.dash = {
    enable = mkEnableOption "Debian Almquiest Shell";

    shellOptions = mkOption {
      type = types.listOf types.str;
      default = [];
      example = [ "extglob" "-cdspell" ];
      description = ''
        Shell options to set. Prefix an option with
        "`-`" to unset.
      '';
    };

    sessionVariables = mkOption {
      default = { };
      type = types.attrs;
      example = { MAILCHECK = 30; };
      description = ''
        Environment variables that will be set for the dash session.
      '';
    };

    shellAliases = mkOption {
      default = { };
      type = types.attrsOf types.str;
      example = literalExpression ''
        {
          ll = "ls -l";
          ".." = "cd ..";
        }
      '';
      description = ''
        An attribute set that maps aliases (the top level attribute names in
        this option) to command strings or directly to build outputs.
      '';
    };

    profileExtra = mkOption {
      default = "";
      type = types.lines;
      description = ''
        Extra commands that should be run when initializing a login
        shell.
      '';
    };

    initExtra = mkOption {
      default = "";
      type = types.lines;
      description = ''
        Extra commands that should be run when initializing an
        interactive shell.
      '';
    };

    dashrcExtra = mkOption {
      default = "";
      type = types.lines;
      description = ''
        Extra commands that should be placed in {file}`~/.dashrc`.
        Note that these commands will be run even in non-interactive shells.
      '';
    };
  };
};
#+end_src

***** File generation
#+NAME: Dash File Generation
#+begin_src nix-ts
config = let
  aliasesStr = concatStringsSep "\n"
    ((mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
      cfg.shellAliases) ++ 
    (mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
      config.home.shellAliases));

  globalAliasesStr = concatStringsSep "\n"
    (mapAttrsToList (k: v: "alias ${k}=${escapeShellArg v}")
      home.shellAliases);

  shoptsStr = let switch = v: if hasPrefix "-" v then "-u" else "-s";
  in concatStringsSep "\n"
  (map (v: "shopt ${switch v} ${removePrefix "-" v}") cfg.shellOptions);

  sessionVarsStr = config.lib.shell.exportAll cfg.sessionVariables;

in mkIf cfg.enable {
  home.file.".profile".source = lib.mkForce (writeBashScript "profile" ''
    . "${config.home.profileDirectory}/etc/profile.d/hm-session-vars.sh"

    ${sessionVarsStr}

    ${cfg.profileExtra}
  '');

  home.file.".dashrc".source = writeBashScript "dashrc" ''
    ${cfg.dashrcExtra}

    ${shoptsStr}

    ${aliasesStr}

    ${cfg.initExtra}
  '' ;

  home.sessionVariables.ENV = "$HOME/.dashrc";
};
#+end_src

** Aesthetics
*** Inputs
#+begin_src nix-ts :noweb yes :tangle aesthetics.nix
  { config, inputs, lib, pkgs, ... }:

  {
    <<Stylix Config>>

    <<Aesthetics Picom>>

    programs.emacs.init.usePackage = {
      <<Aesthetics Prettify Symbols>>

      <<Emacs Ricing Icons>>
      
      <<Emacs Ricing Dashboard>>
      
      <<Emacs Ricing Nano>>

      <<Emacs Ricing Theme>>
      
      <<Emacs Ricing Solaire>>
      
      <<Emacs Ricing Posframes>>
    };
  }
#+end_src

*** Picom
For making emacs transparent
#+NAME: Aesthetics Picom
#+begin_src nix-ts
  services.picom = {
    enable = true;
    package = (config.lib.nixGL.wrap pkgs.picom);
    backend = "glx";
    opacityRules = [ "70:class_g = 'lmms'" ];
    settings = {
      glx-no-stencil = true;
      glx-no-rebind-pixmap = true;
      use-damage = true;
      vsync = true;
      blur = {
        method = "gaussian";
        size = 5;
        deviation = 2.0;
      };
      shadow-exclude = [ "class_g != 'emacs'"
      ];
    };
    shadow = true;
  };
#+end_src

*** Stylix
Stylix does a bad job of theming emacs, so we use pywal instead

Pywal integration: https://github.com/danth/stylix/issues/99
#+NAME: Stylix Config
#+begin_src nix-ts
  stylix = {
    enable = true;
    polarity = "dark";
    targets = {
      vencord.enable = false;
      vesktop.enable = true;
      emacs.enable = false;
    };
    image = ./wallpaper.png;
    cursor = {
      package = pkgs.nordzy-cursor-theme;
      name = "Nordzy-cursors-white";
      size = 16;
    };
    opacity = {
      applications = 0.9;
      popups = 0.9;
      terminal = 0.9;
    };
    fonts = with pkgs; rec {
      monospace = {
        package = jetbrains-mono;
        name = "JetBrains Mono";
      };
      sansSerif = {
        package = inputs.apple-fonts.packages.${system}.sf-pro;
        name = "SF Pro";
      };
      serif = sansSerif;
    };
  };

  home.file = {
    ".cache/colors.json".source = config.lib.stylix.colors {
      template = builtins.readFile ./pywal.json.mustache;
      extension = ".json";
    };
  };

  home.activation =  #ALSO ACTIVATES AT REBOOT
    {
      generate_pywal_colors = lib.hm.dag.entryAfter ["writeBoundary"] ''
         $DRY_RUN_CMD ${pkgs.pywal}/bin/wal -f ~/.cache/colors.json
         $DRY_RUN_CMD ${pkgs.pywal}/bin/wal -R
       '';
    } ;
#+end_src

*** Icons
Installs all the icon fonts for dired.

Use =M-x all-the-icons-install-fonts=
#+NAME: Emacs Ricing Icons
#+begin_src nix-ts
  nerd-icons = {
    enable = true;
    command = [
      "nerd-icons-octicon"
      "nerd-icons-faicon"
      "nerd-icons-flicon"
      "nerd-icons-wicon"
      "nerd-icons-mdicon"
      "nerd-icons-codicon"
      "nerd-icons-devicon"
      "nerd-icons-ipsicon"
      "nerd-icons-pomicon"
      "nerd-icons-powerline"
    ];
  };

  all-the-icons = {
    enable = true;
  };

  nerd-icons-completion = {
    enable = true;
    ghookf = ["('marginalia-mode 'nerd-icons-completion-marginalia-setup)"];
  };
#+end_src

*** Prettify Symbols
#+NAME: Aesthetics Prettify Symbols
#+begin_src nix-ts
  prettify-symbols = {
    enable = true;
    ghookf = ["('prog-mode 'prettify-symbols-mode)"];
  };
#+end_src

*** Dashboard
#+NAME: Emacs Ricing Dashboard
#+begin_src nix-ts :noweb yes
  dashboard = {
    enable = true;
    ghookf = ["('on-init-ui '(dashboard-insert-startupify-lists dashboard-initialize))"];
    config = ''
      <<Emacs Dashboard Config>>  
    '' ;
    custom = {
      dashboard-banner-logo-title = ''"Emacs: The one true desktop environment"'';
      dashboard-center-content = true;
      dashboard-items = '''((recents   . 5)
                            (bookmarks . 5)
                            (projects  . 5)
                            (agenda    . 5))'';
      dashboard-icon-type = "'nerd-icons";
      dashboard-set-heading-icons = true;
      dashboard-set-file-icons = true;
      dashboard-agenda-sort-strategy = "'(time-up)";
    };
  };
#+end_src

#+NAME: Emacs Dashboard Config
#+begin_src emacs-lisp
  (dashboard-setup-startup-hook)
  (dashboard-open)
  (evil-collection-dashboard-setup)
  (evil-collection-dashboard-setup-jump-commands)
#+end_src

*** Nano
Using nano modeline to cut down clutter.

I'm not using the minor mode, because its text is being sent to the tab bar.

The powerline separators were borrowed from punchline, because I think they look cool
#+NAME: Emacs Ricing Nano
#+begin_src nix-ts :noweb yes
  doom-nano-modeline = {
    enable = true;
    afterCall = ["after-init-hook"];
    custom.mode-line-format = false;
    config = ''
      <<Emacs Doom Nano Modeline Config>>
    '';
  };
#+end_src

This is just overriding a bunch of functions so that I can put all the info in the tab bar
#+NAME: Emacs Doom Nano Modeline Config
#+begin_src emacs-lisp
  (defun doom-nano-modeline--render (left right &optional hide-evil-mode)
    "Render the doom-nano modeline string.

    LEFT is the information that will be rendered to the left of the modeline. RIGHT
    is the information that will be rendered to the right of modeline. Both
    variables must be a list in which each element has the following syntax:

        (text . face)

    where TEXT will be decorated with FACE.

    If HIDE-EVIL-MODE is nil, the Evil mode state is not shown in the modeline."
    (let* ((window (get-buffer-window (current-buffer)))

           ;; Variable to store if the this window is active.
  	 (active t)

           ;; Status of the buffer.
           (status (doom-nano-modeline-status))

           ;; Check if we are recording a macro and get its name.
           (hasmacro (or defining-kbd-macro executing-kbd-macro))
           (macroname (if (bound-and-true-p evil-this-macro)
                          (char-to-string evil-this-macro)
                        "?"))

           ;; String to indicate the current evil mode.
           (evilstate
            (if hide-evil-mode
                nil
              (concat (cond ((eq evil-state 'emacs)    "E ")
                            ((eq evil-state 'motion)   "M ")
                            ((eq evil-state 'normal)   "N ")
                            ((eq evil-state 'insert)   "I ")
                            ((eq evil-state 'replace)  "R ")
                            ((eq evil-state 'operator) "O ")
                            ((eq evil-state 'god) "G ")
                            ((eq evil-state 'symex) "S ")
                            ((eq evil-state 'visual) (cond ((eq evil-visual-selection 'line)  "L ")
                                                           ((eq evil-visual-selection 'block) "B ")
                                                           (t                                 "V ")))
                            (t "? ")))))

           ;; String to indicate if a macro is being recorded.
           (macrostring (if hasmacro (concat "● " macroname ) nil))

           ;; Select the modeline face.
  	 (modeline-face 'doom-nano-modeline-active-face)

           ;; Select the face to highlight the evil state.
           (evilstate-face
            (cond (hide-evil-mode            modeline-face)
                  ((not active)              modeline-face)
                  ((eq evil-state 'emacs)    'doom-nano-modeline-evil-emacs-state-face)
                  ((or (eq evil-state 'normal) (eq evil-state 'god) (eq evil-state 'symex))   'doom-nano-modeline-evil-normal-state-face)
                  ((eq evil-state 'motion)   'doom-nano-modeline-evil-motion-state-face)
                  ((eq evil-state 'insert)   'doom-nano-modeline-evil-insert-state-face)
                  ((eq evil-state 'replace)  'doom-nano-modeline-evil-replace-state-face)
                  ((eq evil-state 'operator) 'doom-nano-modeline-evil-operator-state-face)
                  ((eq evil-state 'visual)   'doom-nano-modeline-evil-visual-state-face)
                  (t                         modeline-face)))

           ;; Select the face to highlight the macro recording indicator.
           (macro-face (if hasmacro 'doom-nano-modeline-macro-face modeline-face))

           ;; Assemble the left string with the highlights.
           (pleft (concat
                   (propertize " "
                               'face evilstate-face
                               'display `(raise ,doom-nano-modeline-top-padding))

                   ;; Evil state.
                   (when evilstate
                     (concat (propertize evilstate 'face evilstate-face)
                             (propertize " " 'face modeline-face)))

                   ;; Macro recording indicator.
                   (when macrostring
                     (concat (propertize macrostring 'face macro-face)
                             (propertize " " 'face modeline-face)))

                   ;; Left list.
                   (if left
                       (mapconcat
                        (lambda (element)
                          (if (and active (cdr element))
                              (propertize (car element) 'face (cdr element))
                            (propertize (car element) 'face modeline-face)))
                        left
                        "")
                     ""))))

      ;; Concatenate and return the modeline string.
      (concat pleft
              ;; We have one final space as margin, so we make sure it is
              ;; highlighted with the correct face.
              (propertize " " 'face modeline-face))))

  (defun doom-nano-modeline-org-mode-buffer-name-and-major-mode ()
    "Return the buffer name and the major mode for Org buffers."
    (if (derived-mode-p 'org-mode)
        (let* ((org-title (doom-nano-modeline--get-org-title))
               (buffer-name (if org-title
                                org-title
                              (format-mode-line "%b")))
               (buffer-modified (if (and buffer-file-name (buffer-modified-p)) "** " "")))

          `((,(concat buffer-modified buffer-name) . nil)
  	  ("  " . nil)
            (,(nerd-icons-icon-for-buffer) . doom-nano-modeline-major-mode-face)
  	  ("  " . nil)))
      (doom-nano-modeline-default-mode)))

  (defun doom-nano-modeline-buffer-name-vc-and-major-mode ()
    "Return the buffer name and the major mode."
    (let* ((buffer-name (cond
                         ((and (derived-mode-p 'org-mode)
                               (buffer-narrowed-p)
                               (buffer-base-buffer))
                          (format"%s [%s]" (buffer-base-buffer)
                                 (org-link-display-format
                                  (substring-no-properties (or (org-get-heading 'no-tags)
                                                               "-")))))
                         ((and (buffer-narrowed-p)
                               (buffer-base-buffer))
                          (format"%s [narrow]" (buffer-base-buffer)))
                         (t
                          (format-mode-line "%b"))))

           (buffer-modified (if (and buffer-file-name (buffer-modified-p)) "** " ""))

           (vc-branch-name (doom-nano-modeline--get-vc-branch))

           (vc-branch (if vc-branch-name
                          `((vc-branch-name . nil))
                        nil)))

      `((,(concat buffer-modified buffer-name) . nil)
        ("  " . nil)
        (,(if vc-branch-name (concat vc-branch-name " ") "") . doom-nano-modeline-vc-branch-name-face)
        (,(if vc-branch-name " " "") . nil)
        (,(if (or (equal major-mode 'nix-mode) (equal major-mode 'bibtex-mode)) (all-the-icons-icon-for-buffer) (nerd-icons-icon-for-buffer)) . doom-nano-modeline-major-mode-face)
        ("  " . nil))))

  (defun doom-nano-modeline--special-mode-p ()
    "Return t if we are in `special-mode' or nil otherwise."
    (or (derived-mode-p 'special-mode) (and (eq major-mode 'exwm-mode) (not qutebrowser-exwm-mode))))

  (defun doom-nano-tabline ()
    "Format the modeline for the tabline"
    (let* ((the-format '((:eval
  			(funcall
  			 (or (catch 'found
  			       (dolist (elt doom-nano-modeline-mode-formats)
  				 (let* ((config (cdr elt))
  					(mode-p (plist-get config :mode-p))
  					(format (plist-get config :format)))
  				   (when mode-p
  				     (when (funcall mode-p)
  				       (throw 'found format))))))
  			     #'doom-nano-modeline-default-mode-format))))))
      `((global menu-item ,(format-mode-line the-format) ignore))))
#+end_src

*** Emacs Theme
Makes emacs' theme mimic the wallpaper. A good pywal config will get most things to match.
#+NAME: Emacs Ricing Theme
#+begin_src nix-ts :noweb yes
  ewal = {
    enable = true;
    demand = true;
    custom = {
      ewal-use-built-in-always-p = false;
      ewal-use-built-in-on-failure-p = true;
      ewal-built-in-palette = ''"sexy-material"'';
    };
  };

  ewal-doom-themes = {
    enable = true;
    demand = true;
    config = ''
      <<Emacs Ewal Config>>
    '';
    custom = {
      doom-themes-enable-bold = true;
      doom-themes-enable-italic = true;
    };
  };
#+end_src

#+NAME: Emacs Ewal Config
#+begin_src emacs-lisp
  (load-theme 'ewal-doom-one t)
  ;; Stolen from Noctuid
  (let (custom--inhibit-theme-enable)
    (custom-theme-set-faces
     'ewal-doom-one
     `(font-lock-number-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-header-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-header-delimiter-face ((t (:foreground ,(ewal-get-color 'blue)))))
     `(markdown-bold-face ((t (:foreground ,(ewal-get-color 'green)))))
     `(markdown-list-face ((t (:foreground ,(ewal-get-color 'green)))))
     `(org-code ((t (:foreground ,(ewal-get-color 'green)))))
     `(line-number ((t (:foreground ,(ewal-get-color 'blue)))))
     `(eshell-git-prompt-powerline-dir-face ((t (:background ,(ewal-get-color 'blue)))))
     `(hl-line-face ((t (:background ,(ewal-get-color 'green)))))
     `(solaire-hl-line-face ((t (:background ,(ewal-get-color 'green)))))
     `(tab-bar ((t :inherit mode-line)))
     `(eshell-git-prompt-powerline-clean-face ((t (:background ,(ewal-get-color 'green)))))
     `(eshell-git-prompt-powerline-not-clean-face ((t (:background ,(ewal-get-color 'red)))))))
  (doom-themes-visual-bell-config)
  (doom-themes-org-config)
#+end_src

*** Solaire
Solaire dims certain parts of the frame.
#+NAME: Emacs Ricing Solaire
#+begin_src nix-ts
  solaire-mode = {
    enable = true;
    demand = true;
    config = ''(solaire-global-mode)'';
  };
#+end_src

*** Posframes
Vertico Posframe puts vertico in a separate frame, causing it to actually look like dmenu.
#+NAME: Emacs Ricing Posframes
#+begin_src nix-ts
vertico-posframe = {
  enable = true;
  defer = true;
  ghookf = ["('vertico-mode 'vertico-posframe-mode)"];
  config = ''(set-face-attribute 'vertico-posframe-face nil :family 'variable-pitch)'';
};
#+end_src

*** Mustache File
#+begin_src json-ts :tangle pywal.json.mustache
  {
    "special": {
      "background": "#{{base00-hex}}",
      "foreground": "#{{base07-hex}}",
      "cursor": "#{{base07-hex}}"
    },
    "colors": {
      "color0": "#{{base00-hex}}",
      "color1": "#{{base01-hex}}",
      "color2": "#{{base02-hex}}",
      "color3": "#{{base03-hex}}",
      "color4": "#{{base04-hex}}",
      "color5": "#{{base05-hex}}",
      "color6": "#{{base06-hex}}",
      "color7": "#{{base07-hex}}",
      "color8": "#{{base08-hex}}",
      "color9": "#{{base09-hex}}",
      "color10": "#{{base0A-hex}}",
      "color11": "#{{base0B-hex}}",
      "color12": "#{{base0C-hex}}",
      "color13": "#{{base0D-hex}}",
      "color14": "#{{base0E-hex}}",
      "color15": "#{{base0F-hex}}"
    }
  }

#+end_src

** Extra Packages
#+begin_src nix-ts :tangle extra-packages.nix
{ config, pkgs, pkgs-stable, ... }:

{
  home.packages = with pkgs; [
    (config.lib.nixGL.wrap gimp)
    (config.lib.nixGL.wrap prismlauncher)
    (config.lib.nixGL.wrap blockbench)
    (config.lib.nixGL.wrap tor-browser)
    wget
    zip
    unzip
    zbar
    # comms
    (config.lib.nixGL.wrap teams-for-linux)
    (config.lib.nixGL.wrap thunderbird)
    pkgs-stable.vesktop
    # things emacs appreciates
    xclip
    xsel
    xdotool
    # scripts
    ezf
    pkg
  ];
}
#+end_src

** Gui
#+NAME: xinitrc-config
#+begin_src shell
#!/usr/bin/sh
xrandr --setprovideroutputsource modesetting NVIDIA-0
xrandr --auto
xrandr --dpi 96
# xrandr --output eDP-1 --mode 2560x1600
${pkgs.xwallpaper}/bin/xwallpaper --stretch ~/.config/home-manager/wallpaper.png 
xrdb load ~/.cache/wal/colors.Xresources 

if test -z "$DBUS_SESSION_BUS_ADDRESS"; then
    eval $(dbus-launch --exit-with-session --sh-syntax)
fi

xmodmap ~/.Xmodmap

picom &

if command -v dbus-update-activation-environment >/dev/null 2>&1; then
    dbus-update-activation-environment DISPLAY XAUTHORITY
fi

# exec dbus-launch --exit-with-session emacsclient -c
exec dbus-launch --exit-with-session emacs -mm --debug-init
#+end_src

#+begin_src nix-ts :noweb yes :tangle gui.nix
{ pkgs, ... }:

{
  home.file.".config/X11/xinitrc".text = '' 
    <<xinitrc-config>>
  '' ;
}
#+end_src

** Development
This was more directly stolen than the other parts
I think most of it was from the github page for lsp mode, but it's been a while, & I don't remember much.
https://github.com/joaotavora/eglot/discussions/888
https://gist.github.com/rosholger/e519c04243ae7ccb5bbf7ebef3f1cec2
#+begin_src nix-ts :noweb yes :tangle development.nix
{ config, pkgs, lib, ... }:

{
  programs.emacs.init = {
    ide = {
      project = true;
      flymake = {
        enable = true;
        preset = true;
      };
      symex = true;  
      hoverDoc = true;
      eglot = {
        enable = true;
        preset = true;
      };
      direnv = true;
      languages = {
        bash.enable = true;
        gradle.enable = true;
        java = {
          enable = true;
          moreEglot = true;
        };
        json.enable = true;
        nix.enable = true;
        toml.enable = true;
        xml.enable = true;
        zenscript.enable = true;
        emacs-lisp.enable = true;
        javascript.enable = true;
        ledger.enable = true;
	c.enable = true;
	r.enable = true;
      };
    };

    usePackage = {
      <<Development Misc>>
      
      # lsp-java.custom.lsp-java-content-provider-preferred = ''"fernflower"'';
      <<Development Direnv>>

      <<Development Treesitter>>

      <<Development Project>>

      <<Development Eglot>>
      
      # <<Development Dape>>

      <<Development Python>>
      
      <<Development Makefile>>

      <<Development Yaml>>
      
      racket-mode.gfhookf = ["('racket-mode 'hs-minor-mode)"];

      elisp-mode.gfhookf = ["('emacs-lisp-mode (local! completion-at-point-functions (list (cape-capf-super 'tempel-complete 'elisp-completion-at-point))))"];
      java-ts-mode = {
        init = ''
          <<Java Config>>
        '';  
      };
    };
  };
}
#+end_src

*** Misc
#+NAME: Development Misc
#+begin_src nix-ts
editorconfig = {
  enable = true;
  afterCall = ["on-first-file-hook"];
  config = ''(editorconfig-mode)'';
};

rainbow-delimiters = {
  enable = true;
  ghookf = ["('prog-mode 'rainbow-delimiters-mode)"];
};
#+end_src

*** Treesitter
#+NAME: Development Treesitter
#+begin_src nix-ts
treesit-fold = {
  enable = true;
  ghookf = ["((gen-mode-hooks '(bash-ts c-ts css-ts emacs-lisp erlang-ts go-ts haskell-ts html-ts java-ts js-ts json-ts json5-ts julia-ts kotlin-ts lua-ts make nix-ts python-ts ess-r rustic scala-ts svelte-ts swift-ts toml-ts typescript-ts vimscript-ts yaml-ts zig-ts)) 'treesit-fold-mode)"];
};
#+end_src

*** Java
Borrowed from here:
https://gitlab.com/skybert/my-little-friends/-/blob/master/emacs/.emacs
#+NAME: Java Config
#+begin_src emacs-lisp
(defun tkj/java-decompile-class ()
  "Run the FernFlower decompiler on the current .class file using
 fernflower, and opens the decompiled Java file."
  (interactive)
  (let* ((current-file (buffer-file-name))
         (output-dir (concat (file-name-directory current-file) "decompiled/"))
         (decompiled-file (concat output-dir (file-name-base current-file) ".java"))
         (command (format "fernflower %s %s"
                          (shell-quote-argument current-file)
                          (shell-quote-argument output-dir))))
    (if (and current-file (string-equal (file-name-extension current-file) "class"))
        (progn
          (unless (file-directory-p output-dir)
            (make-directory output-dir t))
          (message "Running FernFlower decompiler...")
          (shell-command command)
          (if (file-exists-p decompiled-file)
              (find-file decompiled-file)
            (message "Error: Decompiled file not found at %s" decompiled-file)))
      (message "Error: This command can only be run on .class files"))))
#+end_src

*** Project
#+NAME: Development Project
#+begin_src nix-ts :noweb yes
magit = {
  enable = true;
  custom.magit-display-buffer-function = "#'magit-display-buffer-same-window-except-diff-v1";
  generalOne.project-prefix-map = {
    "v" = "'magit-status";
    "c" = "'magit-commit";
    "p" = "'magit-pull";
    "P" = "'magit-push";
    "b" = "'magit-branch";
    "m" = "'magit-merge";
  };
};

projection-ibuffer = {
  enable = true;
  generalOne.project-prefix-map.i = "(cmd! () (ibuffer) (ibuffer-filter-by-projection-root (project-current)))";
};

projection-multi.custom.projection-gradle-use-daemon = false;

projection-multi-embark = {
  enable = true;
  after = ["embark" "projection-multi"];
  config = ''(projection-multi-embark-setup-command-map)'';
};
#+end_src

#+NAME: Emacs Development Projection Config
#+begin_src emacs-lisp
(require 'projection)
(global-projection-hook-mode)
(oset projection-project-type-maven build "mvn -B clean compile")
#+end_src

*** Eglot
#+NAME: Development Eglot
#+begin_src nix-ts :noweb yes
eglot = {
  gfhookf = [
    ''('eglot-managed-mode (local! completion-at-point-functions (list (cape-capf-super #'tempel-complete
                                                                                             #'eglot-completion-at-point
											     #'cape-file)
                                                                            #'cape-dabbrev)))''
    "('before-save (lambda () (when eglot--managed-mode (eglot-format-buffer))))"
  ];
  config = ''
    <<Development Eglot Config>>
  '';
  generalTwo.local-leader.eglot-mode-map."r" = "'eglot-rename";
};

eglot-tempel = {
  enable = true;
  after = ["eglot"];
  config = ''(eglot-tempel-mode)'';
};
#+end_src

#+NAME: Development Eglot Config
#+begin_src emacs-lisp
(general-add-advice 'evil-collection-eglot-setup
		    :after '(lambda ()
			      (general-def 'normal eglot-mode-map "K" 'evil-substitute)))
#+end_src

*** Dape
#+NAME: Development Dape
#+begin_src nix-ts
dape = {
  enable = true;
  after = ["eglot"];
  gfhookf = ["('dape-on-stopped (list 'dape-info 'dape-repl))"];
  custom = {
    dape-window-arrangement = "gud";
    dape-key-prefix = ''"\C-x\C-a"'';
  };
};
#+end_src

*** Python
#+NAME: Development Python
#+begin_src nix-ts
python-ts-mode.custom = {
    python-shell-interpreter = ''"ipython"'';
    python-shell-interpreter-args = ''"-i --simple-prompt"'';
};
#+end_src

*** Makefile
#+NAME: Development Makefile
#+begin_src nix-ts
make-mode = {
  enable = true;
  symex = true;
  ghookf = ["('makefile-mode (treesit! 'make))"];
};
#+end_src

*** Yaml
#+NAME: Development Yaml
#+begin_src nix-ts
yaml-ts-mode = {
  enable = true;
  mode = [''"\\.yaml\\'"''];
  extraPackages = [pkgs.yaml-language-server];
  symex = true;
  eglot = ''("yaml-language-server" "--stdio")'';
};
#+end_src

** File Management
I'm running dired with a couple of small packages that improve on it
#+begin_src nix-ts :noweb yes :tangle emacs/file-management.nix
{ inputs, ... }:

{
  programs.emacs.init.usePackage = {
    dired = {
      enable = true;
      gfhookf = ["('dired-mode (list 'dired-omit-mode 'hl-line-mode (local!
        visible-cursor nil)))"];
      general = {
        "C-x C-j" = "'dired-jump";
        "C-x d" = "'consult-dir";
      };
      generalOne.global-leader."d" = '''(dired :which-key "dired")'';
      generalTwo.":n".dired-mode-map."w" = "'wdired-change-to-wdired-mode";
      custom = {
        dired-recursive-deletes = "'always";
        dired-listing-switches = ''"-agho --group-directories-first"'';
        # We're doing our best to get rid of that 1st extraneous line
        dired-free-space = false;
      };
      config = ''(with-eval-after-load 'dired-x (gsetq dired-omit-extensions (delete ".class" dired-omit-extensions)))'';
    };

    openwith = {
      enable = true;
      defer = true;
      ghookf = ["('dired-mode 'openwith-mode)"];
      config = ''
          <<Emacs Openwith Config>>
        '';
    };

    dired-hide-dotfiles = {
      enable = true;
      defer = true;
      ghookf = ["('dired-mode 'dired-hide-dotfiles-mode)"];
      generalTwoConfig.":n".dired-mode-map."H" = "'dired-hide-dotfiles-mode";
    };

    all-the-icons-dired = {
      enable = true;
      ghookf = ["('dired-mode 'all-the-icons-dired-mode)"];
    };

    dired-single = {
      enable = true;
      ghookf = [''
          ('dired-mode (lambda () (general-def 'normal dired-mode-map
               "B" 'evil-goto-line
               "n" 'dired-single-prev
               "i" 'dired-single-next)))
        ''];
    };

    dired-ranger = {
      enable = true;
      ghookf = [''
          ('dired-mode (lambda () (general-def 'normal dired-mode-map
               "d" 'dired-ranger-copy
               "O" 'dired-ranger-move
               "G" 'dired-ranger-paste)))
        ''];
    };

    diredfl = {
      enable = true;
      ghookf = ["('dired-mode 'diredfl-mode)"];
    };

    dired-posframe = {
      enable = true;
      generalTwo.":n".dired-mode-map."M-t" = "'dired-posframe-mode";
    };
    
    image = {
      enable = true;
      gfhookf = ["('image-mode 'image-transform-fit-to-window)"];
      generalTwo.":n".image-map = {
        "E" = "'image-next-file";
        "O" = "'image-previous-file";
      };
      custom.image-animate-loop = true;
    };

    dired-narrow = {
      enable = true;
      generalTwo.":n".dired-mode-map."N" = "'dired-narrow-fuzzy";
    };
  };
}
#+end_src

#+NAME: Emacs Openwith Config
#+begin_src emacs-lisp
(gsetq openwith-associations
       (list
        (list (openwith-make-extension-regexp
               '("ff"))
              "lel"
              '(file))
        (list (openwith-make-extension-regexp
               '("odt" "doc" "docx" "odp" "pptx" "xlsx"))
              "libreoffice"
              '(file))
        (list (openwith-make-extension-regexp
               '("mpg" "mpeg" "mp3" "mp4"
                 "avi" "wmv" "wav" "mov" "flv"
                 "ogm" "ogg" "mkv" "webm" "opus"
                 "flac"))
              "mpv"
              '(file))))

(defun dired-do-async-delete (&optional arg)
  "Delete all marked (or next ARG) files.
  `dired-recursive-deletes' controls whether deletion of
  non-empty directories is allowed."
  ;; This is more consistent with the file marking feature than
  ;; dired-do-flagged-delete.
  (interactive "P")
  (let (markers)
    (dired-internal-do-deletions
     (nreverse
      ;; this may move point if ARG is an integer
      (dired-map-over-marks (cons (dired-get-filename)
                                  (let ((m (point-marker)))
                                    (push m markers)
                                    m))
                            arg))
     arg t)
    (async-start (lambda ()
  		   (dolist (m markers) (set-marker m nil)))
  		 'ignore)))
#+end_src

** Emacs
*** Main
**** Inputs & Imports
#+begin_src nix-ts :tangle emacs.nix :noweb yes
{ config, pkgs, inputs, ... }:

{
  imports = [
    ./emacs/early-init.nix
    ./emacs/evil.nix
    ./emacs/file-management.nix
    ./emacs/help-system.nix
    ./emacs/completion-system.nix
    ./emacs/passwords.nix
    ./emacs/writing.nix
    ./emacs/window-manager.nix
  ];

  programs.emacs = {
    enable = true;
    package = pkgs.emacs30-gtk3;
    extraPackages = epkgs: with epkgs; [ 
      on
      repeaters
      hydra
      pretty-hydra
    ];
    init = {
      enable = true;
      packageQuickstart = false;
      recommendedGcSettings = true;
      usePackageVerbose = false;
      largeFileHandling = true;

      <<Emacs Prelude>>

      usePackage = {

        <<Emacs UI Improvements>>

        <<Emacs Cleanup>>

        <<Emacs Async>>

        <<Emacs Wgrep>>

        <<Emacs Notifications>>
      };

      <<Emacs Postlude>>
    };
  };
}
#+end_src

**** Prelude
#+NAME: Emacs Prelude
#+begin_src nix-ts :noweb yes
prelude =''
  <<emacs-prelude>>
'';
#+end_src

#+NAME: emacs-prelude
#+begin_src emacs-lisp
(defalias 'gsetq #'general-setq)
(general-unbind "C-h")

(use-package pretty-hydra
  :demand t
  :custom
  (hydra-hint-display-type 'posframe)
  :config
  (gsetq hydra-posframe-show-params '(:internal-border-width 1
							     :internal-border-color "003f28"
							     :parent-frame nil
							     :poshandler posframe-poshandler-frame-bottom-center
							     :refposhandler posframe-refposhandler-xwininfo))
  :gfhookf ('doom-escape 'hydra-keyboard-quit))

(use-package repeaters
  :demand t
  :config
  (repeaters-define-maps
   '(("next-error" ;; borrowed from the hydra wiki
      next-error "`"
      next-error "n"
      previous-error "e"))))

(use-package repeat
  :config
  (repeat-mode))

(general-def "H-z" 'repeat)

(defmacro cmd! (&rest body)
  "Returns (lambda () (interactive) ,@body)
A factory for quickly producing interaction commands, particularly for keybinds
or aliases. Stolen from Doom."
  (declare (doc-string 1) (pure t) (side-effect-free t))
  `(quote (lambda (&rest _) (interactive) ,@body)))

(defmacro local! (var body)
  "Creates a lambda that runs setq-local on the variable VAR with the value provided by BODY."
  `(lambda () (setq-local ,var ,body)))

(defun gen-mode-hooks (modes)
  "Takes a list of symbols, MODES, & appends -mode to them."
  (mapcar (lambda (mode)
	    (intern (concat (symbol-name mode) "-mode")))
	  modes))
#+end_src

**** Sensible Defaults
***** UI Improvements
Most of this was shamelessly lifted from Emacs from Scratch.
Display buffer rules were taken from noctuid's config.
https://emacs.stackexchange.com/questions/75528/how-to-define-display-buffer-alist-to-keep-every-buffer-in-the-frame-it-is-curr
#+NAME: Emacs UI Improvements
#+begin_src nix-ts
tooltip = {
  enable = true;
  config = ''
    (tooltip-mode -1)
    (set-fringe-mode -1)
  '';
};

simple = {
  enable = true;
  config = ''
    (gsetq save-interprogram-paste-before-kill t)
    (column-number-mode)
  '';
};

display-line-numbers = {
  enable = true;
  custom = {
    display-line-numbers-type = "'relative";
    display-line-numbers-width = 3;
  }; 
  config = "(global-display-line-numbers-mode)";
  #Disable line numbers for some modes
  ghookf = ["((gen-mode-hooks '(org term dired eww eat markdown help helpful Info Man shell pdf-view elfeed-search elfeed-show eshell racket-repl sage-shell)) (lambda () (display-line-numbers-mode 0)))"];
} ;

server = {
  enable = true;
  deferIncrementally = true;
  config = "(server-start)";
};
#+end_src

***** Cleanup
Emacs has a propensity for leaving garbage lying around. This configuration that I stole from David Wilson should make that stop.

#+NAME: Emacs Cleanup
#+begin_src nix-ts
no-littering = {
  enable = true;
  demand = true;
  #no-littering doesn't set this by default so we must place
  #auto save files in the same path as it uses for sessions
  custom.auto-save-file-name-transforms = ''`((".*" ,(no-littering-expand-var-file-name "auto-save/") t))'';
};
#+end_src

**** Async
Async lets emacs create other instances of itself to run functions. It still has to be passed back to the main instance, but it does help with the single-threadedness.
#+NAME: Emacs Async
#+begin_src nix-ts :noweb yes
async = {
  enable = true;
  config = ''
    <<Emacs Async Config>>
  '';
};
#+end_src

#+NAME: Emacs Async Config
#+begin_src emacs-lisp
(autoload 'dired-async-mode "dired-async.el" nil t)
(dired-async-mode)
#+end_src

**** Wgrep
Wgrep basically turns grep into sed.

=Bindings=
+ C-c C-e: Apply changes
+ C-c C-u: Changes are unmarked & ignored
+ C-c C-d: Mark current line for deletion
+ C-c C-r: Remove changes in region
+ C-c C-p: Toggle read-only
+ C-c C-k: Exit without changes
+ C-x C-q: Exit wgrep
#+NAME: Emacs Wgrep
#+begin_src nix-ts
wgrep = {
  enable = true;
  custom.wgrep-auto-save-buffer = true;
  generalTwo.":n".grep-mode-map."w" = "'wgrep-change-to-wgrep-mode";
};
#+end_src

**** Notifications
Stolen from EDNC's github page.

EDNC does the same thing as dunst. It will pop up any new notifications inside of a text buffer.
#+NAME: Emacs Notifications
#+begin_src nix-ts :noweb yes
ednc = {
  enable = true;
  gfhook = [
    "('ednc-notification-presentation-functions #'show-notification-in-echo-area)"
  ];
  deferIncrementally = true;
  config = ''
    <<Emacs EDNC Config>>
  '';
};
#+end_src

#+NAME: Emacs EDNC Config
#+begin_src emacs-lisp
(ednc-mode)
(defun show-notification-in-echo-area (old new)
  (when new (message (ednc-format-notification new t))))
#+end_src

**** Postlude
#+NAME: Emacs Postlude
#+begin_src nix-ts :noweb yes
postlude = ''
  <<Emacs Postlude Config>>
'';
#+end_src

#+NAME: Emacs Postlude Config
#+begin_src emacs-lisp
;; Stolen from Derek Taylor's config.
(add-to-list 'default-frame-alist '(alpha-background . 90))
;; Display buffer rules
(cl-pushnew (list (rx "*Async Shell Command*" (0+ any)) #'display-buffer-no-window) display-buffer-alist)
(cl-pushnew (list (rx "*Shell Command Output*" (0+ any)) #'display-buffer-no-window) display-buffer-alist)
#+end_src

*** Early Init
All of the repeaters config was origally stolen from Karthinks. I don't think any of the code I stole is actually here anymore, though.
#+begin_src nix-ts :noweb yes :tangle emacs/early-init.nix
{ ... }:

{
  programs.emacs.init = {
    earlyInit = ''
      <<Emacs Early Init>>
    '';
  };
}
#+end_src

#+NAME: Emacs Early Init
#+begin_src emacs-lisp
(scroll-bar-mode -1) ; Disable visible scrollbar
(tool-bar-mode -1) ; Disable the toolbar
(menu-bar-mode -1)

(setq auto-save-visited-file-name t
      warning-minimum-level :error
      use-package-enable-imenu-support t
      make-backup-files nil
      enable-recursive-minibuffers t
      inhibit-startup-message t
      inhibit-startup-screen t
      visible-bell t
      use-short-answers t
      switch-to-buffer-obey-display-actions t
      ;; Scratch is an org mode buffer
      initial-major-mode 'org-mode
      initial-scratch-message ""
      ;;Reduce garbage
      user-emacs-directory "~/.cache/emacs")

(defun efs/display-startup-time ()
  (message "Emacs loaded in %s with %d garbage collections."
           (format "%.2f seconds"
                   (float-time
                    (time-subtract after-init-time before-init-time)))
           gcs-done))

(add-hook 'emacs-startup-hook #'efs/display-startup-time)
#+end_src

*** Evil Mode
My keybinds have been rearranged to work with Canary. Evil is used for the purposes of ergonomics, & all my bindings revolve around it.

Evil mode provides vim-like keybinds.
#+begin_src nix-ts :noweb yes :tangle emacs/evil.nix
{ lib, pkgs, inputs, config, ... }:

{
  programs.emacs.init = {
    keybinds = {
      evil = {
        enable = true;
        surround = true;
        keys = {
          forward = "i";
          backward = "n";
          up = "o";
          down = "e";
          prefer-visual-line = true;
          evil-collection-swap-keys = ''
          "x" "B"
          "X" "b"
          "u" "W"
          "U" "w"
          "j" "u"
          "a" ":"
          "m" "n"
          "M" "N"
          "h" "m"
          "b" "g"
        '';
        };
      };
      leader-key = {
        enable = true;
        globalPrefix = "s";
      };
      doomEscape.enable = true;
      undo.enable = true;
      whichKey = {
        enable = true;
        posframe = {
          enable = true;
          unparent = true;
        };
      };
      god.enable = true;
      electricPair.enable = true;
      evilNerdCommenter.enable = true;
      avy = {
        enable = true;
        evilModifierKey = "H";
      };
    };
    usePackage = {
      <<Emacs Evil Main>>
    
      <<Emacs Evil Extensions>>
    
      <<Emacs Evil Symex>>

      <<Emacs Evil Compats>>
    };
  };
}
#+end_src

**** TODO Main Config
+ [ ] ergovim keys
  https://emacs.stackexchange.com/questions/59223/how-to-assign-a-command-to-g-key-when-using-evil
https://www.hxa.name/articles/content/ergovim-key-mappings_hxa7241_2010.html
+ [X] Dashboard
+ [X] Easymotions
+ [X] What do we do about consult-yank-pop?
+ [ ] Symex
  Very messy
It should be noted that C-g quits out of insert mode. That, like most of this config, was taken from David Wilson's dotfiles.

Differences from the spec:
+ numbers & symbols aren't rebound
#+NAME: Emacs Evil Main
#+begin_src nix-ts :noweb yes
evil = {
  gfhookf = ["('doom-escape 'evil-normal-state)"];
  config = ''
    <<Evil Config>>
  '';
  generalOne = {
    ":i" = {
      "C-s" = "'insert-char";
      "C-k" = "'kill-line";
    };
    ":n"."C-s" = "'evil-write";
  };
  extraConfig = ''
    <<Evil Extra Config>>
  '';
  generalOneConfig = {
    ":n" = {
      "I" = "'evil-window-top";
      "C-i" = "'evil-goto-line";
      "N" = "'evil-window-bottom";
      "C-n" = "'evil-goto-first-line";
      "E" = "'evil-scroll-down";
      "O" = "'evil-scroll-up";
      "x" = "'evil-backward-WORD-begin";
      "X" = "'evil-backward-word-begin";
      "C-x" = "'evil-backward-WORD-end";
      "j" = "'evil-undo";
      "J" = "'evil-redo";
      "a" = "'evil-ex";
      "r" = "'evil-insert-line";
      "R" = "'evil-open-above";
      "s" = "'evil-append-line";
      "S" = "'evil-open-below";
      "t" = "'evil-insert";
      "T" = "'evil-append";
      "C-t" = "'evil-replace-state";
      "u" = "'evil-forward-WORD-begin";
      "U" = "'evil-forward-word-begin";
      "C-u" = "'evil-forward-WORD-end";
      "-" = "'evil-jump-backward";
      "_" = "'evil-jump-forward";
      "m" = "'evil-search-next";
      "M" = "'evil-search-previous";
      "k" = "'evil-delete-char";
      "K" = "'evil-substitute";
      "c" = "'evil-visual-char";
      "C" = "'evil-visual-line";
      "C-c" = "'evil-visual-block";
      "v" = "'evil-delete";
      "V" = "'evil-change";
      "C-v" = "'evil-delete-line";
      "d" = "'evil-yank";
      "D" = "'evil-yank-line";
      "G" = "'evil-paste-after";
      ";" = "'evil-end-of-visual-line";
      ":" = "'evil-end-of-line";
      "C-;" = "'evil-end-of-line";
      "p" = "'ergo-word-delete";
      "P" = "'ergo-word-change";
      "C-p" = "'ergo-word-change";
      "$" = "'evil-execute-macro";
      "~" = "'evil-record-macro";
      "C-z" = "'evil-goto-last-change-reverse";
      "w" = "'evil-repeat";
      "W" = "'evil-ex-repeat";
      "C-w" = "'evil-ex-repeat";
      "l" = "'evil-shift-right-line";
      "L" = "'evil-shift-left-line";
      "C-l" = "'evil-shift-left-line";
      "/" = "'isearch-forward-regexp";
      "?" = "'isearch-backward-regexp";
      "y" = "'evil-shift-right";
      "Y" = "'evil-shift-left";
    };
    ":m" = {
      "I" = "'evil-window-top";
      "C-i" = "'evil-goto-line";
      "N" = "'evil-window-bottom";
      "C-n" = "'evil-goto-first-line";
      "C-e" = "'evil-scroll-page-down";
      "C-o" = "'evil-scroll-page-up";
      "a" = "'evil-ex";
      "h" = "'evil-set-marker";
      "m" = "'evil-search-next";
      "M" = "'evil-search-previous";
      "-" = "'evil-jump-backward";
      "_" = "'evil-jump-forward";
      "/" = "'isearch-forward-regexp";
      "?" = "'isearch-backward-regexp";
      "f" = "'evil-first-non-blank-of-visual-line";
      "F" = "'evil-beginning-of-visual-line";
      "C-f" = "'evil-first-non-blank";
      "B" = "'evil-goto-line";
    };
    ":v" = {
      "U" = "'evil-forward-word-begin";
      "u" = "'evil-forward-WORD-begin";
      "X" = "'evil-backward-word-begin";
      "x" = "'evil-backward-WORD-begin";
      "v" = "'evil-delete-char";
      "V" = "'evil-substitute";
      "C-v" = "'evil-substitute";
      "t" = "evil-outer-text-objects-map";
      "s" = "evil-inner-text-objects-map";
      "l" = "'evil-invert-case";
      "y" = "'evil-shift-right";
      "Y" = "'evil-shift-left";
      "C-t" = "'evil-replace";
      "R" = "'evil-insert-line";
      "C-r" = "'evil-append-line";
      "d" = "'evil-yank-line";
      "D" = "'evil-yank-line";
      "C-d" = "'evil-yank-line";
      "/" = "'isearch-forward-regexp";
      "?" = "'isearch-backward-regexp";
      "G" = "'evil-paste";
    };
  };
};

emacs.generalOne = {
  help-map."A" = ''(cmd! () (async-shell-command "${pkgs.wiki}/bin/wiki"))'';
  global-leader = {
    "l" = ''(cmd! () (if (project-current) (project-compile) (compile (read-string "Compile command: " "make -k"))))'';
    "L" = ''(cmd! () (if (project-current) (project-recompile) (recompile)))'';
    "u" = ''(cmd! () (start-process-shell-command "udisksmenu" nil "${pkgs.udisksmenu}/bin/udisksmenu"))'';
  };
};
#+end_src

#+NAME: Evil Config
#+begin_src emacs-lisp
(evil-ex-define-cmd "q" (cmd! () (prescient--save) (save-buffers-kill-emacs)))
(evil-ex-define-cmd "Undotree" 'vundo)
(evil-ex-define-cmd "k[ill]" 'kill-current-buffer)
(evil-ex-define-cmd "trash" (cmd! () (start-process-shell-command "rm" nil "rm -rf ~/.local/Trash")))

(evil-set-initial-state 'dashboard-mode 'normal)

(dolist (command '(consult-grep
		   consult-line
		   isearch-forward-regexp
		   evilem-motion-previous-visual-line
		   evilem-motion-next-line
		   evilem-motion-forward-WORD-begin
		   evilem-motion-backward-WORD-begin
		   evilem-motion-search-next
		   evilem-motion-search-previous
		   find-file
		   consult-fd))
  (evil-add-command-properties command :jump t))

(evil-define-operator ergo-word-delete (beg end type register yank-handler)
  "Delete word."
  :motion evil-a-word
  (evil-delete beg end type register yank-handler))

(evil-define-operator ergo-word-change (beg end type register yank-handler)
  "Delete word."
  :motion evil-inner-word
  (evil-change beg end type register yank-handler))

(repeaters-define-maps
 '(("flyspell"
    evil-prev-flyspell-error "S"
    evil-next-flyspell-error "s")))
#+end_src

#+NAME: Evil Extra Config
#+begin_src emacs-lisp
:general-config
(general-swap-key nil '(motion normal visual)
  "g" "b"
  "z" "q"
  "Z" "Q")

(:keymaps 'override
	  :states '(normal visual)
	  "g" 'evil-paste-before
	  "z" 'evil-jump-item
	  "Z" 'evil-goto-last-change)

(:keymaps 'override
	  :states '(operator visual)
	  "i" 'evil-forward-char
	  "s" evil-inner-text-objects-map
	  "t" evil-outer-text-objects-map)

('normal "bl" 'consult-goto-line
	 "b/" 'consult-keep-lines)
#+end_src
    
**** Extensions
Easymotion's prefix is M-SPC, however, most important keys are already bound somewhere easier.
Cursors hydra: https://hungyi.net/posts/hydra-for-evil-mc/
#+NAME: Emacs Evil Extensions
#+begin_src nix-ts :noweb yes
evil-collection.custom.evil-collection-unimpaired-want-repeat-mode-integration = true;

evil-surround.generalTwoConfig = {
  ":v".evil-surround-mode-map."R" = "'evil-surround-region";
  ":o".evil-surround-mode-map = {
    "s" = "nil";
    "r" = "'evil-surround-edit";
    "R" = "'evil-Surround-edit";
  };
};

evil-easymotion = {
  generalOne.":nvo" = {
    "H-m" = "'evilem-motion-search-next";
    "H-U" = "'evilem-motion-forward-word-begin";
    "H-u" = "'evilem-motion-forward-WORD-begin";
    "H-X" = "'evilem-motion-backward-word-begin";
    "H-x" = "'evilem-motion-backward-WORD-begin";
    "H-M" = "'evilem-motion-search-previous";
  };
  custom = {
    avy-keys = "'(?c ?r ?s ?t ?b ?f ?n ?e ?i ?a)";
    avy-dispatch-alist = ''
      '((?l . avy-action-ispell)
			  (?o . nix-emacs-avy-action-embark)
			  (?h . avy-action-helpful)
			  (?g . avy-action-yank)
			  (?p . avy-action-teleport)
			  (?q . nix-emacs-avy-action-fold))
    '';
    avy-all-windows = false;
  };
  config = "(defun avy-action-helpful (pt) (nix-emacs-base-avy-action 'helpful-at-point pt))";
};

evil-mc = {
  enable = true;
  defer = true;
  command = ["evil-mc-pause-cursors" "evil-mc-make-cursor-here"];
  generalOne = {
    ":nv"."bz" = "'evil-mc-hydra/body";
    global-leader."C" = "'evil-mc-hydra/body";
  };
  config = ''
    <<Emacs Evil-MC Config>>
  '';
  extraConfig = ''
    :pretty-hydra
    ((:color pink :pre (evil-mc-pause-cursors))
     ("Search"
      (("m" #'evil-mc-make-and-goto-next-match "Search forward")
       ("M" #'evil-mc-make-and-goto-prev-match "Search backward")
       ("C-m" #'evil-mc-skip-and-goto-next-match "Skip forward")
       ("C-M" #'evil-mc-skip-and-goto-prev-match "Skip backward"))
      "Undo"
      (("q" #'evil-mc-undo-all-cursors)
       ("j" #'evil-mc-undo-last-added-cursor))
      "Pause/Resume"
      (("r" #'evil-mc-resume-cursors "Resume")
       ("p" #'evil-mc-pause-cursors "Pause")
       ("<return>" #'evil-mc-resume-cursors "Quit" :color blue))
      "Create Cursors"
      (("h" #'evil-mc-make-all-cursors "All")
       ("s" #'evil-mc-make-cursor-here "Here")
       ("E" #'evil-mc-make-cursor-move-next-line "Next Line")
       ("O" #'evil-mc-make-cursor-move-prev-line "Prev Line"))))
  '';
};
#+end_src

#+NAME: Emacs Evil-MC Config
#+begin_src emacs-lisp
(global-evil-mc-mode)

(general-add-hook 'doom-escape-hook (lambda () (when (evil-mc-has-cursors-p)
  						 (evil-mc-undo-all-cursors)
  						 (evil-mc-resume-cursors) t)))

;; Don't mess with my macros.
;; https://github.com/gabesoft/evil-mc/issues/83
(defun ~+multiple-cursors-evil-mc-write-cursor-state-a (state)
  "Write the state of the real cursor with values from STATE."
  (let ((names (evil-mc-get-cursor-variables)))
    (dolist (name names)
      (when (boundp name)
        (let ((p (evil-mc-get-cursor-property state name)))
          (when (not
                 (or
                  (eq name 'register-alist)
                  (eq name 'evil-markers-alist)))
            (set name p)))))))
(advice-add #'evil-mc-write-cursor-state :override #'~+multiple-cursors-evil-mc-write-cursor-state-a)
#+end_src

**** Symex
Gives us an entire state where we can rapidly make specific edits to code.
#+NAME: Emacs Evil Symex
#+begin_src nix-ts :noweb yes
  symex = {
    enable = true;
    defer = true;
    generalTwo.":n"."(racket-repl-mode-map lisp-interaction-mode-map lisp-mode-map)"."RET" = "'symex-mode-interface";
    init = ''
      <<Emacs Symex Init>>    
    '';
    config = ''
      <<Emacs Symex Config>>    
    '';
    generalOneConfig.evil-symex-state-map = {
      "n" = "'symex-go-backward";
      "e" = "'symex-go-down";
      "o" = "'symex-go-up";
      "i" = "'symex-go-forward";
      "bn" = "'evil-backward-char";
      "bi" = "'evil-forward-char";
      "C-e" = "'symex-climb-branch";
      "C-o" = "'symex-descend-branch";
      "d" = "'symex-yank";
      "D" = "'symex-yank-remaining";
      "G" = "'symex-paste-after";
      "g" = "'symex-paste-before";
      "k" = "'symex-delete";
      "C-k" = "'symex-delete-backward";
      "p" = "'symex-delete-remaining";
      "K" = "'symex-change";
      "P" = "'symex-change-remaining";
      "N" = "'symex-shift-backward";
      "I" = "'symex-shift-forward";
      "M-N" = "'symex-shift-backward-most";
      "M-I" = "'symex-shift-forward-most";
      "M-n" = "'symex-goto-first";
      "M-i" = "'symex-goto-last";
      "t" = "'symex-insert-at-beginning";
      "T" = "'symex-append-at-end";
      "S" = "'symex-open-line-after";
      "R" = "'symex-open-line-before";
      "j" = "'evil-undo";
      "J" = "'evil-redo";
      "s" = "'symex-append-after";
      "r" = "'symex-insert-before";
      "w" = "'evil-repeat";
      "C-w" = "'evil-repeat-pop";
      "W" = "'evil-ex-repeat";
      "a" = "'evil-ex";
      "~" = "'evil-record-macro";
      "$" = "'evil-execute-macro";
    };
  };
#+end_src

#+NAME: Emacs Symex Init
#+begin_src emacs-lisp
  (with-eval-after-load 'evil-easymotion
    (evilem-make-motion-plain evilem-symex-forward 'symex-traverse-forward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-backward 'symex-traverse-backward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-next-visual-line 'symex-next-visual-line :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-previous-visual-line 'symex-previous-visual-line :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-go-forward 'symex-go-forward :post-hook 'symex-select-nearest-in-line)
    (evilem-make-motion-plain evilem-symex-go-backward 'symex-go-backward :post-hook 'symex-select-nearest-in-line))
#+end_src

#+NAME: Emacs Symex Config
#+begin_src emacs-lisp
(symex-mode)
(repeaters-define-maps
 '(("symex-visual-line"
    symex-next-visual-line "e"
    symex-previous-visual-line "o")))
#+end_src

**** Compats
#+NAME: Emacs Evil Compats
#+begin_src nix-ts :noweb yes
evil-org.config = ''
  <<Emacs Evil Org Config>>
'';

evil-org-agenda = {
  generalTwo.":m".evil-org-agenda-mode-map = {
    "bn" = "'org-agenda-next-item";
    "bI" = "'evil-window-bottom";
    "I" = "'org-agenda-do-date-later";
    "C-S-i" = "'org-agenda-todo-nextset"; # Original binding "C-S-<right>"
    "l" = "'org-agenda-diary-entry";
  };
};

ewal-evil-cursors = {
  enable = true;
  demand = true;
  config = ''(ewal-evil-cursors-get-colors :apply t)'';
};
#+end_src

#+NAME: Emacs Evil Org Config
#+begin_src emacs-lisp
(evil-define-key 'operator 'evil-org-mode
  "i" 'evil-forward-char)
(evil-define-key 'normal 'evil-org-mode
  "o" 'evil-previous-visual-line
  "O" 'evil-scroll-up
  "R" 'evil-org-open-above
  "S" 'evil-org-open-below
  "x" 'evil-backward-WORD-begin
  "X" 'evil-backward-word-begin
  "d" 'evil-yank)
(evil-define-key 'visual 'evil-org-mode
  "i" 'evil-forward-char
  "s" evil-inner-text-objects-map)
#+end_src

*** Completion System
My completions system is based around vertico, because that's what all the cool kids use nowadays.
#+begin_src nix-ts :noweb yes :tangle emacs/completion-system.nix
{ inputs, pkgs, ... }:

{
  <<Emacs Templates File>>

  programs.emacs.init = {
    completions = {
      prescient = true;
      orderless = true;
      vertico = {
        enable = true;
        evilConsultLine = true;
        embark = true;
      };
      corfu = {
        enable = true;
        wantTabComplete = false;
        wantRetConfirm = false;
        wantMinibuffer = true;
        popupInfo = true;
      };
    };

    usePackage = {
      <<Emacs Vertico>>
      
      <<Emacs Corfu>>

      <<Emacs Consult>>

      <<Emacs Embark>>

      <<Emacs App Launcher>>

      <<Emacs Search>>

      <<Emacs Snippets>>

      <<Emacs Ezf>>
    };
  };
}
#+end_src

**** Vertico
Vertico is basically dmenu for emacs. It lists out all the options in a command menu.
#+NAME: Emacs Vertico
#+begin_src nix-ts :noweb yes
vertico.generalTwo.":n".vertico-map = {
  "C-o" = "'vertico-scroll-down";
  "C-e" = "'vertico-scroll-up";
  "j" = "'evil-undo";
  "I" = "'vertico-last";
  "N" = "'vertico-first";
  "B" = "'vertico-last";
  "bg" = "'vertico-first";
};

vertico-quick.custom = {
  vertico-quick1 = ''"crst"'';
  vertico-quick2 = ''"neia"'';
};
#+end_src

**** Corfu
I took a lot of this from Gavin Freeborn's config
#+NAME: Emacs Corfu
#+begin_src nix-ts :noweb yes
nerd-icons-corfu = {
  enable = true;
  config = ''(add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter)'';
  after = ["corfu"];
};

corfu-quick = {
  enable = true;
  generalTwo.":ie".corfu-map = {
    "M-o" = "'corfu-quick-insert";
    "M-e" = "'corfu-quick-insert";
  };
  custom = {
    corfu-quick1 = ''"crst"'';
    corfu-quick2 = ''"neia"'';
  };
};

cape = {
  enable = true;
  after = ["corfu"];
  config = ''
      <<Emacs Cape Config>>
    '';
};
#+end_src

#+NAME: Emacs Cape Config
#+begin_src emacs-lisp
(dolist (src (list 'cape-dabbrev 'cape-file))
  (add-to-list 'completion-at-point-functions src))
#+end_src

**** Consult
Replaces a bunch of commands with new commands.
Evil integration is from noctuid & minad
#+NAME: Emacs Consult
#+begin_src nix-ts :noweb yes
consult = {
  ghookf = ["('minibuffer-setup 'consult-initial-narrow)"];
  command = ["consult-goto-line" "consult-keep-lines"];
  custom.consult-buffer-sources = "'(consult--source-buffer)";
  generalOne = {
    ":n" = {
      "M-g" = "'consult-yank-pop"; # orig. evil-paste-pop
      "M-E" = "'consult-isearch-history "; # orig. isearch-edit-string
      "H-'" = "'evil-collection-consult-mark";
      "H--" = "'evil-collection-consult-jump-list";
      "H-q" = "'consult-flymake"; # Alternative: consult-flycheck
    };
    ctl-x-map."C-f" = "'consult-fd";
  };
  bindLocal.help-map."M" = "man";
  config = ''
      <<Emacs Consult Config>>
    '';
} ;
#+end_src

#+NAME: Emacs Consult Config
#+begin_src emacs-lisp
(defvar consult--bufler-workspace+
  `(:name "Workspace"
          :narrow ?w
          :category buffer
          :face consult-buffer
          :history  buffer-name-history
          :state    ,#'consult--buffer-state
          :enabled  ,(lambda () (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find)))
          :items
          ,(lambda ()
             (let ((bufler-vc-state nil))
               (mapcar #'buffer-name
                       (mapcar #'cdr
                               (bufler-buffer-alist-at
                                (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find))
                                :filter-fns bufler-filter-buffer-fns))))))
  "Bufler workspace buffers source for `consult-buffer'.")

(push #'consult--bufler-workspace+ consult-buffer-sources)

;; Stolen from the wiki
(defun consult-initial-narrow ()
  (when (and (eq this-command #'consult-buffer)
             (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find)))
    (setq unread-command-events (append unread-command-events (list ?w 32)))))
#+end_src

**** Embark
Embark lets you manipulate the content of vertico buffers.

Credits:
Which-key indicator from the embark wiki
avy actions from karthink
#+NAME: Emacs Embark
#+begin_src nix-ts :noweb yes
embark = {
  general."M-a" = "'embark-dwim";
  generalTwo.":n".vertico-map."a" = "'embark-act";
  generalOne = {
    embark-file-map = {
      "2" = "(my/embark-split-action find-file elwm-split-window)";
      "t" = "(my/embark-split-action find-file tab-new)";
      "o" = "(my/embark-ace-action find-file)";
    };
    embark-buffer-map = {
      "2" = "(my/embark-split-action switch-to-buffer elwm-split-window)";
      "t" = "(my/embark-split-action switch-to-buffer tab-new)";
      "o" = "(my/embark-ace-action switch-to-buffer)";
    };
    embark-bookmark-map = {
      "2" = "(my/embark-split-action bookmark-jump elwm-split-window)";
      "t" = "(my/embark-split-action bookmark-jump tab-new)";
      "o" = "(my/embark-ace-action bookmark-jump)";
    };
  };
  preface = ''
    <<Emacs Embark Preface>>
  '';
};
#+end_src

Borrowed from Karthinks
#+NAME: Emacs Embark Preface
#+begin_src emacs-lisp
(eval-when-compile
  (defmacro my/embark-split-action (fn split-type)
    `(defun ,(intern (concat "my/embark-"
                             (symbol-name fn)
                             "-"
                             (car (last  (split-string
                                          (symbol-name split-type) "-"))))) ()
       (interactive)
       (funcall #',split-type)
       (call-interactively #',fn))))

(eval-when-compile
  (defmacro my/embark-ace-action (fn)
    `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
       (interactive)
       (with-demoted-errors "%s"
	 (require 'ace-window)
	 (let ((aw-dispatch-always t))
           (aw-switch-to-window (aw-select nil))
           (call-interactively (symbol-function ',fn)))))))
#+end_src

**** App Launcher
#+NAME: Emacs App Launcher
#+begin_src nix-ts
app-launcher = {
  enable = true;
  defer = true;
  command = ["app-launcher-run-app"];
};
#+end_src

**** Search
#+NAME: Emacs Search
#+begin_src nix-ts
ace-isearch = {
  enable = true;
  demand = true;
  gfhookf = ["('pdf-view-mode (lambda () (ace-isearch-mode -1)))"];
  generalOne.isearch-mode-map."C-a" = "'avy-isearch";
  config = "(global-ace-isearch-mode)";
  custom = {
    ace-isearch-on-evil-mode = true;
    ace-isearch-input-length = 5;
    ace-isearch-jump-based-on-one-char = false;
  };
};
#+end_src

**** Snippets
#+NAME: Emacs Snippets
#+begin_src nix-ts :noweb yes
tempel = {
  enable = true;
  command = ["tempel-complete"];
  custom.tempel-path = ''"~/.config/emacs/templates.eld"'';
  init = ''
      <<Emacs Templ Init>>
    '';
};

tempel-collection = {
  enable = true;
  after = ["tempel"];
};
#+end_src

#+NAME: Emacs Templ Init
#+begin_src emacs-lisp
(defun tempel-setup-capf ()
  " Add the Tempel Capf to `completion-at-point-functions'.
    `tempel-expand' only triggers on exact matches. Alternatively use
    `tempel-complete' if you want to see all matches, but then you
    should also configure `tempel-trigger-prefix', such that Tempel
    does not trigger too often when you don't expect it. NOTE: We add
    `tempel-expand' *before* the main programming mode Capf, such
    that it will be tried first."
  (setq-local completion-at-point-functions
              (cons #'tempel-expand
                    completion-at-point-functions)))
#+end_src

#+NAME: Emacs Templates File
#+begin_src nix-ts
home.file.".config/emacs/templates.eld".text = ''
  nix-mode
  (upackage p "= {" n "  enable = true;" q "  }")

  js-ts-mode
  (clg "console.log(" p ");")
  (doc "/**" n> " * " q n " */")
  (anfn "(" p ") => {" n> q n "};")
  (qs "document.querySelector(\"" q "\");")
  (if "if (" p ") {" n> q n "}")

  c-ts-mode
  (doc "/**" n> " * " q n " */")
  (if "if (" p ") {" n> q n "}")
  (for "for (int i = " p "; i < " p "; i++) {" n> q n "}")
  (while "while (" p ") {" n> q n "}")
  (stdio "#include <stdio.h>")
  (stdlib "#include <stdlib.h>")
  (string "#include <string.h>")
  (unistd "#include <unistd.h>")
  (mpi "#include <mpi.h>")
  (math "#include <math.h>")
  (define "#define " p)
  (function p " " p " (" p ") {" n> q n "}" ) 
  (main "int main (int argc, char **argv) {" n> q n "}" ) 

  org-mode
  (au "#+author: " q)
  (ti "#+title: " q)
  (ci "* Works Cited" n "#+cite_export: csl ~/.config/csl/ieee.csl" n "#+print_bibliography:" q)
  (pdf "#+auto-export-pandoc: to-latex-pdf")
  (odt "#+auto-export-pandoc: to-odt")

  java-ts-mode
  (doc "/**" n> " * " q n " */")
  (if "if (" p ") {" n> q n "}")
  (class "public class " (p (file-name-base (or (buffer-file-name) (buffer-name)))) " {" n> r> n "}")
  (method p " " p " " p "(" p ") {" n> q n "}")
  (while "while (" p ") {" n> q n "}")
  (for "for (int i = " p "; i < " p "; i++) {" n> q n "}")

  bash-ts-mode
  (bang "#!/bin/sh" n q)
  (safebang "#!/bin/sh" n "set -euo pipefail" n q)

  ledger-mode
  (payroll p "Rose-Hulman Payroll" n> "Income:TeachingAssistant" > "-" p n> "*Assets:Checking")
  (checking "Assets:Checking")

  racket-mode
  (let "(let [(" p ")]" n q ")")
  (letrec "(letrec [(" p ")]" n q ")")
  (letstar "(let* [(" p ")]" n q ")")
  (namelet "(let " p " [(" p ")]" n q ")")
  (defun "(define " p " (lambda (" p ")" n q "))")

  emacs-lisp-mode
  (wcd "(with-current-buffer " "q)")
  (gbc "(get-buffer-create " "q)")

  eshell-mode
  (gbc "(get-buffer-create \"" q "\")")
'';
#+end_src

**** Ezf
An alternative to fzf.
#+NAME: Emacs Ezf
#+begin_src nix-ts
ezf = {
  enable = true;
  deferIncrementally = true;
};
#+end_src

*** Help System
An improved help system that I lifted from emacs from scratch.
Helpful gives more information, & which-key tells what keybinds you have available
#+begin_src nix-ts :tangle emacs/help-system.nix
{ ... }:

{
  programs.emacs.init.usePackage = {
    helpful = {
      enable = true;
      defer = true;
      generalOne = {
        global-leader = {
          "hf" = "'helpful-function";
          "hs" = "'helpful-symbol";
          "hv" = "'helpful-variable";
          "hx" = "'helpful-command";
          "hk" = "'helpful-key";
          "hm" = "'helpful-macro";
        };
        embark-become-help-map = {
          "f" = "'helpful-function";
          "s" = "'helpful-symbol";
          "v" = "'helpful-variable";
        };
        embark-symbol-map."h" = "'helpful-symbol";
      };
    };
  };
}
#+end_src

*** Password Management
#+begin_src nix-ts :noweb yes :tangle emacs/passwords.nix
{ pkgs, ... }:

{
  home.packages = with pkgs; [ pass ];

  programs.emacs.init.usePackage = {
    <<Emacs Pass>>
    
    <<Emacs Pinentry>>
  };
}
#+end_src

**** Pass
This is an emacs wrapper for pass.
Password-store-otp has more functions, if they are of intrest.
Everything is bound to SPC p
#+NAME: Emacs Pass
#+begin_src nix-ts
password-store = {
  enable = true;
  defer = true;
  generalOne.global-leader = {
    "p" = '''(:ignore t :which-key "pass")'';
    "py" = '''(password-store-copy :which-key "yank")'';
    "pi" = '''(password-store-insert :which-key "insert")'';
    "pg" = '''(password-store-generate :which-key "generate")'';
  };
  extraConfig = ":autoload pass-entries password-store-list";
};

password-store-otp = {
  enable = true;
  defer = true;
  generalOne.global-leader."po" = '''(password-store-otp-token-copy :which-key "copy otp")'';
};
#+end_src

**** Pinentry
This is a pinentry program (alternative to pinentry-dmenu)
When you're prompted for your gpg password, the place for entry will be your modeline.
#+NAME: Emacs Pinentry
#+begin_src nix-ts :noweb yes
pinentry = {
  enable = true;
  custom.epa-pinentry-mode = "'loopback";
  deferIncrementally = true;
  config = ''
    <<Emacs Pinentry Config>>
  '';
};
#+end_src

#+NAME: Emacs Pinentry Config
#+begin_src emacs-lisp
(pinentry-start)
(shell-command "gpgconf --launch-agent")
(shell-command "gpg-connect agent updatestartuptty /bye >/dev/null")
#+end_src

*** Writing
#+begin_src nix-ts :noweb yes :tangle emacs/writing.nix
{ config, inputs, pkgs, ... }:

{
  home.packages = with pkgs; [
    libreoffice-fresh
    hunspell
    hunspellDicts.en-us-large
    texlive.combined.scheme-full
  ];

  programs.emacs.init = {
    ide.languages = {
      markdown.enable = true;
      latex = {
        enable = true;
        magicLatexBuffer = true;
        cdlatex = true;
      };
      org = {
        enable = true;
        aesthetics = {
          enable = true;
          headerFont = config.stylix.fonts.sansSerif.name;
        };
        captureTemplates.enable = true;
      };
    };

    usePackage = {
      <<Emacs Org Main>>

      <<Emacs Org Extensions>>
      
      <<Emacs Org Denote>>
      
      <<Emacs Org Novelist>>
      
      <<Emacs Latex>>
      
      <<Emacs Markdown>>
      
      <<Emacs Writeroom>>

      <<Emacs Spellcheck>>
      
      <<Emacs Citations>>

      <<Emacs Epub Reader>>
    };
  };
}
#+end_src

**** Org
***** Main Config
The org agenda syntax:
DEADLINE:<year-month-date>
How to add a latex package
: #+LATEX_HEADER: \usepackage{times}

#+NAME: Emacs Org Main
#+begin_src nix-ts
org = {
  gfhookf = [''('org-mode (list 'ispell-minor-mode
    (local! completion-at-point-functions (list (cape-capf-super
                                                 #'tempel-complete
						 #'cape-file)
                                                #'pcomplete-completions-at-point
						#'cape-dict
                                                #'cape-dabbrev))))''
  ];
  custom = {
    org-export-with-toc = false;
    org-export-with-section-numbers = false;
    org-directory = ''"~/doc"'';
    org-emphasis-alist = '''(("*" bold)
      ("/" italic)
                                 ("=" org-verbatim verbatim)
                                 ("~" org-code verbatim)
                                 ("+" (:strike-through t))
                                 ("!" (:overline t) verbatim))'';
  };
  generalTwo.local-leader.org-mode-map."a" = '''(avy-org-goto-heading-timer :which-key "avy")'';

  config = ''
    (require 'ol-man)
  '';
};
#+end_src

***** Extensions
#+NAME: Emacs Org Extensions
#+begin_src nix-ts :noweb yes
org-auto-tangle = {
  enable = true;
  ghookf = ["('org-mode 'org-auto-tangle-mode)"];
};

org-auto-export-pandoc = {
  enable = true;
  extraPackages = with pkgs; [pandoc];
  ghookf = ["('after-save (lambda () (when (equal major-mode 'org-mode) (org-auto-export-pandoc))))"];
};
#+end_src

***** Denote
#+NAME: Emacs Org Denote
#+begin_src nix-ts :noweb yes
denote = {
  enable = true;
  defer = true;
  gfhookf = ["('dired-mode 'denote-dired-mode-in-directories)"];
  custom = {
    denote-directory = ''(expand-file-name "~/doc/denote")'';
    denote-known-keywords = '''("quotes" "chem" "emacs" "java" "physics" "calculus" "minecraft" "de" "proofs" "csse230" "os" "databases" "scifi" "softwarerequirements" "anthropology" "theoryofcomputation" "parallelcomp" "cybersecurity" "probstats" "scheme" "dreams" "softwaredevelopment" "ethics" "plp" "malwareanalysis" "bio" "ai" "resolve")'';
    denote-file-type = false;
    denote-dired-directories = "(list denote-directory)";
    
  };
  generalOne.global-leader = {
    "of" = "'denote-open-or-create";
    "or" = '''(denote-rename-file :whick-key "denote rename")'';
    "oi" = '''(denote-link :which-key "link to note")'';
  };
  config = "(consult-denote-mode)";
};

consult-denote = {
  enable = true;
  command = ["consult-denote-mode"];
  generalOne.global-leader."os" = "'consult-denote-grep";
  custom.consult-denote-grep-command = "'consult-ripgrep";
};
#+end_src

***** Novelist
#+NAME: Emacs Org Novelist
#+begin_src nix-ts
org-novelist = {
  enable = true;
  command = ["org-novelist-mode" "org-novelist-new-story"];
  generalTwo.local-leader.org-novelist-mode-map = {
    "c" = '''(:ignore t :which-key "character")'';
    "cn" = '''(org-novelist-new-character :which-key "new")'';
    "cr" = '''(org-novelist-rename-character :which-key "rename")'';
    "cd" = '''(org-novelist-destroy-character :which-key "destroy")'';
    "h" = '''(:ignore t :which-key "chapter")'';
    "hn" = '''(org-novelist-new-chapter :which-key "new")'';
    "hr" = '''(org-novelist-rename-chapter :which-key "rename")'';
    "hd" = '''(org-novelist-destroy-chapter :which-key "destroy")'';
    "p" = '''(:ignore t :which-key "place")'';
    "pn" = '''(org-novelist-new-place :which-key "new")'';
    "pr" = '''(org-novelist-rename-place :which-key "rename")'';
    "pd" = '''(org-novelist-destroy-place :which-key "destroy")'';
    "r" = '''(:ignore t :which-key "prop")'';
    "rn" = '''(org-novelist-new-prop :which-key "new")'';
    "rr" = '''(org-novelist-rename-prop :which-key "rename")'';
    "rd" = '''(org-novelist-destroy-prop :which-key "destroy")'';
    "e" = '''(org-novelist-export-story :which-key "export")'';
  };
};
#+end_src

**** Latex
Auctex turns emacs into a LaTeX IDE.

This configuration was taken from the emacs wiki. [[https://www.emacswiki.org/emacs/RefTeX][Reftex]] 
[[https://libredd.it/r/emacs/comments/4zvln1/editing_tex_documents/
][Also this reddit post]]
Reftex seems to do references
Magic latex buffer makes your source file look more like the pdf.
No idea what the rest of this is for.

| Key | CDLatex effect                    |
| `n  | greek letter \nu                    |
| TAB | magic. Ususally involves jumping. |
| equ | becomes an equation after tab     |
| beg | becomes an environment after tab  |

#+NAME: Emacs Latex
#+begin_src nix-ts
pdf-tools = {
  enable = true;
  defer = true;
  generalOne.pdf-view-mode-map."C-s" = "'search-forward";
  custom = {
    # Makes PDFtools the default
    TeX-view-program-selection = '''((output-pdf "PDF Tools"))'';
    TeX-view-program-list = '''(("PDF Tools" TeX-pdf-tools-sync-view))'';
    TeX-source-correlate-start-server = false;
  };
  config = ''
    (pdf-tools-install)
  '';
  gfhook = ["('TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)"];
  gfhookf = ["('pdf-view-mode-hook 'pdf-view-midnight-minor-mode)"];
  init = ''(setq-default pdf-view-display-size 'fit-width)'';
  extraConfig = '':magic ("%PDF" . pdf-view-mode)'';
};

evil-collection-pdf = {
  defer = true;
  enable = true;
  generalTwoConfig.":n".pdf-view-mode-map = {
    "C-e" = "'pdf-view-scroll-up-or-next-page";
    "E" = "'pdf-view-scroll-up-or-next-page";
    "C-o" = "'pdf-view-scroll-down-or-previous-page";
    "O" = "'pdf-view-scroll-down-or-previous-page";
  };
};

cdlatex.generalTwo.":i" = {
  cdlatex-mode-map."TAB" = "'cdlatex-tab";
  org-cdlatex-mode-map."TAB" = "'cdlatex-tab";
};

tex.generalTwo.local-leader.LaTeX-mode-map."e" = "'TeX-command-run-all";
#+end_src

**** Markdown
#+NAME: Emacs Markdown
#+begin_src nix-ts :noweb yes
markdown = {
  generalOne.markdown-mode-map."C-c C-e" = "'markdown-do";
  gfhookf = ["('markdown-mode 'efs/markdown-font-setup)"];
  custom = {
    markdown-command = ''"multimarkdown"'';
    markdown-hide-markup = true;
  };
  generalTwo = {
    ":n".markdown-mode-map = {
      "[h" = "'markdown-previous-visible-heading";
      "]h" = "'markdown-next-visible-heading";
    };  
  };
  preface = ''
    <<Emacs Markdown Init>>
  '';
};
#+end_src

#+NAME: Emacs Markdown Init
#+begin_src emacs-lisp
(defun efs/markdown-font-setup ()
  (variable-pitch-mode)
  (dolist (face '((markdown-header-face-1 . 1.4)
                  (markdown-header-face-2 . 1.2)
                  (markdown-header-face-3 . 1.1)
                  (markdown-header-face-4 . 1.05)
                  (markdown-header-face-5 . 1.05)
                  (markdown-header-face-6 . 1.05)))
    (set-face-attribute (car face) nil :font "SF Pro" :weight 'regular :height (cdr face))))
#+end_src

**** Writeroom
I couldn't get olivetti to work.
#+NAME: Emacs Writeroom
#+begin_src nix-ts
writeroom-mode = {
  enable = true;
  ghookf = ["((gen-mode-hooks '(Man org-agenda org Info markdown)) 'writeroom-mode)"];
  gfhookf = ["('writeroom-mode 'visual-line-mode)"];
  custom = {
    writeroom-mode-line = true;
    writeroom-maximize-window = false;
    writeroom-global-effects = false;
  };
  generalOne.global-leader."w" = '''(writeroom-mode :which-key "writeroom")'';
};
#+end_src

**** Spellcheck
#+NAME: Emacs Spellcheck
#+begin_src nix-ts
flyspell = {
  enable = true;
  custom.ispell-personal-dictionary = "~/.config/emacs/ispell.txt";
  ghookf = [
    "('text-mode-hook 'flyspell-mode)"
    "('prog-mode-hook 'flyspell-prog-mode)"
  ];
};
#+end_src

**** Citations
#+NAME: Emacs Citations
#+begin_src nix-ts :noweb yes
citar = {
  enable = true;
  config = ''(citar-denote-mode)'';
  ghookf = ["('(LaTeX-mode org-mode) 'citar-capf-setup)"];
  custom = {
    org-cite-insert-processor = "'citar";
    org-cite-follow-processor = "'citar";
    org-cite-activate-processor = "'citar";
    citar-bibliography = '''("~/doc/uni.bib")'';
    org-cite-global-bibliography = '''("~/doc/uni.bib")'';
  };
};

citar-embark = {
  enable = true;
  after = ["citar" "embark"];
  config = ''(citar-embark-mode)'';
  custom.citar-at-point-function = "'embark-act";
};

citar-denote = {
  enable = true;
  command = ["citar-denote-mode"];
  generalOne.global-leader = {
    "on" = '''(citar-create-note :which-key "new citar note")'';
    "oo" = '''(citar-denote-open-note :which-key "open citar note")'';
    "ol" = "'citar-denote-link-reference";
    "ow" = "'citar-denote-find-citation";
  };
  config = ''
    <<Emacs Writing Citar Denote Config>>
  '';
  afterCall = ["citar"];
};
#+end_src

#+NAME: Emacs Writing Citar Denote Config
#+begin_src emacs-lisp
(defun citar-denote--create-note (citekey &optional _entry)
  "Create a bibliographic note for CITEKEY with properties ENTRY.

The note file type is determined by `citar-denote-file-type'.

The title format is set by `citar-denote-title-format'.

When `citar-denote-subdir' is non-nil, prompt for a subdirectory.

When `citar-denote-template' is a symbol, use the specified
template, if otherwise non-nil, prompt for a Denote template.

When `citar-denote-signature' is non-nil, prompt for a signature or
use citation key."
  (denote
   (read-string "Title: " (citar-denote--generate-title citekey))
   (citar-denote--keywords-prompt citekey)
   citar-denote-file-type
   (when citar-denote-subdir
     (if (stringp citar-denote-subdir)
         (expand-file-name
          (concat denote-directory citar-denote-subdir))
       (denote-subdirectory-prompt)))
   nil
   (when citar-denote-template
     (or (alist-get citar-denote-template denote-templates)
         (denote-template-prompt)))
   (cond ((eq citar-denote-signature 'ask)
          (denote-signature-prompt nil "Signature: "))
         ((eq citar-denote-signature 'citekey)
          citekey)
         (nil nil)))
  (citar-denote--add-reference citekey)
  ;; Open available atachment in other window
  (when (one-window-p)
    (split-window-right))
  (other-window 1)
  (citar-open-files citekey))
#+end_src

**** Epub Reader
Nov allows you to read an epub file in a very similar way to an org file.
You can't get page numbers, though, which becomes unfortunate for doing citations.
#+NAME: Emacs Epub Reader
#+begin_src nix-ts
nov = {
  enable = true;
  defer = true;
  extraPackages = with pkgs; [unzip];
  mode = [''("\\.epub\\'" . nov-mode)''];
};
#+end_src

** Window Management
Almost everything here was copied from David Wilson. Thank you, David, for practically writing my config for me.

#+begin_src nix-ts :noweb yes :tangle emacs/window-manager.nix
{ inputs, pkgs, config, ... }:

{
  programs = {
    <<i3status>>

    emacs.init.usePackage = {
      <<Emacs Window Management Tab Bar>>
      
      <<Emacs Window Management Bufler>>

      <<Emacs Window Management ELWM>>

      <<Emacs Window Management Golden Ratio>>
      
      <<Emacs Window Management EXWM>>
      
      <<Emacs Window Management Popper & Proced>>
      
      <<Emacs Ace Window>>
    };
  };
}
#+end_src

*** Tab Bar
I borrowed pretty heavily from here: https://github.com/jamescherti/vim-tab-bar.el
#+NAME: Emacs Window Management Tab Bar
#+begin_src nix-ts
tab-bar = {
  enable = true;
  config = ''
    (general-add-advice 'tab-new :after #'dashboard-open)
    (defun efs/tab-bar-select ()
       (interactive)
       (setq tab-bar-tab-hints t)
       (tab-bar-select-tab (string-to-number (read-string "Tab Number: ")))
       (setq tab-bar-tab-hints nil))
  '';
  ghookf = ["('exwm-init 'tab-bar-mode)"];
  general."s-u" = "'tab-bar-hydra/body";
  custom = {
    tab-bar-format = "'(tab-bar-format-tabs-groups tab-bar-separator doom-nano-tabline tab-bar-format-align-right tab-bar-format-global)";
    tab-bar-close-button-show = false;
    tab-bar-select-restore-windows = false;
    tab-bar-auto-width-max = "'((150) 20)";
  };
  extraConfig = ''
    :pretty-hydra
    ((:color amaranth)
     ("Navigation"
      (("e" #'evil-tab-next "next")
       ("o" #'tab-bar-switch-to-prev-tab "prev")
       ("v" #'tab-recent "recent")
       ("b" #'tab-bar-lost-commands-switch-to-first-tab "first")
       ("B" #'tab-bar-lost-commands-switch-to-last-tab "last")
       ("/" #'efs/tab-bar-select "search"))
      "Creation/Deletion"
      (("s" #'tab-new "new")
       ("k" #'tab-close "close")
       ("r" #'tab-rename "rename")
       ("u" #'tab-undo "undo"))
      "Groups"
      (("g" #'tab-group "add to group")
       ("K" #'tab-close-group "close group"))
      "Organization"
      (("E" #'tab-bar-lost-commands-move-tab-forward "forward")
       ("O" #'tab-bar-lost-commands-move-tab-backward "backward"))
      "Exit"
      (("<return>" nil "" :color blue)
       ("<escape>" nil "" :color blue))))
  '';
};

tab-bar-lost-commands = {
  enable = true;
  command = [
    "tab-bar-lost-commands-move-tab-forward"
    "tab-bar-lost-commands-move-tab-backward" 
    "tab-bar-lost-commands-switch-to-first-tab" 
    "tab-bar-lost-commands-switch-to-last-tab" 
  ];
};
#+end_src

*** Bufler
Bufler is the other half of tab bar. It lets us automatically narrow buffers down to a given workspace
#+NAME: Emacs Window Management Bufler
#+begin_src nix-ts :noweb yes
bufler = {
  enable = true;
  ghookf = ["('tab-bar-mode 'bufler-mode)"];
  general = {
    "s-b" = "'bufler-hydra/body";
    "s-f" = "'bufler-workspace-focus-buffer";
    "s-F" = "'bufler-workspace-set";
  };
  generalTwo."'normal".evil-collection-unimpaired-mode-map = {
    "]b" = "'bufler-cycle-buffers-forward";
    "[b" = "'bufler-cycle-buffers-backward";
  };
  custom.bufler-groups = ''
    <<Emacs Bufler Defgroups>>
  '' ;
  init = ''
    <<Emacs Bufler Init>>
  '';
  config = ''
    <<Emacs Bufler Config>>
  '';
  extraConfig = ''
    :pretty-hydra
    ((:color amaranth)
      ("Move"
       (("o" bufler-cycle-buffers-backward "prev")
        ("e" bufler-cycle-buffers-forward "next"))
       "Tricks"
       (("/" consult-buffer "search" :color blue :exit t)
        ("i" ibuffer "list (ibuffer)" :color blue :exit t)
        ("k" kill-current-buffer "delete"))
       "Quit"
       (("<escape>" nil "quit" :color blue :exit t)
        ("<return>" nil "quit" :color blue :exit t))))
  '';
};

bufler-workspace-tabs = {
  enable = true;
  ghookf = ["('bufler-mode 'bufler-workspace-workspaces-as-tabs-mode)"];
  gfhookf = ["('bufler-workspace-workspaces-as-tabs-mode '(global-tab-line-mode burly-tabs-mode))"];
};
#+end_src

#+NAME: Emacs Bufler Defgroups
#+begin_src emacs-lisp
(bufler-defgroups
  ;; Subgroup collecting all named workspaces.
  (group (auto-workspace))
  ;; Subgroup collecting buffers in a project.
  (group (auto-project))
  ;; Subgroup collecting tramp buffers
  (group (auto-tramp))
  ;; Grouping browser windows
  (group
   (group-or "Browsers"
             (name-match "Qutebrowser" (rx bos "Qutebrowser"))
             (name-match "Tor Browser" (rx bos "Tor Browser"))
             (mode-match "eww-mode" (rx bos "eww-"))))
  (group
   (group-or "Chat"
             (name-match "Thunderbird" (rx bos "Thunderbird"))
             (name-match "teams-for-linux" (rx bos "teams-for-linux"))
             (mode-match "ement" (rx bos "ement-"))
             (name-match "vesktop" (rx bos "vesktop"))))
  (group
   (group-or "Media"
             (name-match "mpv" (rx bos "Mpv"))
             (mode-match "elfeed-search-mode" (rx bos "elfeed-"))
             (mode-match "elfeed-show-mode" (rx bos "elfeed-"))
	     (mode-match "yeetube-mode" (rx bos "yeetube-"))))
  (group
   (group-or "Agenda"
             (name-match "tasks.org" (rx bos "tasks.org"))
             (mode-match "org-agenda-mode" (rx bos "org-agenda-"))))
  (group
   (group-or "Ledger"
	     (mode-match "ledger-mode" (rx bos "ledger-"))
	     (mode-match "ledger-report-mode" (rx bos "ledger-"))))
  (group
   (group-or "Notes"
             (dir "~/doc/denote/")))
  (group
   (group-or "AV"
             (name-match "lmms" (rx bos "lmms"))
             (name-match "Gimp-2.10" (rx bos "Gimp-2.10"))
             (name-match "kdenlive" (rx bos "kdenlive"))))
  (group
   (group-or "Games"
             (dir "~/.local/PrismLauncher/")
             (name-match "Minecraft" (rx bos "Minecraft"))
             (name-match "PrismLauncher" (rx bos "PrismLauncher"))))
  (group
   ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
   (group-or "Help/Info"
             (mode-match "*Help*" (rx bos (or "help-" "helpful-")))
             (mode-match "*Info*" (rx bos "info-"))
	     (mode-match "Man-mode" (rx bos "Man-"))))
  (group
   ;; Subgroup collecting all special buffers (i.e. ones that are not
   ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
   ;; through to other groups, so they end up grouped with their project buffers).
   (group-and "*Special*"
              (name-match "**Special**"
                          (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace" "Pinentry") "*"))
              (lambda (buffer)
                (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                     buffer)
                            (funcall (mode-match "Dired" (rx bos "dired"))
                                     buffer)
                            (funcall (auto-file) buffer))
                  "*Special*"))))
  (auto-directory))
#+end_src

#+NAME: Emacs Bufler Init
#+begin_src emacs-lisp
;; These functions were adapted from perspective-exwm
(defun bufler-cycle-buffers (proc)
  "Switches to the next or previous buffer in the workspace, if one exists, or the next buffer anywhere, if one doesn't exist."
  (let* ((workspace (bufler-workspace--tab-parameter 'bufler-workspace-path (tab-bar--current-tab-find))))
    (if workspace
        (let* ((current (current-buffer))
               (buffer-list (mapcar #'cdr
                                    (bufler-buffer-alist-at workspace :filter-fns bufler-filter-buffer-fns)))
               (current-pos (or (cl-position current buffer-list) -1))
               (len (length buffer-list))
               (next-pos (% (+ current-pos len
                               (if (eq proc 'evil-next-buffer) (- len 1) -1))
                            len))
               (next-buffer (nth next-pos buffer-list)))
          (switch-to-buffer next-buffer))
      (funcall proc))))
(defun bufler-cycle-buffers-forward ()
  "Cycles the buffers in the workspace forward."
  (interactive)
  (bufler-cycle-buffers 'evil-next-buffer))
(defun bufler-cycle-buffers-backward ()
  "Cycles the buffers in the workspace backward."
  (interactive)
  (bufler-cycle-buffers 'evil-prev-buffer))
#+end_src

#+NAME: Emacs Bufler Config
#+begin_src emacs-lisp
(defun bufler-bar ()
  (interactive)
  (bufler-sidebar)
  (with-selected-window (get-buffer-window "*Bufler*")
    (gsetq window-size-fixed 'width)
    (window-resize (selected-window) (- 35 (window-total-width)) t t)))
#+end_src

*** ELWM
#+NAME: Emacs Window Management ELWM
#+begin_src nix-ts :noweb yes
elwm = {
  enable = true;
  defer = true;
  command = ["elwm-next" "elwm-prev" "elwm-rotate-window" "elwm-derotate-window" "elwm-split-window"];
  config = ''
    <<Emacs Elwm Config>>
  '';
  init = ''
    <<Emacs Elwm Init>>
  '';
};
#+end_src

#+NAME: Emacs Elwm Config
#+begin_src emacs-lisp
(defun elwm-split-window ()
  "Split window according to the current layout.
  
  Window in the master area can't be split, instead the last window
  in the stack will be split.
  
  If selected window is window on the stack, the new window will be
  created next to it, according to the current layout."
  (interactive)
  (let ((buf (current-buffer)))
    (unless (or (eq elwm-current-layout 'monocle) (eq elwm-current-layout 'follow))
	(if (eq (count-windows) 1)
	    (if (eq elwm-current-layout 'tile-vertical-left)
		(evil-window-vsplit)
	      (evil-window-split))
	  (cond
	   ((eq elwm-current-layout 'tile-vertical-left)
	    (if (elwm--in-master-area-p)
		;; split the last window on the stack instead
		(set-window-buffer
		 (select-window (split-window (car (last (elwm--sorted-window-list))) nil nil))
		 buf)
	      (evil-window-split)))
	   ((eq elwm-current-layout 'tile-horizontal-top)
	    (if (elwm--in-master-area-p)
		;; split the last window on the stack instead
		(set-window-buffer
		 (select-window (split-window (car (last (elwm--sorted-window-list))) nil t))
		 buf)
	      (evil-window-vsplit))))))))
#+end_src

#+NAME: Emacs Elwm Init
#+begin_src emacs-lisp
(defun elwm-next ()
  "Go to the next visible window, or if there is 1 window, the next buffer in the workspace"
  (interactive)
  (if (eq (count-windows) 1)
      (bufler-cycle-buffers-forward)
    (elwm-activate-window)))
(defun elwm-deactivate-window () (interactive) (elwm-activate-window (prefix-numeric-value -1)))
(defun elwm-prev ()
  "Go to the previous visible window, or if there is 1 window, the previous buffer in the workspace"
  (interactive)
  (if (eq (count-windows) 1)
      (bufler-cycle-buffers-backward)
    (elwm-deactivate-window)))
(defun elwm-derotate-window () (interactive) (elwm-rotate-window (prefix-numeric-value -1)))
#+end_src

*** Golden Ratio
#+NAME: Emacs Window Management Golden Ratio
#+begin_src nix-ts
golden-ratio = {
  enable = true;
  defer = true;
  ghookf = ["('on-first-input 'golden-ratio-mode)"];
  config = "(general-add-advice 'golden-ratio :after 'exwm-mff-warp-to-selected)";
};
#+end_src

*** EXWM
#+NAME: Emacs Window Management EXWM
#+begin_src nix-ts :noweb yes
exwm = {
  enable = true;
  gfhookf = [
    # When window "class" updates, use it to set the buffer name
    "('exwm-update-class 'efs/exwm-update-class)"
    # When EXWM starts up, do some extra configuration
    "('exwm-init 'efs/exwm-init-hook)"
    "('exwm-mode 'evil-motion-state)"
    # When window title updates, use it to set the buffer name
    "('exwm-update-title 'efs/exwm-update-title)"
  ];
  # Ctrl+q will enable the next key to be sent directly
  generalOne.exwm-mode-map."C-q" = "'exwm-input-send-next-key";
  custom = {
    exwm-manage-force-tiling = true;
    # Emacs everywhere
    exwm-input-simulation-keys = '''(([?\C-h] . [backspace]))'';
    exwm-workspace-number = 1;
    # Automatically move EXWM buffer to current workspace when selected
    exwm-layout-show-all-buffers = true;
    # Display all EXWM buffers in every workspace buffer list
    exwm-workspace-show-all-buffers = true;
    # This will need to be updated to the name of a display!  You can find
    # the names of your displays by looking at arandr or the output of xrandr
    exwm-randr-workspace-monitor-plist = '''(1 "eDP-1-1") (2 "HDMI-0")'';
    # Automatically send the mouse cursor to the selected workspace's display
    exwm-workspace-warp-cursor = true;
    # Window focus should follow the mouse pointer
    mouse-autoselect-window = false;
    focus-follows-mouse = false;
    # These keys should always pass through to Emacs
    exwm-input-prefix-keys = '''(?\M-`
      ?\C-^
                                 ?\M-&
                                 ?\s-\M-'
                                 ?\s-b
                                 ?\M-u
                                 ?\M-:
                                 ?\s-o
                                 ?\s-c
                                 ?\s-v
                                 ?\s-n
                                 ?\s-i
                                 ?\s-e
                                 ?\s-f
                                 ?\s-F
                                 ?\s-u
                                 ?\s-/
                                 ?\s-'	;; popper-toggle-latest
                                 ?\s-\" ;; popper-toggle-type
                                 ?\s-\ 
                                 XF86AudioRaiseVolume
                                 XF86AudioLowerVolume
                                 XF86AudioMute
                                 ?\M-\ )'';
    # Set up global key bindings.  These always work, no matter the input state!
    # Keep in mind that changing this list after EXWM initializes has no effect.
    exwm-input-global-keys = ''`(;; Reset to line-mode (C-c C-k switches to char-mode via exwm-input-release-keyboard)
      ([?\s-r] . exwm-reset)
                                   ([?\s-a] . evil-ex)
    
                                    ;; Launch applications (basically dmenu)
                                    ([?\s-d] . app-launcher-run-app)
                                    ([?\s-t] . proced)
    
                                    ;;Movement
                                    ([?\s-e] . elwm-next)
                                    ([?\s-o] . elwm-prev)

                                    ;; Arrangement
                                    ([?\s-E] . elwm-rotate-window)
                                    ([?\s-O] . elwm-derotate-window)
                                    ([?\s-c] . elwm-split-window)
                                    ([?\s-n] . evil-window-move-far-left)
                                    ([?\s-i] . evil-window-move-far-right)
                                    ([?\s-j] . winner-undo)
                                    ([?\s-J] . winner-redo)
                                    ([?\s-r] . exwm-reset)
                                    ([?\s-m] . toggle-single-window)
                                    ([?\s-x] . toggle-follow-mode)
                                    ([?\s-k] . evil-window-delete)
                                    ([?\s-K] . evil-delete-buffer-and-window)
    
                                    ;; Shell bindings
                                    ([?\s-s] . (lambda () (interactive) (shell-command "slock")))
                                    ([?\s-y] . (lambda () (interactive) (start-process-shell-command "maim" nil  "${pkgs.maim}/bin/maim ~/pic/screenshot.png"))))'';
    
  };
  afterCall = ["on-init-ui-hook"];
  init = ''
    <<Emacs Exwm Init>>
  '';
  config = ''
    <<Emacs Exwm Config>>
  '';
  after = ["repeaters"];
};

exwm-mff = {
  enable = true;
  defer = true;
  command = ["exwm-mff-warp-to-selected"];
};

exwm-outer-gaps = {
  enable = true;
  config = ''(ignore-errors (exwm-outer-gaps-mode))'';
  after = ["exwm"];
};
#+end_src

#+NAME: Emacs Exwm Init
#+begin_src emacs-lisp
(defun efs/exwm-init-hook ()
  ;; Make workspace 0 be the one where we land at startup
  (exwm-workspace-switch-create 0)
  
  ;; Show status in the mode line
  (start-process-shell-command "xbanish" nil "${pkgs.xbanish}/bin/xbanish"))
(defun efs/exwm-update-class ()
  (exwm-workspace-rename-buffer exwm-class-name))

(defun efs/exwm-update-title ()
  (pcase exwm-class-name
    ("qutebrowser" (exwm-workspace-rename-buffer (format "Qutebrowser: %s" exwm-title)))
    ("mpv" (exwm-workspace-rename-buffer (format "Mpv: %s" exwm-title)))))

;; From dmacs
(defvar single-window--last-configuration nil "Last window configuration before calling `delete-other-windows'.")
;; From dmacs
(defun toggle-single-window ()
  "Un-maximize current window.
  If multiple windows are active, save window configuration and
  delete other windows.  If only one window is active and a window
  configuration was previously save, restore that configuration."
  (interactive)
  (if (= (count-windows) 1)
      (when single-window--last-configuration
	(setq elwm-current-layout 'tile-vertical-left)
        (set-window-configuration single-window--last-configuration)
	(when treesitter-context-mode (treesitter-context-focus-mode -1)))
    (setq single-window--last-configuration (current-window-configuration))
    (setq elwm-current-layout 'monocle)
    (delete-other-windows)
    (when (and treesitter-context-mode)
      (treesitter-context-focus-mode 1))))

(defun evil-delete-buffer-and-window ()
  "kill the current buffer & its window"
  (interactive)
  (kill-current-buffer)
  (evil-window-delete))

(defun toggle-follow-mode ()
  "If called while multiple windows are present, deactivates follow mode & kills all other windows.
   If called on only 1 window, activates follow mode & splits the window."
  (interactive)
  (if (= (count-windows) 1)
      (progn (follow-mode 1)
	     (split-window-right)
	     (setq elwm-current-layout 'follow))
    (progn (follow-mode -1)
	   (delete-other-windows)
	   (setq elwm-current-layout 'tile-vertical-left))))
#+end_src

#+NAME: Emacs Exwm Config
#+begin_src emacs-lisp
;; Set the screen resolution (update this to be the correct resolution for your screen!)
(winner-mode)
(require 'exwm-randr)
(exwm-randr-mode)

(repeaters-define-maps
 '(("delete-windows"
    evil-delete-buffer-and-window "K"
    evil-window-delete "k")))
(repeaters-define-maps
 '(("input-keys"
    exwm-input-send-next-key "q")))
(exwm-input-set-key (kbd "s-<return>") 'efs/make-eshell)
(exwm-wm-mode)
#+end_src

*** Popper & Proced
#+NAME: Emacs Window Management Popper & Proced
#+begin_src nix-ts
popper = {
  enable = true;
  ghookf = ["('on-first-buffer 'popper-mode)"];
  general = {
    "s-'" = "'popper-toggle";
    "s-\\\"" = "'popper-cycle";
    "C-s-'" = "'popper-toggle-type";
  };
  custom = {
    popper-window-height = 30;
    popper-group-function = "'popper-group-by-project";
    popper-reference-buffers = '''(help-mode
                                     helpful-mode
                                     compilation-mode
                                     inferior-python-mode
                                     occur-mode
                                     grep-mode
                                     "^\\*.*eshell\\*"
                                     "^\\*eat\\*"
                                     "^\\*Sage\\*"
                                     "^\\*prolog\\*"
                                     flymake-diagnostics-buffer-mode
                                     rustic-cargo-test-mode
                                     rustic-cargo-run-mode
  			                             geiser-repl-mode
                                     dape-repl-mode
  			                             racket-repl-mode
                                     inferior-ess-r-mode
                                     cider-repl-mode)'';
  };
};

proced = {
  enable = true;
  command = ["proced"];
  generalTwoConfig.":n".proced-mode-map = {
    "j" = "'proced-unmark";
    "k" = "'proced-send-signal";
  };
};
#+end_src

*** i3status
#+NAME: i3status
#+begin_src nix-ts
i3status-rust = {
  enable = true;
  bars."default" = {
    blocks = [
		  {
			  block = "time";
			  format =  "$icon $timestamp.datetime(f:'%a %d/%m %R')";
			  interval = 60;
		  }
      # {
      #   block = "music";
      # }
      {
			  block = "battery";
			  format =  "$icon $percentage";
			  interval = 60;
		  }
	  ];
    icons = "awesome6";
    settings.theme.overrides = {
      idle_bg = "#" + config.lib.stylix.colors.base00;
      idle_fg = "#" + config.lib.stylix.colors.base05;
      info_bg = "#" + config.lib.stylix.colors.base00;
      info_fg = "#" + config.lib.stylix.colors.base05;
      good_bg = "#" + config.lib.stylix.colors.base00;
      good_fg = "#" + config.lib.stylix.colors.base05;
      warning_bg = "#" + config.lib.stylix.colors.base00;
      warning_fg = "#" + config.lib.stylix.colors.base05;
      critical_bg = "#" + config.lib.stylix.colors.base00;
      critical_fg = "#" + config.lib.stylix.colors.base05;
      # alternating_tint_bg = "#" + config.lib.stylix.colors.base00;
      separator_bg = "#" + config.lib.stylix.colors.base00;
      separator_fg = "#" + config.lib.stylix.colors.base05;
      separator = "  ";
    };
  };
};

emacs.init.usePackage.i3bar = {
  enable = true;
  ghookf = ["('tab-bar-mode 'i3bar-mode)"];
  
  custom = {
    i3bar-command = ''"${(import ../scripts/i3status-rust.nix {inherit pkgs;})}/bin/i3status-rust"'';
  };
};
#+end_src

*** Ace Window
#+NAME: Emacs Ace Window
#+begin_src nix-ts :noweb yes
ace-window = {
  enable = true;
  custom = {
    aw-scope = "'frame";
    aw-keys = "'(?c ?r ?s ?t ?n ?e ?i ?a)";
  };
  preface = ''
    <<Emacs Ace Window Preface>>
  '';
  init = ''(setopt aw-dispatch-alist '((?k aw-delete-window "Delete Window")
                                       (?m aw-swap-window "Swap Windows")
                                       (?M aw-move-window "Move Window")
                                       (?d aw-copy-window "Copy Window")
                                       (?b aw-switch-buffer-in-window "Select Buffer")
                                       (?f aw-flip-window)
                                       (?u aw-switch-buffer-other-window "Switch Buffer Other Window")
                                       (?x aw-execute-command-other-window "Execute Command Other Window")
                                       (?v efs-aw-split-window-elwm "Split Window")
                                       (?o delete-other-windows "Delete Other Windows")
                                       (?T aw-transpose-frame "Transpose Frame")
                                       (?? aw-show-dispatch-help)))'';
  general."s-/" = "'ace-window";
  config = ''
    <<Emacs Ace Window Config>>
  '';
};
#+end_src

#+NAME: Emacs Ace Window Preface
#+begin_src emacs-lisp
(defun efs-aw-split-window-elwm (window)
  "Split WINDOW horizontally."
  (select-window window)
  (elwm-split-window))
#+end_src

#+NAME: Emacs Ace Window Config
#+begin_src emacs-lisp
(ace-window-posframe-mode)

(defun aw--lead-overlay-posframe (path leaf)
  (let* ((wnd (cdr leaf))
         (str (format "%s" (apply #'string path)))
         ;; It's important that buffer names are not unique across
         ;; multiple invocations: posframe becomes very slow when
         ;; creating new frames, and so being able to reuse old ones
         ;; makes a huge difference. What defines "able to reuse" is
         ;; something like: a frame exists which hasn't been deleted
         ;; (with posframe-delete) and has the same configuration as
         ;; the requested new frame.
         (bufname (format " *aw-posframe-buffer-%s*" path)))
    (with-selected-window wnd
      (push bufname aw--posframe-frames)
      (posframe-show bufname
                     :string str
                     :poshandler aw-posframe-position-handler
		     :refposhandler 'posframe-refposhandler-xwininfo
		     :parent-frame nil
                     :font (face-font 'aw-leading-char-face)
                     :foreground-color (face-foreground 'aw-leading-char-face nil t)
                     :background-color (face-background 'aw-leading-char-face nil t)))))

(general-add-advice 'ace-window :after (lambda (&rest args) (golden-ratio)))
#+end_src

** GPT.el
#+begin_src nix-ts :noweb yes :tangle gptel.nix
{ config, pkgs, inputs, ... }:

{
  programs.emacs.init.usePackage = {
    gptel = {
      enable = true;
      defer = true;
      command = ["start-ollama"];
      custom = {
	gptel-default-mode = "'org-mode";
	gptel-max-tokens = 10000000;
	gptel-prompt-prefix-alist = ''
	  `((markdown-mode . ,(concat "meatbag ›  "))
            (org-mode . ,(concat  "meatbag ›  "))
            (text-mode . ,(concat "meatbag ›  ")))
	'';
	gptel-response-prefix-alist = ''
	  '((markdown-mode . "HK-47  ")
            (org-mode . "HK-47  ")
            (text-mode . "HK-47  "))
	'';
      };
      generalOne.global-leader = {
	"g" = '''(:ignore t :which-key "gptel")'';
	"gs" = '''(start-ollama :which-key "start")'';
	"gp" = '''(gptel :which-key "prompt")'';
      };
      generalTwo.":n".gptel-mode-map."S-RET" = "'gptel-menu";
      preface = ''
	<<Emacs Gptel Preface>>
      '';
      config = ''
	<<Emacs Gpt4all Config>>
      '';
    };

    gptel-quick = {
      enable = true;
      defer = true;
      generalOne = {
	embark-general-map."?" = '''(gptel-quick :which-key "summarize")''; 
	global-leader."gq" = '''(gptel-quick :which-key "summarize")'';
      };
      config = ''
	<<Emacs Gptel Quick Config>>
      '';
    };

    gptel-aibo = {
      enable = true;
      generalOne.":ie" = {
	"M-/" = "'gptel-aibo-complete-at-point";
	"M-?" = "'gptel-aibo-apply-last-suggestions";
      };
    };

    macher = {
      enable = true;
      command = ["macher-install"];
      generalOne.global-leader = {
	"gi" = "'macher-implement";
	"gr" = "'macher-revise";
	"gd" = "'macher-discuss";
	"ga" = "'macher-abort";
      };
    };

    ragmacs = {
      enable = true;
      after = ["gptel"];
      config = ''
	<<Emacs Gpt4all Tools>>
      '';
    };
  };
}
#+end_src

#+NAME: Emacs Gptel Preface
#+begin_src emacs-lisp
(defun start-ollama ()
  (interactive)
  (start-process-shell-command "start-ollama" nil "${(import ./scripts/start-ollama.nix { inherit pkgs config; })}/bin/start-ollama"))
#+end_src

#+NAME: Emacs Gpt4all Tools
#+begin_src emacs-lisp
(gsetq gptel-tools (list ragmacs-eval
			 ragmacs-symbolp
			 ragmacs-load-paths
			 ragmacs-features
			 ragmacs-manuals
			 ragmacs-manual-nodes
			 ragmacs-manual-node-contents
			 ragmacs-featurep
			 ragmacs-library-source
			 ragmacs-symbol-manual-node
			 ragmacs-function-source
			 ragmacs-variable-source
			 ragmacs-variable-value
			 ragmacs-function-docstring
			 ragmacs-variable-docstring
			 ragmacs-function-completions
			 ragmacs-command-completions
			 ragmacs-variable-completions
			 ragmacs-simulate-error
			 ragmacs-coerce-nil
			 ragmacs-all-arg-types
			 ragmacs-async))
#+end_src

#+NAME: Emacs Gpt4all Config
#+begin_src emacs-lisp
(start-ollama)

(setopt gptel-backend (gptel-make-ollama "Ollama"
			:stream t
			:protocol "http"
			:host "localhost:11434"
			:models '(qwen3:latest llama3.2:3b)))

;; (setopt gptel-backend (gptel-make-gh-copilot "Copilot"))
#+end_src

#+NAME: Emacs Gptel Quick Config
#+begin_src emacs-lisp
(setopt gptel-quick-backend (gptel-make-ollama "Ollama"
			      :stream t
			      :protocol "http"
			      :host "localhost:11434"
			      :models '(llama3.2:3b))
	gptel-quick-model 'llama3.2:3b)
#+end_src

** Multimedia
This is where all the audio/video stuff goes
#+begin_src nix-ts :tangle multimedia.nix :noweb yes
{ pkgs, config, inputs, ... }:

{
  home.packages = with pkgs; [
    yt-dlp
    (config.lib.nixGL.wrap obs-studio)
    (config.lib.nixGL.wrap kdePackages.kdenlive)
    lmms
    audacity
    mpc-cli
    doomer
    masstube
    cast
  ];

  <<Mpd>>

  <<Mpv>>

  programs.emacs.init.usePackage = {
    <<Emacs Pulseaudio Control>>
  };
}
#+end_src

*** MPD
#+NAME: Mpd
#+begin_src nix-ts :noweb yes
services.mpd = {
  enable = true;
  musicDirectory = "${config.home.homeDirectory}/mus/mpd";
  extraConfig = ''
    audio_output {
      type "pipewire"
      name "My Pipewire Output"
      mixer_type "hardware"
      mixer_device "default"
      mixer_control "PCM"
    }
  '';
};

programs.emacs.init.usePackage.mpc-wrapper = {
  enable = true;
  generalOne.global-leader = {
    "m" = '''(:ignore t :which-key "mpd")'';
    "mp" = '''(mpc-play :which-key "replay file")'';
    "mm" = '''(music-menu :which-key "menu")'';
    "ms" = '''(mpc-stop :which-key "stop")'';
  };
  deferIncrementally = true;
  config = ''
    <<Emacs Mpc Wrapper Config>>
  '';
};
#+end_src

#+NAME: Emacs Mpc Wrapper Config
#+begin_src emacs-lisp
(defun mpc-add (file)
  "Add FILE to the queue. FILE is a string."
  (shell-command (concat "mpc add " "\"" file "\"")))
(defun music-menu ()
  "Play music from a menu."
  (interactive)
  (mpc-clear)
  (mpc-add (completing-read "Choose a song: " (mpc-ls)))
  (mpc-play))
#+end_src

*** MPV
The mpv package lets us start an mpv process & puppeteer it with emacs. I'm definitely not using it to its full potential.
=efs/mpv-browse-url= originates from https://karthinks.com/software/lazy-elfeed/
#+NAME: Mpv
#+begin_src nix-ts :noweb yes
programs.emacs.init.usePackage.mpv = {
  enable = true;
  command = ["efs/mpv-browse-url" "efs/mpv-eww-url"];
  config = ''
  <<Emacs Mpv Config>>
'';
};

programs.mpv = {
  enable = true;
  package = (config.lib.nixGL.wrap pkgs.mpv);
  config = {
    fs = "no";
    hwdec = "auto";
    x11-bypass-compositor = "no";
    volume-max = "250";
  };
};
#+end_src

#+NAME: Emacs Mpv Config
#+begin_src emacs-lisp
(defun efs/mpv-browse-url (url &optional single)
  (mpv-play-url url))

(defun efs/mpv-eww-url ()
  (interactive)
  (mpv-play-url (eww-current-url)))
#+end_src

*** Pulseaudio Control
#+NAME: Emacs Pulseaudio Control
#+begin_src nix-ts
pulseaudio-control = {
  enable = true;
  custom.pulseaudio-control-volume-step = ''"5%"'';
  general = {
    "<XF86AudioRaiseVolume>" = "'pulseaudio-control-increase-sink-volume";
    "<XF86AudioLowerVolume>" = "'pulseaudio-control-decrease-sink-volume";
    "<XF86AudioMute>" = "'pulseaudio-control-toggle-current-sink-mute";
    "s-v" = "'pulseaudio-control-default-sink-mode";
  };
};
#+end_src

** Sagemath
Sagemath is my goto for dealing with complex math. It makes for a wonderful maple replacement.
#+begin_src nix-ts :tangle sage.nix :noweb yes
{ pkgs, ... }:
{
  home.packages = with pkgs; [ sage ];

  <<Sage Emacs>>

  home.file.".config/sage/ipython-5.0.0/profile_default/startup/00nix.py".text = ''
    <<sage-config>>
  '';
}
#+end_src

*** Useful functions
I wrote these to help me with a class I was taking. I don't really use them anymore
#+NAME: sage-config
#+begin_src python-ts
# Combo functions
def permutation(n, r):
  return factorial(n)/factorial(n - r)

def combo(n, r):
  return permutation(n, r)/factorial(r)

# Probstats functions
def pbinary(n, p, x):
  """Returns the probability of a binary distribution"""
  return combo(n, x)*(p**x)*((1-p)**(n-x))

def ebinary(n, p):
  """Returns the expectation (mean) of a binary distribution"""
  return n*p

def ppoisson(x, lam):
  """Returns the probability of the poisson distribution"""
  return (exp(-lam)*lam**x)/factorial(x)
def poisprocess(lam, s, t, n):
  """Returns the probability of the poisson process
        lam: lambda (the rate)
        s: the start time
        t: the end time
        n: the number of occurrances"""
  return (((lam*(t - s))**n)*exp(-lam*(t - s)))/factorial(n)

def expecpoisprocess(lam, s, t):
  """Returns the expectancy of a poisson process
       lam: lambda (the rate)
        s: the start time
        t: the end time"""
  return lam*(t-s)

def pnormal(x, mu, sigma):
  """Returns the probability of a normal random variable
     x: the other variable
     mu: the expectancy
     sigma: the variance"""
  return exp(-((x-mu)**2)/(2*sigma))/sqrt(2*pi*sigma)
#+end_src

*** Emacs
Putting =:session= in an org block is necessary for evaluation
,cgo clears your sage buffer.
,cc evaluates the sage commands in an org file.
#+NAME: Sage Emacs
#+begin_src nix-ts
programs.emacs.init.usePackage = {
  sage-shell-mode = {
    enable = true;
    defer = true;
    custom."sage-shell-edit:display-function" = ''"display-buffer"'';
    config = ''(sage-shell:define-alias)'';
    generalOne.global-leader."S" = '''(run-sage :which-key "sage")'';
    generalTwo."local-leader"."sage-shell-mode-map"."h" = "'sage-shell:help";
  };

  ob-sagemath = {
    enable = true;
    afterCall = ["sage-shell-mode" "ob"];
  };
};
#+end_src

** Internet
#+begin_src nix-ts :tangle internet.nix :noweb yes
{ inputs, config, pkgs, lib, ... }:

{
  home.packages = with pkgs; [
    python313Packages.adblock
  ];

  programs.emacs.init.usePackage = {
    <<Emacs Internet Browse URL>>

    <<Emacs Internet EWW>>

    <<Emacs Internet Yeetube>>

    # <<Emacs Internet Ement>>

    <<Emacs Internet Webjump>>

    <<Emacs Internet Elfeed>>
  };

  <<Internet Qutebrowser>>
}
#+end_src

*** Browse URL
This lets us decide how emacs will handle certain urls
+ Under most circumstances, a youtube link will be opened by mpv (notable exception being if we're searching)
You need regexes to do this, & you can build them easily using =rx=
#+NAME: Emacs Internet Browse URL
#+begin_src nix-ts
browse-url = {
  enable = true;
  config = "(defun qutebrowser-browse-url (url &rest args) (qutebrowser-open-url url 'tab))";
  custom = {
    browse-url-handlers = ''
      '(("https:\\/\\/www\\.youtu\\.*be." . efs/mpv-browse-url)
        ("https:\\/\\/yewtu\\.*be." . efs/mpv-browse-url)
        ("https:\\/\\/inv\\.*nadeko\\.*net\\/watch." . efs/mpv-browse-url)
        ("search\\.nixos\\.org[^z-a]*" . qutebrowser-browse-url)
        ("melpa\.org\.*" . qutebrowser-browse-url)
        ("." . (lambda (url &rest args) (eww url (prefix-numeric-value 4)))))
    '';
    browse-url-secondary-browser-function = "'browse-url-default-browser";
  };
};
#+end_src

*** EWW
It's a simple text based web browser. I use it for short web searches & for finding youtube videos
#+NAME: Emacs Internet EWW
#+begin_src nix-ts :noweb yes
eww = {
  enable = true;
  custom = {
    eww-search-prefix = ''"https://search.inetol.net/?q="'';
    eww-header-line-format = false;
    eww-desktop-remove-duplicates = true;
    eww-download-directory = ''(expand-file-name "~/dwn")'';
    eww-history-limit = 10;
    # External Browser
    eww-use-external-browser-for-content-type = ''"\\`\\(video/\\|audio\\)"''; # On GNU/Linux check your mimeapps.list
    eww-browse-url-new-windowis-tab = false;
    eww-form-checkbox-selected-symbol = ''"[X]"'';
    eww-form-checkbox-symbol = ''"[ ]"'';
    eww-auto-rename-buffer = "'title";
  };
  generalTwo.":n".eww-mode-map = {
    "N" = "#'eww-back-url";
    "I" = "#'eww-forward-url";
    "P" = "#'eww-copy-page-url";
    "R" = "'eww-readable";
  };
  init = ''
    <<Emacs Internet Eww Config>>
  '';
};
#+end_src

#+NAME: Emacs Internet Eww Config
#+begin_src emacs-lisp
(with-eval-after-load 'evil-collection-eww
  (general-add-advice 'evil-collection-eww-setup
		      :after
		      '(lambda ()
			 (general-def 'normal eww-mode-map
			   "d" 'evil-yank
			   "p" 'efs/mpv-eww-url))))
#+end_src

*** Yeetube
#+NAME: Emacs Internet Yeetube
#+begin_src nix-ts
yeetube = {
  enable = true;
  custom.yeetube-play-function = "'mpv-play-url";
  generalOne.global-leader."y" = '''(yeetube-search :which-key "search")'';
  generalTwo.":n"."yeetube-mode-map" = {
    "RET" = "'yeetube-play";
    "r" = "'yeetube-channel-videos";
    "s" = "'yeetube-channel-search";
    "d" = "'yeetube-download-video";
  };
};
#+end_src

*** Ement
Ement username: @holscherhead:matrix.org
Use S-SPC to load old messages
#+NAME: Emacs Internet Ement
#+begin_src nix-ts :noweb yes
ement = {
  enable = true;
  defer = true;
  generalOne = {
    global-leader."e" = '''(ement-connect :which-key "element")''; 
    local-leader."s" = '''(ement-sidebar :which-key "sidebar")'';
  };
  init = ''
    <<Emacs Internet Ement Init>>
  '';
};
#+end_src

#+NAME: Emacs Internet Ement Init
#+begin_src emacs-lisp
  (defun ement-sidebar ()
    (interactive)
    (ement-room-list-side-window)
    (with-selected-window (get-buffer-window "*Ement Room List*")
      (gsetq window-size-fixed 'width)
      (window-resize (selected-window) (- 45 (window-total-width)) t t)))
#+end_src

*** Webjump
#+NAME: Emacs Internet Webjump
#+begin_src nix-ts :noweb yes
webjump = {
  enable = true;
  generalOne.global-leader."s" = "'webjump";
  custom.webjump-sites = ''
    '(("DuckDuckGo" . [simple-query "duckduckgo.com" "duckduckgo.com/?q=" ""])
      ("Invidious" . [simple-query "inv.nadeko.net" "inv.nadeko.net/search?q=" ""])
      ("Aur" . [simple-query "aur.archlinux.org" "aur.archlinux.org/packages/?K=" ""])
      ("Nixpkgs" . [simple-query "search.nixos.org" "search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=" ""])
      ("Curseforge" . webjump-to-curseforge))
  '';
  config = ''
    <<Emacs Internet Webjump Config>>
  '';
};
#+end_src

#+NAME: Emacs Internet Webjump Config
#+begin_src emacs-lisp
(defun webjump-to-curseforge (name)
  (let* ((prefix "legacy.curseforge.com/minecraft/")
         (category (completing-read "Choose a category" '("mc-mods" "modpacks" "shaders" "data-pack" "texture-packs")))
	 (url (concat prefix category))
	 (term (webjump-read-string (concat name " Search for"))))
    (concat url "/search?search=" (webjump-url-encode term))))
#+end_src

*** Elfeed
#+NAME: Emacs Internet Elfeed
#+begin_src nix-ts
elfeed = {
  enable = true;
  defer = true;
  custom.elfeed-feeds = '''("https://lukesmith.xyz/index.xml"
                            "https://youtube.com/feeds/videos.xml?channel_id=UCSJPFQdZwrOutnmSFYtbstA"
                            "https://planet.emacslife.com/atom.xml"
                            "https://youtube.com/feeds/videos.xml?channel_id=UC_GQ4mac4oN3wl1UdbFuTEA"
                            "https://youtube.com/feeds/videos.xml?channel_id=UC6UBbvEA8uh6Ulc6ax1Zs0g"
                            "https://youtube.com/feeds/videos.xml?channel_id=UCNzZD3otfZVlIdvYYRRqNSw"
                            "https://youtube.com/feeds/videos.xml?channel_id=UCnnkTXnyn0uZzmArZO99Klg"
                            "https://youtube.com/feeds/videos.xml?channel_id=UCq-VIBjS6Ia1r1IR_j-7NUw"
                            "https://youtube.com/feeds/videos.xml?channel_id=UC0E_vIe1e1lVeojYOgVg_5Q"
                            "https://youtube.com/feeds/videos.xml?channel_id=UCUQs6rEz6lRGHn6DWqss0hA"
                            "https://notrelated.xyz/rss")
    '';
  generalOne.global-leader."r" = "(cmd! () (elfeed) (elfeed-update))";
};
#+end_src

*** Qutebrowser
https://greasyfork.org/en/scripts/374833-yt2invidio
#+NAME: Internet Qutebrowser
#+begin_src nix-ts :noweb yes
programs.qutebrowser = {
  enable = true;
  enableDefaultBindings = true;
  package = (config.lib.nixGL.wrap pkgs.qutebrowser);

  <<Internet Qutebrowser Keybinds>>

  <<Internet Qutebrowser Greasemonkey>>

  <<Internet Qutebrowser Aliases>>

  <<Internet Qutebrowser Search>>
  
  settings = {
    <<Internet Qutebrowser Privacy>>

    <<Internet Qutebrowser Dir>>

    <<Internet Qutebrowser Transparency>>

    <<Internet Qutebrowser File Selection>>

    <<Internet Qutebrowser Tabs>>

    <<Internet Qutebrowser Links>>

  };

  <<Internet Qutebrowser Extraconfig>>
};

<<Internet Qutebrowser Emacs Integration>>
#+end_src

**** Keybinds
https://redlib.northboot.xyz/r/qutebrowser/comments/eh10i7/config_share_qute_with_emacs_keybindings/
#+NAME:Internet Qutebrowser Keybinds
#+begin_src nix-ts
keyBindings = {
  normal = {
    "m" = "search-next";
    "M" = "search-prev";
    "e" = "fake-key <Down>";
    "o" = "fake-key <Up>";
    "O" = "scroll-page 0 -0.5";
    "E" = "scroll-page 0 0.5";
    "<ctrl-o>" = "scroll-page 0 -1";
    "<ctrl-e>" = "scroll-page 0 1";
    "t" = "mode-enter insert";
    "I" = "forward";
    "i" = "fake-key <Right>";
    "n" = "fake-key <Left>";
    "N" = "back";
    "k" = "hint links spawn mpv {hint-url}";
    "h" = "spawn --userscript emacsclient-wrapper '(qutebrowser-launcher)'";
    "H" = "spawn --userscript emacsclient-wrapper '(qutebrowser-launcher-tab)'";
    ";l" = "spawn --userscript qute-pass";
    ";u" = "spawn --userscript qute-pass --username-only";
    ";p" = "spawn --userscript qute-pass --password-only";
    ";o" = "spawn --userscript qute-pass --otp-only";
    ";P" = "spawn --userscript emacsclient-wrapper '(qutebrowser-pass \"{url}\")'";
    "a" = "cmd-set-text :";
    "<ctrl-f>" = "hint links spawn mpv {hint-url}";
  };
};
#+end_src

**** Greasemonkey Scripts
#+NAME: Internet Qutebrowser Greasemonkey
#+begin_src nix-ts :noweb yes
greasemonkey = [
  (pkgs.fetchurl {
		url = "https://raw.githubusercontent.com/afreakk/greasemonkeyscripts/1d1be041a65c251692ee082eda64d2637edf6444/youtube_sponsorblock.js";
		sha256 = "sha256-e3QgDPa3AOpPyzwvVjPQyEsSUC9goisjBUDMxLwg8ZE=";
	})
  (pkgs.fetchurl {
		url = "https://raw.githubusercontent.com/afreakk/greasemonkeyscripts/refs/heads/master/youtube_adblock.js";
		sha256 = "sha256-AyD9VoLJbKPfqmDEwFIEBMl//EIV/FYnZ1+ona+VU9c=";
	})
];
#+end_src

**** Aliases
#+NAME: Internet Qutebrowser Aliases
#+begin_src nix-ts
aliases = {
  "q" = "quit";
  "w" = "session-save";
  "wq" = "quit --save";
};
#+end_src

**** Autoconfig & Search Engines
#+NAME: Internet Qutebrowser Search
#+begin_src nix-ts
loadAutoconfig = false;
searchEngines = {
  "DEFAULT" = "https://search.inetol.net/search?q={}";
};
#+end_src

**** Some privacy Settings
#+NAME: Internet Qutebrowser Privacy
#+begin_src nix-ts
content = {
  blocking = {
    enabled = true;
    method = "both";
    adblock.lists = [
      "https://easylist.to/easylist/easylist.txt"
      "https://easylist.to/easylist/easyprivacy.txt"
      "https://easylist.to/easylist/fanboy-social.txt"
      "https://secure.fanboy.co.nz/fanboy-annoyance.txt"
      "https://easylist-downloads.adblockplus.org/abp-filters-anti-cv.txt"
      #"https://gitlab.com/curben/urlhaus-filter/-/raw/master/urlhaus-filter.txt"
      "https://pgl.yoyo.org/adservers/serverlist.php?showintro=0;hostformat=hosts"
      "https://raw.githubusercontent.com/DandelionSprout/adfilt/master/NorwegianExperimentalList%20alternate%20versions/NordicFiltersABP-Inclusion.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/legacy.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters-2020.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/filters-2021.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/badware.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/privacy.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/badlists.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/annoyances.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/resource-abuse.txt"
      "https://www.i-dont-care-about-cookies.eu/abp/"
      "https://secure.fanboy.co.nz/fanboy-cookiemonster.txt"
      "https://github.com/uBlockOrigin/uAssets/raw/master/filters/unbreak.txt"
      "https://raw.githubusercontent.com/uBlockOrigin/uAssets/master/filters/quick-fixes.txt"
    ];
  };
  autoplay = false;
  cookies.store = false;
  geolocation = false;
  private_browsing = true;
};
completion = {
  cmd_history_max_items = 0;
  web_history.max_items = 0;
};
#+end_src

**** Download Dir & Startpage
#+NAME: Internet Qutebrowser Dir
#+begin_src nix-ts
downloads.location.directory = "~/dwn";
url = {
  default_page = "https://search.inetol.net";
  start_pages = "https://search.inetol.net";
};
#+end_src

**** Transparency
This is a very ugly way of doing things
#+NAME: Internet Qutebrowser Transparency
#+begin_src nix-ts
window.transparent = true;
colors = {
  completion = {
    category = {
      bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
      border = {
        bottom = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
        top = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
      };
    };
    even.bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
    odd.bg = lib.mkForce ("#90" + config.lib.stylix.colors.base00);
  };
  statusbar = {
    command = {
      bg = lib.mkForce ("#50" + config.lib.stylix.colors.base00);
      private.bg = lib.mkForce ("#50" + config.lib.stylix.colors.base00);
    };
  };
};
#+end_src

**** File Selection
#+NAME: Internet Qutebrowser File Selection
#+begin_src nix-ts
fileselect = {
  handler = "external";
  single_file.command = [
    "emacsclient"
    "{}"
  ];
  folder.command = [
    "emacsclient"
    "{}"
  ];
  multiple_files.command = [
    "emacsclient"
    "{}"
  ];
};
#+end_src

**** WM Related
#+NAME: Internet Qutebrowser Tabs
#+begin_src nix-ts
tabs = {
  tabs_are_windows = true;
  show = "never";
};

window.title_format = "{current_title}";
new_instance_open_target = "tab-silent";
statusbar.show = "never";
#+end_src

**** Link Hints
#+NAME: Internet Qutebrowser Links
#+begin_src nix-ts
hints.chars = "crstbfneia";
#+end_src

**** Extra Config
#+NAME: Qutebrowser Config
#+begin_src python-ts
config.set('content.cookies.accept', 'no-3rdparty', 'chrome-devtools://*')
config.set('content.cookies.accept', 'no-3rdparty', 'devtools://*')

config.set('content.images', True, 'chrome-devtools://*')
config.set('content.images', True, 'devtools://*')

config.set('content.javascript.enabled', True, 'chrome-devtools://*')
config.set('content.javascript.enabled', True, 'devtools://*')
config.set('content.javascript.enabled', True, 'chrome://*/*')
config.set('content.javascript.enabled', True, 'qute://*/*')

config.set('content.notifications.enabled', False, 'https://www.reddit.com')
config.set('content.notifications.enabled', False, 'https://www.youtube.com')

config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}) AppleWebKit/{webkit_version} (KHTML, like Gecko) {upstream_browser_key}/{upstream_browser_version} Safari/{webkit_version}', 'https://web.whatsapp.com/')
config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://accounts.google.com/*')
config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info} rv:110.0) Gecko/20100101 Firefox/119.0', 'https://*.slack.com/*')
config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://docs.google.com/*')
config.set('content.headers.user_agent', 'Mozilla/5.0 ({os_info}; rv:71.0) Gecko/20100101 Firefox/119.0', 'https://drive.google.com/*')

c.editor.command = ['emacsclient', '{file}']

c.fonts.default_family = '"Source Code Pro"'
c.fonts.default_size = '8pt'
c.fonts.completion.entry = '8pt "Source Code Pro"'
c.fonts.debug_console = '8pt "Source Code Pro"'
c.fonts.prompts = 'default_size sans-serif'
#+end_src

#+NAME: Internet Qutebrowser Extraconfig
#+begin_src nix-ts :noweb yes
extraConfig = ''
  <<Qutebrowser Config>>
'';
#+end_src

**** Emacs Integration
#+NAME: Internet Qutebrowser Emacs Integration
#+begin_src nix-ts :noweb yes
programs.emacs.init.usePackage = {
  qutebrowser = {
    enable = true;
    ghookf = [
      "('exwm-init 'global-qutebrowser-exwm-mode)"
    ];
    gfhookf = [
      "('server-visit 'qute/dired-hook)"
      "('qutebrowser-exwm-mode 'evil-normal-state)"
    ];
    config = ''
      <<Emacs Internet Qutebrowser Config>>
    '';
    generalOneConfig.qute-dired-mode-map."C-c C-c" = "#'qute/choose-file";
    generalTwoConfig.":n".qute-dired-mode-map = {
      "i" = "'dired-find-file";
      "n" = "'dired-up-directory";
    };
  };
  qutebrowser-evil = {
    enable = true;
    package = epkgs: epkgs.qutebrowser;
    ghookf = [
      "('global-qutebrowser-exwm-mode 'qutebrowser-evil-state-mode)"
    ];
  };
};
#+end_src

#+NAME: Emacs Internet Qutebrowser Config
#+begin_src emacs-lisp
(define-minor-mode qute-dired-mode
  "Used for dired buffers qutebrowser is using as a file picker"
  :keymap '())

(defun qute/choose-file ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (with-temp-file qute-filename
      (insert (s-join "\n" files)))
    (remove-hook 'dired-mode-hook 'qute-dired-mode)
    (dolist (buffer dired-buffers) (when qute-dired-mode (kill-buffer (cdr buffer))))))

(defun qute/dired-hook (&optional _)
  (when (s-starts-with? "/tmp/qutebrowser-fileselect" buffer-file-name)
    (setq qute-filename buffer-file-name)
    (kill-buffer)
    (add-hook 'dired-mode-hook 'qute-dired-mode)
    (setq qute-dired-buffers (list (dired "~/")))))
#+end_src

** Keyboard
I use kmonad to manage my keybinds.
Canary is my layout of choice.
#+begin_src nix-ts :tangle keyboard.nix
{ ... }:

{
  home.file = {
    ".config/kmonad/kmonad.kbd".text = ''
      ;; ** For Linux **
      (defcfg
      input  (device-file "/dev/input/by-path/platform-i8042-serio-0-event-kbd") ;; Change this line for your device
      output (uinput-sink "KMonad output")

      fallthrough true)

      (defsrc
        esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
        grv     1    2    3    4    5    6    7    8    9    0    -    =    bspc      ins     home    pgup
        tab     q    w    e    r    t    y    u    i    o    p    [    ]    \         del     end     pgdn
        caps    a    s    d    f    g    h    j    k    l    ;    '    ret
        lsft    z    x    c    v    b    n    m    ,    .    /    rsft                         up
        lctl    lmet lalt           spc            ralt    rctl                       left    down    right)

      (defalias
        def  (tap-macro nlck (layer-switch canary)) ;; Bind 'def' to canary Layer
        caps  (tap-macro nlck (layer-switch canary-shift)) ;; Bind 'def' to canary Layer
        cesc (tap-hold 200 esc (layer-toggle extend))
        sesc (tap-hold 200 S-esc (layer-toggle extend))
        num (sticky-key 500 (layer-toggle num))
        qwerty (tap-macro nlck (layer-switch qwerty)) ;; Bind 'def' to canary Layer
        smet (sticky-key 500 lmet)
        salt (sticky-key 500 lalt)
        sshft (sticky-key 500 lshft)
        spc (tap-hold 200 spc caps)
        SPC (tap-hold 200 S-spc caps)
        c (tap-hold 200 c lmet)
        r (tap-hold 200 r lalt)
        s (tap-hold 200 s lctl)
        t (tap-hold 200 t (layer-toggle canary-shift))
        a (tap-hold 200 a lmet)
        i (tap-hold 200 i lalt)
        e (tap-hold 200 e lctl)
        n (tap-hold 200 n (layer-toggle canary-shift))
        C (tap-hold 200 C lmet)
        R (tap-hold 200 R lalt)
        S (tap-hold 200 S lctl)
        A (tap-hold 200 A lmet)
        I (tap-hold 200 I lalt)
        E (tap-hold 200 E lctl)
        wlft C-left
        wrht C-right
        bhst A-left
        fhst A-right)
      (deflayer canary
        esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
        $       &    [    {    }    \(   =    *    \)   +    ]    !    `    bspc      ins     home    pgup
        tab     w    l    y    p    k    z    x    o    u    ;    -    @    \         del     end     pgdn
        @cesc   @c   @r   @s   @t   b    f    @n   @e   @i   @a   '    ret
        shft   j    v    d    g    q    m    h    /    ,    .    @sshft                      up
        caps   @smet @num           @spc             caps     rctl                    left    down    right)

      (deflayer canary-shift
        S-esc   S-f1 S-f2 S-f3 S-f4 S-f5 S-f6 S-f7 S-f8 S-f9 S-f10 S-f11 S-f12        S-prnt  S-slck  S-pause
        ~       %    7    5    3    1    9    0    2    4    6    8    #  S-bspc      S-ins   S-home  S-pgup
        S-tab   W    L    Y    P    K    Z    X    O    U    :    \_   ^    S-\        S-del   S-end   S-pgdn
        @sesc   @C   @R   @S   T    B    F    N   @E   @I   @A    "    S-ret
        @sshft   J    V    D    G    Q    M    H    ?    <    >    @sshft                     S-up
        caps   @smet @def           @SPC             caps    rctl                   S-left S-down S-right)

      (deflayer qwerty
        esc     f1   f2   f3   f4   f5   f6   f7   f8   f9   f10  f11  f12            prnt    slck    pause
        grv     1    2    3    4    5    6    7    8    9    0    -    =    bspc      ins     home    pgup
        tab     q    w    e    r    t    y    u    i    o    p    [    ]    \         del     end     pgdn
        caps    a    s    d    f    g    h    j    k    l    ;    '    ret
        lsft    z    x    c    v    b    n    m    ,    .    /    rsft                         up
        lctl    lmet lalt           spc            @def     rctl                     left    down    right)

      (deflayer extend
        _       _    _    _    _    _    _    _    _    _    _    _    _              _    _    _
        _     f11    f7   f5   f3   f1   f9  f10   f2   f4   f6   f8  f12   _         _    _    _
        _   @bhst @fhst  C-z  C-x   C-c  C-z @wlft up  @wrht  _    _    _    _         _    _    _
        _   @smet @salt lctl @sshft del bspc left down right _    _    _
        _         _    _  @caps    _    _    _    h    _    _    _    _                      _
        _       _    _               ret              @qwerty        _                     _    _    _)
    
      (deflayer num
        _       _    _    _    _    _    _    _    _    _    _    _    _              _    _    _
        _     f11    f7   f5   f3   f1   f9  f10   f2   f4   f6   f8  f12   _         _    _    _
        _       \_    =    +    -    [    ]    7    8    9   &    ^    _    _         _    _    _
        _   @smet @salt lctl @sshft  {    }    4    5    6   0    *    _
        _        @    !    $     \(  ~  \)    1    2    3    #    _                      _
        _       _    _               ret              _        _                     _    _    _)
    '';
      
    ".Xmodmap".text = ''
      clear lock
      clear mod3
      clear mod4
      keycode 66 = Hyper_R
      keycode 105 = Caps_Lock
      add mod3 = Hyper_L Hyper_R
      add mod4 = Super_L Super_R
    '';
  };
}
#+end_src

